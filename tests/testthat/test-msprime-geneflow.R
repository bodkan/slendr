skip_if(!env_present("retipy"))

# Let's start by defining a couple of parameters for our simulations
seed <- 42 # random seed
seq_len <- 250e6 # amount of sequence to simulate
rec_rate <- 1e-8 # uniform recombination rate
mut_rate <- 1e-8 # mutation rate

# Now we define a very simple population model. Note that the Ne of the
# populations `x1` and `x2` is set to be much higher than the rest. The Ne of
# the other populations is low to speed up the simulation (they won't affect the
# results anyway), but increasing the Ne of the `x1` and `x2` will ensure that
# the effect of the drift acting on those two populations will be minimal.
# Because we will simulate (and, later, measure) the proportion of ancestry from
# the population `c`` to `x1`, this will ensure that the ancestry proportion
# will not drift too far away from the expectation.
#
# (Of course, this is all done for demonstration purposes only and to speed up
# the SLiM simulations by making the Ne of the other populations smaller.)
o <- population("o", time = 10, N = 1)
b <- population("b", parent = o, time = 500, N = 10)
c <- population("c", parent = b, time = 1000, N = 10)
x1 <- population("x1", parent = c, time = 2000, N = 10000)
x2 <- population("x2", parent = c, time = 2000, N = 10000)
a <- population("a", parent = b, time = 1500, N = 10)

# no gene flow model
model_nogf <- compile(populations = list(a, b, x1, x2, c, o), generation_time = 1, overwrite = TRUE, sim_length = 2200)

samples <- sampling(model_nogf, times = 2200, list(a, 1), list(b, 1), list(x1, 50), list(x2, 50), list(c, 1), list(o, 1))

slim(model_nogf, sequence_length = seq_len, recombination_rate = rec_rate, sampling = samples, random_seed = seed)
msprime(model_nogf, sequence_length = seq_len, recombination_rate = rec_rate, sampling = samples, random_seed = seed)

# model with gene flow
gf <- geneflow(from = b, to = x1, start = 2100, end = 2150, rate = 0.1)

model_gf <- compile(populations = list(a, b, x1, x2, c, o), geneflow = gf, generation_time = 1, overwrite = TRUE, sim_length = 2200)

samples <- sampling(model_gf, times = 2200, list(a, 1), list(b, 1), list(x1, 50), list(x2, 50), list(c, 1), list(o, 1))

slim(model_gf, sequence_length = seq_len, recombination_rate = rec_rate, sampling = samples, random_seed = seed)
msprime(model_gf, sequence_length = seq_len, recombination_rate = rec_rate, sampling = samples, random_seed = seed)

# Load tree sequence files saved by the SLiM backend script from the two models:
suppressWarnings({
slim_nogf <- ts_load(model_nogf, recapitate = TRUE, simplify = TRUE, mutate = TRUE,
                     Ne = 10, recombination_rate = rec_rate, mutation_rate = mut_rate, random_seed = seed)

slim_gf <- ts_load(model_gf, recapitate = TRUE, simplify = TRUE, mutate = TRUE,
                   Ne = 10, recombination_rate = rec_rate, mutation_rate = mut_rate, random_seed = seed)
})

# Extract vector of names of the "test individuals" in populations `x1` and `x2`:
X_individuals <- ts_samples(slim_gf) %>%
  dplyr::filter(pop %in% c("x1", "x2")) %>%
  dplyr::pull(name)

# Calculate f4-statistics on individuals of `x1` and `x2` populations using data
# from the two models (a model with no gene flow and a gene flow model):
df_slim_f4 <- rbind(
  purrr::map_dfr(X_individuals, ~ ts_f4(slim_nogf, "c_1", .x, "b_1", "o_1")) %>% dplyr::mutate(model = "no gene flow"),
  purrr::map_dfr(X_individuals, ~ ts_f4(slim_gf, "c_1", .x, "b_1", "o_1")) %>% dplyr::mutate(model = "gene flow")
) %>%
  dplyr::select(X, f4, model) %>%
  dplyr::mutate(simulator = "SLiM backend")

# Compute the proportions of `b` ancestry in `x1` (expected 10%) and `x2`
# (expected 0% because this population did not receive any gene flow from `b`):
df_slim_f4ratio <- dplyr::bind_rows(
  purrr::map_dfr(X_individuals, ~ ts_f4ratio(slim_nogf, .x, "a_1", "b_1", "c_1", "o_1")) %>% dplyr::mutate(model = "no gene flow"),
  purrr::map_dfr(X_individuals, ~ ts_f4ratio(slim_gf, .x, "a_1", "b_1", "c_1", "o_1")) %>% dplyr::mutate(model = "gene flow")
) %>%
  dplyr::select(X, alpha, model) %>%
  dplyr::mutate(simulator = "SLiM backend")

# Although we can run slendr model with an msprime setting, for most of the time
# of existence of slendr the tree sequences from SLiM and msprime were not 100%
# interchangeable. Until this is resolved (and it will be resolved soon), we
# will demonstrate how to repeat the same f4 an f4-ratio analysis we performed
# above using the slendr/tskit interface using a "raw" reticulate interface to
# the Python tskit and msprime modules.
#
# Although mildly annoying (the ultimate goal is to be able to analyse tree
# sequence data with slendr's R interface regardless of which simulator produced
# it), it will be instructive to show how this can be done.

# msprime alternative of slendr's ts_load() function for tree sequences
# generated by the msprime backend
load_msprime_ts <- function(model, mut_rate, seed) {
  path <- file.path(model$path, "output_msprime.trees")

  ts <- tskit$load(path.expand(path))
  ts <- msp$sim_mutations(ts, rate = mut_rate, random_seed = seed)
  ts
}

# First, let's write a function which will pull out node IDs of each individual
# (i.e. its two chromosome IDs) from the tree sequence table metadata:
get_individuals <- function(ts) {
  pop_ids <- seq(0, ts$num_populations - 1)
  dplyr::tibble(
    pop = sapply(pop_ids, function(i) ts$population(as.integer(i))$metadata$name),
    nodes = lapply(pop_ids, function(i) ts$samples(as.integer(i)))
  ) %>%
    dplyr::mutate(
      pairs = purrr::map(nodes, function(n) purrr::map2(n[seq(1, length(n), 2)],
                                                        n[seq(2, length(n), 2)],
                                                        ~ c(.x, .y))
      )) %>%
    tidyr::unnest(pairs) %>%
    dplyr::select(-nodes) %>%
    dplyr::group_by(pop) %>%
    dplyr::mutate(ind = paste0(pop, "_", 1:dplyr::n()))
}

# Next, let's write our own f4 and f4-ratio functions with an interface
# analogous to those which are already part of the slendr library:
msprime_f4 <- function(ts, w, x, y, z) {
  individuals <- get_individuals(ts)

  w_nodes <- dplyr::filter(individuals, ind == w)$pairs[[1]]
  x_nodes <- dplyr::filter(individuals, ind == x)$pairs[[1]]
  y_nodes <- dplyr::filter(individuals, ind == y)$pairs[[1]]
  z_nodes <- dplyr::filter(individuals, ind == z)$pairs[[1]]

  ts$f4(sample_sets = list(w_nodes, x_nodes, y_nodes, z_nodes))
}

msprime_f4ratio <- function(ts, x, a, b, c, o) {
  num <- msprime_f4(ts, a, o, x, c)
  den <- msprime_f4(ts, a, o, b, c)
  num / den
}

# With the variants of slendr functions operating on msprime-produced tree
# sequences in place, let's repeat the same analyses we performed on
# SLiM-produced tree sequences above.

# First, let's load the tree sequences we got from slendr's msprime backend:
msprime_nogf <- load_msprime_ts(model_nogf, mut_rate, seed)
msprime_gf <- load_msprime_ts(model_gf, mut_rate, seed)

# Now we compute the f4-statistic test for the presence of evidence of gene flow
# from the `b` population to the `x1` population (and its absence for the `x2`
# population). For this, we will use the same vector of names of the `x1`` and
# `x2` individuals created from the SLiM-produced tree sequence above:

df_msprime_f4 <- rbind(
  dplyr::tibble(
    X = X_individuals,
    f4 = sapply(X_individuals, function(i) msprime_f4(msprime_nogf, "c_1", i, "b_1", "o_1")),
    model = "no gene flow",
    simulator = "msprime backend"
  ),
  dplyr::tibble(
    X = X_individuals,
    f4 = sapply(X_individuals, function(i) msprime_f4(msprime_gf, "c_1", i, "b_1", "o_1")),
    model = "gene flow",
    simulator = "msprime backend"
  )
)

# Let's also quantify the *amount* of 'b' ancestry in 'x1' vs 'x2' individuals
# using the f4-ratio statistic:

df_msprime_f4ratio <- rbind(
  dplyr::tibble(
    X = X_individuals,
    alpha = sapply(X_individuals, function(i) msprime_f4ratio(msprime_nogf, i, "a_1", "b_1", "c_1", "o_1")),
    model = "no gene flow",
    simulator = "msprime backend"
  ),
  dplyr::tibble(
    X = X_individuals,
    alpha = sapply(X_individuals, function(i) msprime_f4ratio(msprime_gf, i, "a_1", "b_1", "c_1", "o_1")),
    model = "gene flow",
    simulator = "msprime backend"
  )
)

# Now for the real test: we defined several population genetic models. If
# everything works as expected, this model should produce the same result (or
# nearly the same result, taking into account uncertainty and randomness)
# regardless of whether we run it through the SLiM forward simulation backend
# engine or msprime coalescent backend engine:

df_f4 <- rbind(df_slim_f4, df_msprime_f4) %>%
  dplyr::mutate(population = ifelse(grepl("x1_", X),
                                    "x1 (received gene flow)",
                                    "x2 (no gene flow)")) %>%
  as.data.frame()

current_f4_tsv <- paste0(tempfile(), ".tsv.gz")
readr::write_tsv(df_f4, current_f4_tsv, progress = FALSE)
original_f4_tsv <- "f4.tsv.gz"
# readr::write_tsv(df_f4, original_f4_tsv, progress = FALSE)
orig_df_f4 <- readr::read_tsv(original_f4_tsv, show_col_types = FALSE, progress = FALSE) %>%
  as.data.frame()

# p_f4 <- ggplot(df_f4, aes(f4, fill = population)) +
#   geom_histogram(bins = 50) +
#   facet_grid(simulator ~ model) +
#   geom_vline(xintercept = 0, linetype = 2) +
#   labs(y = "number of individuals", x = "f4 statistic",
#        title = "f4 statistics calculated on simulated data",
#        subtitle = "Note that for f4 values ~0, the hypothesis of no gene flow can't be rejected") +
#   theme(legend.position = "bottom")
# ggsave("f4.png", p_f4, width = 8, height = 5)

test_that("f4 distributions from SLiM and msprime simulations match", {
  expect_equal(df_f4, orig_df_f4, tolerance = 1e-15)
})

df_f4ratio <- rbind(df_slim_f4ratio, df_msprime_f4ratio) %>%
  dplyr::mutate(population = ifelse(grepl("x1_", X),
                                    "x1 (received gene flow)",
                                    "x2 (no gene flow)")) %>%
  as.data.frame()

current_f4r_tsv <- paste0(tempfile(), ".tsv.gz")
readr::write_tsv(df_f4ratio, current_f4r_tsv, progress = FALSE)
original_f4r_tsv <- "f4ratio.tsv.gz"
# readr::write_tsv(df_f4ratio, original_f4r_tsv, progress = FALSE)
orig_df_f4ratio <- readr::read_tsv(original_f4r_tsv, show_col_types = FALSE, progress = FALSE) %>%
  as.data.frame()

# p_f4ratio <- ggplot(df_f4ratio, aes(alpha, fill = population)) +
#   geom_histogram(bins = 30) +
#   facet_grid(simulator ~ model) +
#   geom_vline(xintercept = 0.1, linetype = 2) +
#   labs(y = "number of individuals", x = "ancestry proportion (f4-ratio statistic)",
#        title = "f4-ratio estimate of 'b' ancestry calculated from simulated data",
#        subtitle = "Population 'x1' receives 10% gene flow (vertical dotted line)
# from 'b' in gene flow models, 'x2' never does") +
#   theme(legend.position = "bottom")
# ggsave("f4ratio.png", p_f4ratio, width = 8, height = 5)

test_that("f4-ratio distributions from SLiM and msprime simulations match", {
  expect_equal(df_f4ratio, orig_df_f4ratio, tolerance = 1e-15)
})

# Great! We got almost the same results, as expected! We can also inspect the
# variance of the statistics between different simulation back ends and see that
# they are, indeed, extremely similar between both simulators:
#
# df_f4 %>% dplyr::group_by(model, simulator) %>% dplyr::summarise(var(f4))
# df_f4ratio %>% dplyr::group_by(model, simulator) %>% dplyr::summarise(var(alpha))
