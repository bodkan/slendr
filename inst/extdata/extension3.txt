// Because we want to simulate non-neutral evolution, we have to provide a
// custom initialization callback -- slendr will use it to replace its default
// neutral genomic architecture. Note that we can refer to slendr's constants
// SEQUENCE_LENGTH and RECOMBINATION_RATE, which will carry values passed
// through from the slim() R function.
initialize() {
    initializeMutationType("m1", 0.5, "f", 0.0);

    initializeGenomicElementType("g1", m1, 1.0);
    initializeGenomicElement(g1, 0, SEQUENCE_LENGTH - 1);

    initializeMutationRate(0);
    initializeRecombinationRate(RECOMBINATION_RATE);
}

// Define model constants all in one place
initialize() {
    defineConstant("s", {{s}});
    defineConstant("onset_time", {{onset_time}});
}

function (void) add_mutation(s pop_name, f selection_coef) {
    // sample one target carrier of the new mutation...
    target = sample(population(pop_name).genomes, 1);
    // ... and add the mutation to it
    target.addNewMutation(m1, selectionCoeff = selection_coef, position = asInteger(SEQUENCE_LENGTH / 2));

    log_output("adding beneficial mutation to population " + pop_name);
}

tick(onset_time) late() {
    // save simulation state in case we need to restart if the mutation is lost
    save_state();

    add_mutation(target_pop, s);
    writeFile(output_file, "tick\ttime\tfrequency");
}

// check that the allele of interest is still segregating (and save its
// frequency to a file)
tick(onset_time):SIMULATION_END late() {
    if (!population(target_pop, check = T)) return;

    segregating = sim.countOfMutationsOfType(m1) > 0;
    fixed = sum(sim.substitutions.mutationType == m1) == 1;

    // the mutation is not segregating and is not fixed either -- we must restart
    if (!segregating & !fixed) {
        log_output("mutation lost -- restarting");

        reset_state();

        add_mutation(target_pop, s);
        writeFile(output_file, "tick\ttime\tfrequency");
    }

    if (fixed)
        frequency = 1.0;
    else
        frequency = population(target_pop).genomes.mutationFrequenciesInGenomes();
    time = model_time(community.tick);

    writeFile(output_file, community.tick + "\t" + time + "\t" + frequency, append = T);
}
