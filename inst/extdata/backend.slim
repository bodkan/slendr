initialize() {
  defineConstant("KEEP_PEDIGREES", {{keep_pedigrees}});
  defineConstant("TS_RECORDING", {{ts_recording}});

  initializeSLiMOptions(keepPedigrees = KEEP_PEDIGREES, dimensionality = "xy");
  if (TS_RECORDING) initializeTreeSeq();

  defineConstant("SIM_SEED", {{seed}});
  setSeed(SIM_SEED); catn("SEED: " + getSeed());

  defineConstant("MODEL_DIR", "{{model_dir}}");
  defineConstant("OUTPUT_PREFIX", "{{output_prefix}}");

  // load model definition tables
  defineConstant("POP_TABLE", read_table(paste0(MODEL_DIR, "/populations.tsv")));
  defineConstant("NAMES", readFile(paste0(MODEL_DIR, "/names.txt")));
  defineConstant("GENEFLOW_TABLE", read_table(paste0(MODEL_DIR, "/geneflow.tsv")));
  defineConstant("MAP_TABLE", read_table(paste0(MODEL_DIR, "/maps.tsv")));

  defineConstant("SIZE_CHANGES", read_dataframe(model_path("resizes.tsv")));

  // load all spatial maps
  defineConstant("MAPS", sapply(map_param("map_number"), "Image(paste0(MODEL_DIR, '/', applyValue, '.png'));"));

  // world map dimensions
  defineConstant("WIDTH", MAPS[0].width); catn("WIDTH: " + WIDTH);
  defineConstant("HEIGHT", MAPS[0].height); catn("HEIGHT: " + HEIGHT);

  defineConstant("GEN_TIME", {{generation_time}});
  defineConstant("T_BURNIN", {{burnin}}); catn("T_BURNIN: " + T_BURNIN);
  defineConstant("T_LENGTH", {{length}}); catn("T_LENGTH: " + T_LENGTH);

  // number of ancestry-informative neutral markers
  defineConstant("N_MARKERS", {{ancestry_markers}});
  defineConstant("TRACK_ANCESTRY", N_MARKERS > 0);

  defineConstant("SAVE_LOCATIONS", {{save_locations}});

  defineConstant("SIM_START", T_BURNIN + 1); catn("SIM_START: " + SIM_START);
  defineConstant("SIM_END", T_BURNIN + T_LENGTH + 1); catn("SIM_END: " + SIM_END);

  // calculate times for scheduling various simulation events (but only if
  // those events are specified in the configuation tables)

  // ancestral population creation times
  defineConstant("T_ANC", T_BURNIN + drop(POP_TABLE[drop(POP_TABLE[, 2]) == -1, 4]));
  catn("T_ANC: " + paste(T_ANC));

  if (!isNULL(pop_param("tsplit_gen", present = "source"))) {
    // split times
    defineConstant("T_SPLITS", T_BURNIN + drop(POP_TABLE[drop(POP_TABLE[, 2]) != -1, 4]));
    catn("T_SPLITS: " + paste(T_SPLITS));
  }

  if (!isNULL(GENEFLOW_TABLE)) {
    // geneflow start/end times
    defineConstant("T_GENEFLOW_START", T_BURNIN + admix_param("tstart_gen"));
    defineConstant("T_GENEFLOW_END", T_BURNIN + admix_param("tend_gen"));
    catn("T_GENEFLOW_START: " + paste(T_GENEFLOW_START));
    catn("T_GENEFLOW_END: " + paste(T_GENEFLOW_END));
  }

  if (length(pop_param("tremove_gen"))) {
    // times of population cleanups
    defineConstant("T_CLEANUPS", T_BURNIN + pop_param("tremove_gen"));
    catn("T_CLEANUPS: " + paste(T_CLEANUPS));
  }

  // times of spatial map changes
  ancestral_maps = map_param("time_gen")[map_param("time_gen") == 1];
  later_maps = map_param("time_gen")[map_param("time_gen") > 1];
  defineConstant("T_MAPS", c(ancestral_maps, T_BURNIN + later_maps));
  catn("T_MAPS: " + paste(T_MAPS));

  // mutation types of neutral ancestry-informative markers for each population
  mut_ids = pop_param("pop");
  for (i in mut_ids) initializeMutationType(i, 0.5, "f", 0.0);
  initializeGenomicElementType("g1", mut_ids, rep(1.0, length(mut_ids)));

  // all ancestry markers have to be prevented from stacking and from
  // disappearing once they become fixed in a population
  g1.mutationTypes[mut_ids].convertToSubstitution = F;
  g1.mutationTypes[mut_ids].mutationStackPolicy = "l";
  g1.mutationTypes[mut_ids].mutationStackGroup = 0;

  defineConstant("SEQ_LENGTH", asInteger({{seq_length}}));
  initializeGenomicElement(g1, 0, SEQ_LENGTH - 1);

  initializeRecombinationRate({{recomb_rate}});
  // TODO: this is only meaningful for purely demographic simulations - make
  // this flexible in run() after other issues are sorted out
  initializeMutationRate(0.0);

  // generate interaction types (two for each population)
  // TODO: add a more realistic kernel
  for (i in pop_param("pop")) {
    // spatial competition distance
    initializeInteractionType(2 * i, "xy", reciprocal = T, maxDistance = pop_param("competition_dist", pop_i = i));
    // mate choice distance
    initializeInteractionType(2 * i + 1, "xy", reciprocal = T, maxDistance = pop_param("mate_dist", pop_i = i));
  }
}

1 early() {
  // schedule all script blocks (unique() is called in case multiple events
  // are scheduled at once)

  // creating ancestral populations
  pop_ids = drop(POP_TABLE[drop(POP_TABLE[, 2] == -1), 0]);
  for (i in pop_ids) {
    sim.addSubpop(i, pop_param("N", i));
    set_map(i, sim.generation);
    set_coordinates(get_pop(i).individuals, i);
    add_markers(i);
  }
  evaluate_interactions();

  sim.rescheduleScriptBlock(s0, generations = SIM_START);

  if (!isNULL(SIZE_CHANGES)) {
    SIZE_CHANGES.setValue("slim_time", T_BURNIN + SIZE_CHANGES.getValue("time"));
    sim.rescheduleScriptBlock(s10, generations = SIZE_CHANGES.getValue("slim_time"));
  } else
    sim.deregisterScriptBlock(s10);

  // population splits
  if (exists("T_SPLITS"))
    sim.rescheduleScriptBlock(s1, generations = unique(T_SPLITS));
  else
    sim.deregisterScriptBlock(s1);

  // geneflow events
  if (exists("T_GENEFLOW_START")) {
    sim.rescheduleScriptBlock(s2, generations = unique(T_GENEFLOW_START));
    sim.rescheduleScriptBlock(s3, generations = unique(T_GENEFLOW_END));
  } else {
    sim.deregisterScriptBlock(s2);
    sim.deregisterScriptBlock(s3);
  }

  // removing populations which are no longer required
  if (exists("T_CLEANUPS"))
     sim.rescheduleScriptBlock(s4, generations = unique(T_CLEANUPS + 1));
  else
     sim.deregisterScriptBlock(s4);

  // spatial map changes
  if (exists("T_MAPS"))
     sim.rescheduleScriptBlock(s5, generations = unique(T_MAPS));
  else
     sim.deregisterScriptBlock(s5);

  // output locations of individuals
  if (SAVE_LOCATIONS) {
    sim.rescheduleScriptBlock(s6, start = SIM_START, end = SIM_END);
    write_locations_header();
  } else
    sim.deregisterScriptBlock(s6);

  // output tree sequence data
  if (TS_RECORDING) {
    sim.rescheduleScriptBlock(s7, generations = SIM_END);
  } else
    sim.deregisterScriptBlock(s7);

  // output ancestry proportions
  if (TRACK_ANCESTRY) {
     sim.rescheduleScriptBlock(s8, generations = SIM_START:SIM_END);
     write_ancestries_header();
  } else
     sim.deregisterScriptBlock(s8);

  // stop the simulation
  sim.rescheduleScriptBlock(s9, generations = SIM_END);
}

//////////////////////////////////////////////////////////////////////
// Demography script blocks
//////////////////////////////////////////////////////////////////////

s0 late() {
  log_output("burnin ends");
}

// Population splits
s1 late() {
  // get the populations splitting in the current generation
  pop_ids = pop_param("pop", present = "tsplit_gen")[sim.generation == T_SPLITS];
  for (i in pop_ids) {
    split_pop(i);
    set_map(i, sim.generation);
    set_coordinates(get_pop(i).individuals, i);
    add_markers(i);
    evaluate_interactions();
  }
}

// Admixture events
s2 late() {
  // iterate over all geneflow events scheduled for this generation
  // and set them accordingly
  for (i in which(sim.generation == T_GENEFLOW_START)) {
    from = admix_param("source", i);
    to = admix_param("target", i);
    rate = admix_param("rate", i);
    span = T_GENEFLOW_END[i] - T_GENEFLOW_START[i];
    set_geneflow(from, to, rate, span);
  }
}

// Stopping geneflow
s3 late() {
  // iterate over all geneflow events scheduled for this generation
  // and set them back to 0.0
  for (i in which(sim.generation == T_GENEFLOW_END)) {
    from = admix_param("source", i);
    to = admix_param("target", i);
    set_geneflow(from, to, 0.0);
  }
}

// Remove populations which are no longer necessary
s4 late() {
  // get the ID of the target population from the table
  // of geneflow events and remove them
  pop_ids = pop_param("pop", present = "tremove_gen")[sim.generation == T_CLEANUPS + 1];
  for (i in pop_ids) {
    log_output("cleanup of " + NAMES[i] + "(" + i + ")");
    get_pop(i).setSubpopulationSize(0);
  }
}

// Update population spatial maps
s5 late() {
  // get populations whose spatial maps should be updated
  pop_ids = map_param("pop")[sim.generation == T_MAPS];
  for (i in pop_ids) {
    log_output("updating map for " + NAMES[i] + "(" + i + ")");
    set_map(i, sim.generation);
  }
}

//////////////////////////////////////////////////////////////////////
// Output script blocks
//////////////////////////////////////////////////////////////////////

// Save locations and remember ancient individuals
s6 late() {
  // explicitly sample individuals for later tree sequence analysis
  // (one individual from each population)
  // TODO: make this programmable by the user on the R side
  if (sim.generation % 10 == 0) {
    inds = sapply(sim.subpopulations, "sample(applyValue.individuals, 1);");
    if (length(inds)) inds.setValue("sampled", 1);
    if (TS_RECORDING) sim.treeSeqRememberIndividuals(inds);
  }
  // save location of each individual present
  for (ind in sim.subpopulations.individuals) {
    write_locations(ind);
  }
}

// Save tree sequences at the end of the simulation
s7 late() {
  catn("--------------------------------------------------");
  log_output("saving tree-sequence data");

  if (TS_RECORDING) {
     filename = paste0(OUTPUT_PREFIX, "_tree_seq.trees");
     sim.treeSeqOutput(filename);
  }
}

s8 late() {
  write_ancestries();
}

s9 late() {
  catn("--------------------------------------------------");
  log_output("simulation finished");
  sim.simulationFinished();
}

s10 {
  events = filter_table(SIZE_CHANGES, "slim_time", sim.generation);
  for (p in events.getValue("pop")) {
    N = events.getValue("N");
    get_pop(p).setSubpopulationSize(N);
    log_output(p + " resized to " + N + " individuals");
  }
}


//////////////////////////////////////////////////////////////////////
// Callbacks and interaction evaluations
//////////////////////////////////////////////////////////////////////

1: late() {
  evaluate_interactions();
}

2: fitness(NULL) {
  interaction = sim.interactionTypes[subpop.id];
  totalStrength = interaction.totalOfNeighborStrengths(individual);
  return 1.1 - totalStrength / subpop.individualCount;
}

2: mateChoice() {
  return sim.interactionTypes[subpop.id].strength(individual);
}

modifyChild() {
  // assign locations uniformly in spatially non-overlapping geneflow
  if (child.migrant) {
    // get indices of the currently active geneflow events
    active = T_GENEFLOW_START <= sim.generation & sim.generation <= T_GENEFLOW_END;
    // get population of the offspring's parents (i.e. the source of geneflow)
    source = sourceSubpop.id == admix_param("source");
    // get the offspring's new population(i.e. the target of geneflow)
    target = subpop.id == admix_param("target");
    // get the index of the single matching geneflow event
    index = admix_param("overlap", which(active & target & source));

    if (!admix_param("overlap", index)) {
      set_coordinates(child, subpop.id, log = F);
      return T;
    }
  }

  // for spatially overlapping geneflow and non-migrant offspring,
  // propose location in the neighborhood of one of its parents
  jitter = rnorm(2, 0, pop_param("offspring_dist", pop_i = subpop.id));
  pos = parent1.spatialPosition + jitter;

  // make sure that offspring is generated in allowed locations on the map
  // (within it's population bounds and not in an inaccessible location)
  if (!subpop.pointInBounds(pos) | subpop.spatialMapValue("world", pos) == 1.0) {
    return F;
  } else {
    child.setSpatialPosition(pos);
    return T;
  }
}

//////////////////////////////////////////////////////////////////////
// Input/output utility functions
//////////////////////////////////////////////////////////////////////

function (s$) model_path(s$ file) {
  return paste0(MODEL_DIR, "/", file);
}

// Read table of population splits, migrations, etc.
function (i) read_table(s$ path) {
  if (!fileExists(path)) return(NULL);

  lines = readFile(path);
  matrix = sapply(
    lines[1 : (size(lines) - 1)], "asInteger(strsplit(applyValue, '\t'));",
    simplify="matrix"
  );
  return t(matrix);
}

// Write a header of a locations table to a locations file
function (void) write_locations_header(void) {
  filename = paste0(OUTPUT_PREFIX, "_ind_locations.tsv.gz");
  header_str = "t\tpop\tind\tx\ty\tsampled";
  writeFile(filename, header_str, compress = T);
}

// Write information about a given individual to a locations file
function(void) write_locations(lifso<Individual>$ ind) {
  filename = paste0(OUTPUT_PREFIX, "_ind_locations.tsv.gz");
  if (KEEP_PEDIGREES) id = ind.pedigreeID;
  else id = -1;
  ind_str = paste(
    SIM_END - sim.generation,
    ind.subpopulation.id,
    id,
    ind.spatialPosition,
    asInteger(!isNULL(ind.getValue("sampled"))),
    sep = "\t"
  );
  writeFile(filename, ind_str, append = T, compress = T);
}

// Write the headers of ancestry tables
function (void) write_ancestries_header(void) {
  for (pop in pop_param("pop")) {
    header_str = paste(c("gen", NAMES[pop_param("pop")]), sep = "\t");
    filename = paste0(OUTPUT_PREFIX, "_ancestry_", NAMES[pop], ".tsv");
    writeFile(filename, header_str);
  }
}

// Write information about a given individual to a locations file
function (void) write_ancestries(void) {
  for (pop in sim.subpopulations) {
    line = paste(SIM_END - sim.generation, calc_ancestry(pop), sep = "\t");
    filename = paste0(OUTPUT_PREFIX, "_ancestry_", NAMES[pop.id], ".tsv");
    writeFile(filename, line, append = T);
  }
}

// Calculate a vector of ancestry proportions in a given population
function (float) calc_ancestry(lifso<Subpopulation>$ pop) {
  // mutation IDs of all populations' ancestry markers
  mut_ids = pop_param("pop");
  return sapply(mut_ids, "mean(pop.genomes.countOfMutationsOfType(applyValue) / N_MARKERS);");
}

// Write the given output string with the time stamp
function (void) log_output(s$ str) {
  catn("Generation " + sim.generation + ": " + str);
}

//////////////////////////////////////////////////////////////////////
// Simulation utility functions
//////////////////////////////////////////////////////////////////////

function (void) evaluate_interactions(void) {
  sim.interactionTypes.evaluate();
}

// Assign a spatial map to a given population
function (void) set_map(i$ i, i$ generation) {
  img = MAPS[map_param("pop") == i & T_MAPS == generation];
  get_pop(i).defineSpatialMap("world", "xy", 1.0 - img.floatK,
    valueRange=c(min(img.floatK), max(img.floatK)), colors=c("#000000", "#FFFFFF"));
  get_pop(i).setSpatialBounds(c(0.0, 0.0, asFloat(WIDTH) - 1, asFloat(HEIGHT) - 1));
}

// Split population from the source specified in an input table
function (void) split_pop(i$ i) {
  source = pop_param("source", i);
  N = pop_param("N", i);
  log_output("split of " + NAMES[i] + "(" + i + ")" + " from " + NAMES[source] + "(" + source + ")");
  sim.addSubpopSplit(i, N, get_pop(source));
}

// Set the migration rate from a populaion 'from' to a population 'to'
// (also used for resetting the migration back to zero)
function (void) set_geneflow(i$ from, i$ to, f$ rate, [i$ span = 1]) {
  if (rate == 0)
    rate_str = " set to 0%";
  else
    rate_str = " (" + rate * 100 + "% over " + span + " generations)";
  log_output("geneflow " + NAMES[from] + "(" + from + ")" + " -> " + NAMES[to] + "(" + to + ")" + rate_str);
  source = get_pop(from);
  target = get_pop(to);
  target.setMigrationRates(source, rate / span);
}

// Add ancestry informative markers specific to the given population
function (void) add_markers(i$ pop) {
  if (TRACK_ANCESTRY) {
    log_output("adding " + NAMES[pop] + "(" + pop + ")" + " ancestry markers");
    get_pop(pop).genomes.addNewMutation(pop, 0.0, seq(0, {{seq_length}} - 1, by = asInteger({{seq_length}} / N_MARKERS)));
  }
}

// Distribute individuals uniformly within the boundary of the given population
function (void) set_coordinates(lifso<Individual> inds, i$ pop, [l$ log = T]) {
  if (log) log_output("distributing individuals");
  for (ind in inds) {
    do pos = c(runif(1, 0, WIDTH), runif(1, 0, HEIGHT));
    while (get_pop(pop).spatialMapValue("world", pos) == 1.0);
    ind.setSpatialPosition(pos);
  }
}

// Get subpopulation object based on a given identifier
// (SLiM-based numerber or a user-defined string name)
function (lifso<Subpopulation>$) get_pop(si$ i) {
  if (isString(i)) i = which(NAMES == i);
  if (!any(i == sim.subpopulations.id))
    stop("Population " + NAMES[i] + " not present in the simulation in generation " + sim.generation);
  return sim.subpopulations[i == sim.subpopulations.id];
}

//////////////////////////////////////////////////////////////////////
// Acessing parameter tables
// This is basically an implementation of a very basic dataframe
//////////////////////////////////////////////////////////////////////

// Get a value of a column from a populations table belonging
// to the i-th population
function (numeric) pop_param(s$ col, [Ni$ pop_i = NULL], [Ns$ present = NULL]) {
  if (!isNULL(pop_i) & !isNULL(present))
    stop("Both population ID and filtering criterion cannot be specified.");

  // column names allowed
  columns = c("pop", "N", "source", "tsplit", "tsplit_gen", "tremove",
              "tremove_gen", "competition_dist", "mate_dist",
              "offspring_dist", "orig_tsplit", "orig_tremove");

  // lookup column name number for indexing into a populations matrix
  col_i = which(columns == col) ;
  if (length(col_i) != 1)
    stop("Incorrect specification of a column in a populations table");

  // in some cases we want all values, even the NA ones
  if (!isNULL(present)) {
    // lookup column name number for indexing into a populations matrix
    present_i = which(columns == present);
    if (length(present_i) != 1)
      stop("Incorrect specification of a column in the splits table");
    table = POP_TABLE[drop(POP_TABLE[, present_i]) != -1, ];
    // ugly hack to get around the new way that splits are defined for
    // all populations, including the ancestral ones (i.e. explicit "sim_length"
    // parameter has now been removed)
    if (present == "tsplit_gen") table = table[drop(table[, 2]) != -1, ];
  } else {
    table = POP_TABLE;
  }
	if (length(table) == 0) return NULL;
  if (isNULL(pop_i)) pop_i = seqLen(nrow(table));
  val = drop(table[pop_i, col_i]);

  return val[which(val != -1)];
}

// Get a value of a column from the table of geneflow events
function (numeric) admix_param(s$ col, [Ni admix_i = NULL]) {
  if (isNULL(GENEFLOW_TABLE)) return(NULL);
  // column names allowed
  columns = c("source", "target", "tstart", "tstart_gen",
              "tend", "tend_gen", "rate", "overlap",
              "orig_tstart", "orig_tend");

  // lookup column name number for indexing into a populations matrix
  col_i = which(columns == col) ;
  if (length(col_i) != 1)
    stop("Incorrect specification of a column in the table of geneflow events");

  if (!isNULL(admix_i)) indices = which(seqAlong(nrow(GENEFLOW_TABLE)) == admix_i);

  // extract the value
  val = drop(GENEFLOW_TABLE[admix_i, col_i]);

  // rate needs to be convered to float
  if (col == "rate") val = val / 100;

  return val;
}

// Get a value of a column from the table of geneflow events
function (numeric) map_param(s$ col, [Ni$ pop_i = NULL], [Ni$ time = NULL]) {
  // column names allowed
  columns = c("pop", "time", "time_gen", "map_number", "orig_time");

  // lookup column name number for indexing into a populations matrix
  col_i = which(columns == col) ;
  if (length(col_i) != 1)
    stop("Incorrect specification of a column in the spatial maps table");

  indices = rep(T, nrow(MAP_TABLE));
  if (!isNULL(pop_i)) {
    indices = indices & (drop(MAP_TABLE[, 0]) == pop_i);
  }
  if (!isNULL(time)) {
    indices = indices & (T_MAPS == time);
  }
  val = drop(MAP_TABLE[indices, col_i]);

  return val[which(val != -1)];
}


// Data frame implementation based on Dictionary
// Read a TSV file as a Dictionary of pairs of the form:
//   <column name>-<vector of column values>
function (object<Dictionary>) read_dataframe(s$ path) {
	lines = readFile(path);

	// extract column names
	columns = strsplit(lines[0], "\t");
	// parse the body of the table into individual elements
	body = lines[1 : (length(lines) - 1)];
	body_elements = sapply(body, "strsplit(applyValue, '\t');");

	// generate a dictionary of key-vector (pairs column-column values)
	dict = Dictionary();
	for (i in seqAlong(columns)) {
		// extract values of the i-th column
		indices = seq(i, length(body_elements) - 1, by = length(columns));
		column_values = convert_type(columns[i], body_elements[indices]);

		dict.setValue(columns[i], column_values);
	}

	return dict;
}


// Filter Dictionary/data-frame for rows where the <column> is
// equal to <value>
function (object<Dictionary>) filter_table(
	object<Dictionary> d,
	s$ column,
	ifsl$ value
) {
	values = d.getValue(column);
	return d.getRowValues(values == value);
}


// Convert column vector values to a required type (this is hardcoded
// for every column among all slendr-generated TSV files)
function (ifsl) convert_type(s$ column_name, s string_values) {
	integer = c("pop_id", "N", "time", "orig_time");
	float = c("rate");
	logical = c("overlap");

	if (any(column_name == integer))
		values = asInteger(string_values);
	else if (any(column_name == float))
		values = asFloat(string_values);
	else if (any(column_name == logical))
		values = asLogical(string_values);
	else
		values = string_values;

	return values;
}

//size_changes = read_table("/tmp/example-model/resizes.tsv")

//size_changes

//size_changes.getRowValues(1)

//size_changes.getValue("pop")

//filter_table(size_changes, "pop", "YAM").getValue("time")
