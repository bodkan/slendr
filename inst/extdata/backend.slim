initialize() {
	initializeSLiMOptions(keepPedigrees = T, dimensionality = "xy");
	initializeTreeSeq();

	// interaction/competition distance
	defineConstant("INTERACTION", asFloat({{interaction}}));
	// offspring spread
	defineConstant("SPREAD", asFloat({{spread}}));

	// spatial competition
	initializeInteractionType(1, "xy", reciprocal = T, maxDistance = INTERACTION);
	i1.setInteractionFunction("n", 5.0, 10.0);

	// spatial mate choice
	initializeInteractionType(2, "xy", reciprocal = T, maxDistance = INTERACTION);
	i2.setInteractionFunction("n", 1.0, 10.0);

	defineConstant("MODEL_DIR", "{{model_dir}}");
	// load model definition tables
	defineConstant("SPLIT_TABLE", read_table(paste0(MODEL_DIR, "/splits.tsv")));
	defineConstant("NAMES", readFile(paste0(MODEL_DIR, "/names.txt")));
	defineConstant("ADMIX_TABLE", read_table(paste0(MODEL_DIR, "/admixtures.tsv")));
	defineConstant("MAP_TABLE", read_table(paste0(MODEL_DIR, "/maps.tsv")));
	// load all spatial maps
	defineConstant("MAPS", sapply(maps_param("map"), "Image(paste0(MODEL_DIR, '/', applyValue, '.png'));"));

	// world dimensions in pixels
	defineConstant("WIDTH", MAPS[0].width);
	defineConstant("HEIGHT", MAPS[0].height);

	// define output files
	defineConstant("OUTPUT_PREFIX", "{{output_prefix}}");

	defineConstant("GEN_TIME", {{gen_time}});
	defineConstant("T_BURNIN", asInteger({{burnin}}));
	defineConstant("T_LENGTH", asInteger({{sim_length}} / GEN_TIME));

	defineConstant("TRACE_ANCESTRY", T);

	catn("T_BURNIN: " + T_BURNIN);
	catn("T_LENGTH: " + T_LENGTH);

	if (nrow(SPLIT_TABLE) > 1) {
		// absolute split times
		defineConstant("T_ABS_SPLITS", asInteger(pop_param("tsplit") / GEN_TIME));
		// split times relative to the start of the simulation
		defineConstant("T_SPLITS", T_BURNIN + (T_LENGTH - T_ABS_SPLITS));

		catn("T_SPLITS: " + paste(T_SPLITS));
	}

	if (!isNULL(ADMIX_TABLE)) {
		// absolute admixture times
		defineConstant("T_ABS_ADMIX_START", asInteger(admix_param("tstart") / GEN_TIME));
		defineConstant("T_ABS_ADMIX_END", asInteger(admix_param("tend") / GEN_TIME));
		// admixture times relative to the start of the simulation
		// (add one generation to force admixture only after each split)
		defineConstant("T_ADMIX_START", T_BURNIN + (T_LENGTH - T_ABS_ADMIX_START) + 1);
		defineConstant("T_ADMIX_END", T_BURNIN + (T_LENGTH - T_ABS_ADMIX_END) + 1);

		catn("T_ADMIX_START: " + paste(T_ADMIX_START));
		catn("T_ADMIX_END: " + paste(T_ADMIX_END));
	}

	if (length(pop_param("tremove"))) {
		// absolute times of population cleanup
		defineConstant("T_ABS_CLEANUPS", asInteger(pop_param("tremove") / GEN_TIME));
		// cleanup times relative to the start of the simulation
		// (add one generation to force cleanup only after each split)
		defineConstant("T_CLEANUPS", T_BURNIN + (T_LENGTH - T_ABS_CLEANUPS) + 1);

		catn("T_CLEANUPS: " + paste(T_CLEANUPS));
	}

	if (length(MAPS) > 1) {
		// absolute times of spatial map changes
		defineConstant("T_ABS_MAPS", asInteger(maps_param("time") / GEN_TIME));
		// times relative to the start of the simulation
		defineConstant("T_MAPS", c(1, T_BURNIN + (T_LENGTH - T_ABS_MAPS)));
		catn("T_MAPS: " + paste(T_MAPS));
	}

	// neutral markers specific for each population
	// TODO: for performance reasons, only add markers for populations
	// that contribute their ancestry to others
	mut_ids = pop_param("pop");
	for (i in mut_ids) initializeMutationType(i, 0.5, "f", 0.0);
	initializeGenomicElementType("g1", mut_ids, rep(1.0, length(mut_ids)));

	// all ancestry markers have to be prevented from stacking and from
	// disappearing once they become fixed in a population
	g1.mutationTypes[mut_ids].convertToSubstitution = F;
	g1.mutationTypes[mut_ids].mutationStackPolicy = "l";
	g1.mutationTypes[mut_ids].mutationStackGroup = 0;

	initializeGenomicElement(g1, 0, asInteger({{seq_length}}) - 1);

	initializeRecombinationRate({{recomb_rate}});
	initializeMutationRate(0.0);
}

1 early() {
	i = 0;
	sim.addSubpop(i, pop_param("Ne", i));
	set_map(i, sim.generation);
	set_coords(get_pop(i).individuals);
	add_markers(i);

	// unique() is called in case multiple events are scheduled at once
	// (this is not allowed in SLiM - each callback needs to detect this
	// and execute everything in a for loop)

	if (exists("T_SPLITS"))
		sim.rescheduleScriptBlock(s1, generations = unique(T_SPLITS));
	else
		sim.deregisterScriptBlock(s1);

	if (exists("T_ADMIX_START")) {
		sim.rescheduleScriptBlock(s2, generations = unique(T_ADMIX_START));
		sim.rescheduleScriptBlock(s3, generations = unique(T_ADMIX_END));
		//		sim.rescheduleScriptBlock(s4, generations = unique(T_ADMIX + 1));
	} else {
		sim.deregisterScriptBlock(s2);
		sim.deregisterScriptBlock(s3);
	}
	sim.deregisterScriptBlock(s4);

	// population cleanups
	if (exists("T_CLEANUPS"))
		sim.rescheduleScriptBlock(s5, generations = unique(T_CLEANUPS + 1));
	else
		sim.deregisterScriptBlock(s5);

	// spatial map changes
	if (exists("T_MAPS"))
		sim.rescheduleScriptBlock(s6, generations = unique(T_MAPS));
	else
		sim.deregisterScriptBlock(s6);

	// output callbacks
	sim.rescheduleScriptBlock(s99, start = T_BURNIN, end = T_BURNIN + T_LENGTH);
	sim.rescheduleScriptBlock(s999, generations = T_BURNIN + T_LENGTH);
	if (TRACE_ANCESTRY)
		sim.rescheduleScriptBlock(s9999, generations = (T_BURNIN + 1):(T_BURNIN + T_LENGTH));
	else
		sim.deregisterScriptBlock(s9999);

	write_locations_header();
	write_ancestries_header();
}

//////////////////////////////////////////////////////////////////////
// Demography script blocks
//////////////////////////////////////////////////////////////////////

// Population splits
s1 late() {
	// get the ID of populations splitting in the current generation
	// from the table of splits
	pop_ids = pop_param("pop", present = "tsplit")[sim.generation == T_SPLITS];
	for (i in pop_ids) {
		split_pop(i);
		set_map(i, sim.generation);
		set_coords(get_pop(i).individuals);
		add_markers(i);
	}
}

// Admixture events
s2 late() {
	// iterate over all admixture events scheduled for this generation
	// and set them accordingly
	for (i in which(sim.generation == T_ADMIX_START)) {
		from = admix_param("source", i);
		to = admix_param("target", i);
		rate = admix_param("rate", i);
		span = T_ADMIX_END[i] - T_ADMIX_START[i];
		set_admixture(from, to, rate, span);
	}
}

// Stopping admixture
s3 late() {
	// iterate over all admixture events scheduled for this generation
	// and set them back to 0.0
	for (i in which(sim.generation == T_ADMIX_END)) {
		from = admix_param("source", i);
		to = admix_param("target", i);
		set_admixture(from, to, 0.0);
	}
}

// Set the location of migrants to that of the receiving population
// (this is only used for "instantaneous" admixture without spatial overlap)
s4 late() {
	// get the new migrants in all populations that recently arrived
	// and re-set their coordinates
	for (i in which(sim.generation - 1 == T_ADMIX)) {
		pop = admix_param("target", i);
		status = get_pop(pop).individuals.migrant;
		migrants = get_pop(pop).individuals[status];
		set_coords(migrants);
	}
}

// Remove populations which are no longer necessary
s5 late() {
	// get the ID of the target population from the table
	// of admixture events and remove them
	pop_ids = pop_param("pop", present = "tremove")[sim.generation - 1 == T_CLEANUPS];
	for (i in pop_ids) {
		catn("Generation " + sim.generation + ": cleanup of " + NAMES[i]);
		get_pop(i).setSubpopulationSize(0);
	}
}

// Update population spatial maps
s6 late() {
	// get populations whose spatial maps should be updated
	pop_ids = maps_param("pop")[sim.generation == T_MAPS];
	for (i in pop_ids) {
		catn("Generation " + sim.generation + ": updating map for " + NAMES[i]);
		set_map(i, sim.generation);
	}
}

//////////////////////////////////////////////////////////////////////
// Output script blocks
//////////////////////////////////////////////////////////////////////

// Saving locations and remembering ancient individuals
s99 late() {
	// explicitly sample individuals for later tree sequence analysis
	// (one individual from each population)
	if (sim.generation % 10 == 0) {
		inds = sapply(sim.subpopulations, "sample(applyValue.individuals, 1);");
		inds.setValue("sampled", 1);
		sim.treeSeqRememberIndividuals(inds);
	}
	// save location of each individual present
	for (ind in sim.subpopulations.individuals) {
		write_locations(ind);
	}
}

// Saving tree sequences at the end of the simulation
s999 late() {
  catn("--------------------------------------------------------");
	catn("Generation " + sim.generation + ": simulation finished");
	filename = paste0(OUTPUT_PREFIX, "treeseq.trees");
	sim.treeSeqOutput(filename);
	sim.simulationFinished();
}

s9999 late() {
	write_ancestries();
}

//////////////////////////////////////////////////////////////////////
// Callbacks
//////////////////////////////////////////////////////////////////////

modifyChild() {
	pos = parent1.spatialPosition + rnorm(2, 0, SPREAD);
	if (!subpop.pointInBounds(pos) | subpop.spatialMapValue("world", pos) == 1.0)
		return F;

	child.setSpatialPosition(pos);
	return T;
}

//////////////////////////////////////////////////////////////////////
// Input/output utility functions
//////////////////////////////////////////////////////////////////////

// Read table of population splits, migrations, etc.
function (i) read_table(s$ path) {
	lines = readFile(path);
	if (length(lines) <= 1) return(NULL);

	matrix = sapply(
		lines[1 : (size(lines) - 1)], "asInteger(strsplit(applyValue, '\t'));",
		simplify="matrix"
		);
	return t(matrix);
}

// Write a header of a locations table to a locations file
function (void) write_locations_header(void) {
	filename = paste0(OUTPUT_PREFIX, "locations.tsv.gz");
	header_str = "t\tpop\tind\tx\ty\tsampled";
	writeFile(filename, header_str, compress = T);
}

// Write information about a given individual to a locations file
function(void) write_locations(lifso<Individual>$ ind) {
	filename = paste0(OUTPUT_PREFIX, "locations.tsv.gz");
	ind_str = paste(
		T_BURNIN + T_LENGTH - sim.generation,
		ind.subpopulation.id,
		ind.pedigreeID,
		ind.spatialPosition,
		asInteger(!isNULL(ind.getValue("sampled"))),
		sep = "\t"
		);
	writeFile(filename, ind_str, append = T, compress = T);
}

// Write the headers of ancestry tables
function (void) write_ancestries_header(void) {
	for (pop in pop_param("pop")) {
		header_str = paste(c("gen", NAMES[pop_param("pop")]), sep = "\t");
		filename = paste0(OUTPUT_PREFIX, "ancestry_", NAMES[pop], ".tsv");
		writeFile(filename, header_str);
	}
}

// Write information about a given individual to a locations file
function (void) write_ancestries(void) {
	for (pop in sim.subpopulations) {
		line = paste(
			T_BURNIN + T_LENGTH - sim.generation,
			calc_ancestry(pop),
			sep = "\t"
		);
		filename = paste0(OUTPUT_PREFIX, "ancestry_", NAMES[pop.id], ".tsv");
		writeFile(filename, line, append = T);
	}
}

// Calculate a vector of ancestry proportions in a given population
function (float) calc_ancestry(lifso<Subpopulation>$ pop) {
	// mutation IDs of all populations' ancestry markers
	mut_ids = pop_param("pop");
	return sapply(mut_ids, "mean(pop.genomes.countOfMutationsOfType(applyValue) / 10);");
}

//////////////////////////////////////////////////////////////////////
// Simulation utility functions
//////////////////////////////////////////////////////////////////////

// Assign a spatial map to a given population
function (void) set_map(i$ i, i$ generation) {
	if (sim.generation == 1)
		img = MAPS[0];
	else
		img = MAPS[maps_param("pop") == i & T_MAPS == generation];
	get_pop(i).defineSpatialMap("world", "xy", 1.0 - img.floatK,
		valueRange=c(min(img.floatK), max(img.floatK)), colors=c("#000000", "#FFFFFF"));
	get_pop(i).setSpatialBounds(c(0.0, 0.0, asFloat(WIDTH) - 1, asFloat(HEIGHT) - 1));
}

// Split population from the source specified in an input table
function (void) split_pop(i$ i) {
	source = pop_param("source", i);
	Ne= pop_param("Ne", i);
	catn("Generation " + sim.generation + ": split of " + NAMES[i] + " from " + NAMES[source]);
	sim.addSubpopSplit(i, Ne, get_pop(source));
}

// Set the migration rate from a populaion 'from' to a population 'to'
// (also used for resetting the migration back to zero)
function (void) set_admixture(i$ from, i$ to, f$ rate, [i$ span = 1]) {
	if (rate == 0)
		rate_str = " is set to zero";
	else
		rate_str = " (" + rate * 100 + "% over " + span + " generations)";
	catn("Generation " + sim.generation + ": admixture " + NAMES[from] + " -> " + NAMES[to] + rate_str);
	source = get_pop(from);
	target = get_pop(to);
	target.setMigrationRates(source, rate / span);
}

// Add ancestry informative markers specific to the given population
function (void) add_markers(i$ pop) {
	catn("Generation " + sim.generation + ": adding " + NAMES[pop] + " ancestry markers");
	get_pop(pop).genomes.addNewMutation(pop, 0.0, seq(0, {{seq_length}} - 1, by = 10));
}

// Distribute the set of individuals around specified coordinates
function (void) set_coords(lifso<Individual> inds) {
	catn("Generation " + sim.generation + ": distributing individuals");
	for (ind in inds) {
	    pop = ind.subpopulation;
	    do pos = c(runif(1, 0, WIDTH), runif(1, 0, HEIGHT));
	    while (!pop.pointInBounds(pos) | pop.spatialMapValue("world", pos) == 1.0);
	    ind.x = pos[0];
	    ind.y = pos[1];
	}
}

// Get subpopulation based on a given ID
function (lifso<Subpopulation>$) get_pop(i$ i) {
	return sim.subpopulations[i == sim.subpopulations.id];
}

//////////////////////////////////////////////////////////////////////
// Acessing parameter 'tables'
//////////////////////////////////////////////////////////////////////

// Get a value of a column from a populations table belonging
// to the i-th population
function (numeric) pop_param(s$ col, [Ni$ pop_i = NULL], [Ns$ present = NULL]) {
	if (!isNULL(pop_i) & !isNULL(present))
		stop("Both population ID and filtering criterion cannot be specified.");

	// column names allowed
	columns = c("pop", "Ne", "x", "y", "source", "tsplit", "tremove");

	// lookup column name number for indexing into a populations matrix
	col_i = which(columns == col) ;
	if (length(col_i) != 1)
		stop("Incorrect specification of a column in a populations table");

	// in some cases we want all values, even the NA ones
	if (!isNULL(present)) {
		// lookup column name number for indexing into a populations matrix
		present_i = which(columns == present);
		if (length(present_i) != 1)
			stop("Incorrect specification of a column in the splits table");
		table = SPLIT_TABLE[drop(SPLIT_TABLE[, present_i]) != -1, ];
	} else {
		table = SPLIT_TABLE;
	}

	if (isNULL(pop_i)) pop_i = seqLen(nrow(table));
	val = drop(table[pop_i, col_i]);

	return val[which(val != -1)];
}

// Get a value of a column from the table of admixture events
function (numeric) admix_param(s$ col, [Ni$ admix_i = NULL]) {
	if (isNULL(ADMIX_TABLE)) return(NULL);
	// column names allowed
	columns = c("source", "target", "tstart", "tend", "rate");

	// lookup column name number for indexing into a populations matrix
	col_i = which(columns == col) ;
	if (length(col_i) != 1)
		stop("Incorrect specification of a column in the table of admixture events");

	if (isNULL(admix_i)) pop_i = seqLen(nrow(ADMIX_TABLE));

	// extract the value and convert it if necessary
	val = drop(ADMIX_TABLE[admix_i, col_i]);
	if (col == "rate") val = val / 100;

	return val;
}

// Get a value of a column from the table of admixture events
function (numeric) maps_param(s$ col, [Ni$ pop_i = NULL], [Ni$ time = NULL]) {
	// column names allowed
	columns = c("pop", "time", "map");

	// lookup column name number for indexing into a populations matrix
	col_i = which(columns == col) ;
	if (length(col_i) != 1)
		stop("Incorrect specification of a column in the spatial maps table");

	indices = rep(T, nrow(MAP_TABLE));
	if (!isNULL(pop_i)) {
		indices = indices & (drop(MAP_TABLE[, 0]) == pop_i);
	}
	if (!isNULL(time)) {
		indices = indices & (T_MAPS == time);
	}
	val = drop(MAP_TABLE[indices, col_i]);

	return val[which(val != -1)];
}
