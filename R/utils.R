# Get path to an appropriate SLiM binary
get_binary <- function(method) {
  if (method == "gui") {
    if (Sys.info()["sysname"] == "Darwin")
      return("open -a SLiMgui")
    else
      binary <- "SLiMgui"
  } else
    binary <- "slim"

  binary_path <- Sys.which(binary)
  if (all(binary_path == ""))
    stop(sprintf("%s binary not found. Please modify your $PATH accordingly or
specify the path manually by setting the 'binary_path' argument.", binary),
call. = FALSE)
  else
    return(as.character(binary_path))
}


# Check whether given population region has not yet been intersected
check_not_intersected <- function(pop) {
  if (!is.null(attr(pop, "intersected")))
    stop("An already intersected population range object was provided.
Please provide a range object before it was intersected against a map.",
         call. = FALSE)
}


# Check whether the given value makes sense given the map dimensions
check_resolution <- function(map, val) {
  xrange <- sf::st_bbox(map)[c("xmin", "xmax")]
  yrange <- sf::st_bbox(map)[c("ymin", "ymax")]
  if (diff(xrange) < val | diff(yrange) < val)
    stop(sprintf("Value of %s = %s larger than the overall world size",
                 deparse(substitute(val)), val),
         call. = FALSE)
}


# Set a bounding box of a given object, and return that object again
# (for some reason there's no builtin way to set a bounding box in
# sf <https://twitter.com/TimSalabim3/status/1063099774977667072>)
set_bbox <- function(x, xmin, xmax, ymin, ymax) {
  bbox <- c(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax)
  attr(bbox, "class") <- "bbox"
  attr(sf::st_geometry(x), "bbox") <- bbox
  x
}


# Does the object have a Coordinate Reference System assigned to it?
has_crs <- function(x) {
  !is.na(sf::st_crs(x)$epsg)
}


# Set slendr classes (or fix their priorities if already present)
set_class <- function(x, type) {
  other_classes <- class(x) %>% .[!grepl("^slendr", .)]
  c("slendr", paste0("slendr_", type), other_classes)
}


# Read ancestry proportion tables generated by the backend SLiM script
read_ancestries <- function(model_dir) {
  files <- list.files(model_dir, pattern = ".*ancestry_.*.tsv$", full.names = TRUE)
  if (!length(files))
    stop("No ancestry proportion tables found. Did you specify the correct path?",
         call. = FALSE)

  lapply(files, function(f) {
    anc_df <- data.table::fread(f)
    if (nrow(anc_df) > 0)
      anc_df$pop <- gsub(".*_ancestry_(.*).tsv", "\\1", f)
    anc_df
  }) %>% do.call(rbind, .)
}


# Get a data frame of geneflow events active at a given time point
get_geneflows <- function(model, time) {
  if (is.null(model$geneflow)) return(NULL)
  pop_names <- unique(unlist(sapply(model$populations, `[[`, "pop")))

  geneflows <- subset(model$geneflow, tstart_orig >= time & tend_orig <= time)
  geneflows$from <- factor(geneflows$from, levels = pop_names)
  geneflows$to <- factor(geneflows$to, levels = pop_names)

  migr_coords <- lapply(seq_len(nrow(geneflows)), function(row_i) {

    from <- model$populations[pop_names == geneflows[row_i, ]$from][[1]] %>%
      .[.$tmap >= time, ] %>%
      .[nrow(.), ]

    to <- model$populations[pop_names == geneflows[row_i, ]$to][[1]] %>%
      .[.$tmap >= time, ] %>%
      .[nrow(.), ]

    from_center <- sf::st_centroid(from) %>% sf::st_coordinates()
    to_center <- sf::st_centroid(to) %>% sf::st_coordinates()

    coords <- as.data.frame(cbind(from_center, to_center), stringsAsFactors = FALSE)
    colnames(coords) <- c("from_x", "from_y", "to_x", "to_y")
    coords

  }) %>%
  do.call(rbind, .)

  cbind(geneflows, migr_coords)
}


# Transfer given set of attributes from one object to another
copy_attributes <- function(to, from, which) {
  for (i in which)
    attr(to, i) <- attr(from, i)
  class(to) <- class(from)
  to
}


# Get split times of populations in the lineage of the given population
get_lineage_splits <- function(x) {
  parent <- attr(x, "parent")
  time <- attr(x, "history")[[1]]$time
  if (is.character(parent))
    return(time)
  else
    return(c(time, get_lineage_splits(parent)))
}


# Get direction of time implied by the model
get_time_direction <- function(pop) {
  split_times <- get_lineage_splits(pop)

  if (length(split_times) == 1) {
    event_times <- attr(pop, "history") %>%
      sapply(function(event) c(event$time, event$tresize, event$tend, event$start, event$end)) %>%
      unlist %>%
      unique %>%
      na.omit
    if (length(event_times) == 1) {
      removal_time <- attr(pop, "remove")
      if (removal_time != -1 & event_times > removal_time)
        "backward"
      else if (removal_time != -1 & event_times < removal_time)
        "forward"
      else
        "unknown"
    } else if (all(diff(event_times) < 0))
      "backward"
    else
      "forward"
  } else if (all(diff(split_times) > 0))
    "backward"
  else
    "forward"
}


# Check the consistency of the given split time to the parent population
check_split_time <- function(time, parent) {
  parent_time <- attr(parent, "history")[[1]]$time
  direction <- get_time_direction(parent)
  if (direction == "forward" & time <= parent_time) {
    stop(sprintf("The model implies forward time direction but the specified split
time (%d) is lower than the parent's (%s)",
                 time, parent_time),
         call. = FALSE)
  } else if (direction == "backward" & time >= parent_time) {
    stop(sprintf("The model implies backward time direction but the specified split
time (%s) is higher than the parent's (%s)",
                 time, parent_time),
         call. = FALSE)
  } else if (time == parent_time) {
    stop("Population can be only created after its parent is already present in the simulation", call. = FALSE)
  }
}


# Get time of the very last event currently specified
get_previous_time <- function(pop) {
  sapply(attr(pop, "history"), function(event) {
    c(event$time, event$tresize, event$tstart, event$tend)
  }) %>%
    unlist %>%
    Filter(Negate(is.null), .) %>%
    Filter(Negate(is.na), .) %>%
    tail(1)
}


check_event_time <- function(time, pop) {
  if (length(time) > 1 & time[1] == time[2])
    stop("Start time of the event is equal to the end time of the event", call. = FALSE)

  direction <- get_time_direction(pop)

  previous_time <- get_previous_time(pop)

  # testing for consistent for ancestral populations (unknown time direction)
  if (direction == "unknown") {
    # there is no information about time direction from ancestral populations,
    # but we can test that all times of the current event are before/after that
    # population's split time
    if (!(all(time >= previous_time) | all(time <= previous_time)))
      stop(sprintf("The new event (time %s) falls both before and after the last active time (%s) for the population",
                   paste(time, collapse = "-"), previous_time), call. = FALSE)

    # if a start-end time window was specified for the event, we can lock in
    # a time direction even for ancestral populations for which the flow of
    # time is otherwise unknown
    if (length(time) > 1) {
      # the first time point implies time going backwards, but the event window
      # implies a forward direction
      if (time[1] < previous_time & time[2] > time[1])
        stop(sprintf("The new event (time %s) implies a forward time direction but the population split time (%d) is higher (indicating backward time direction)",
             paste(time, collapse = "-"), previous_time), call. = FALSE)
      else if (time[1] > previous_time & time[2] < time[1])
        stop(sprintf("The new event (time %s) implies a backward time direction but the population split time (%d) is lower (indicating forward time direction)",
                     paste(time, collapse = "-"), previous_time), call. = FALSE)
    }
  } else if (direction %in% c("backward", "forward")) {
    # direction of an event follows the already established time direction
    if ((direction == "backward" & length(time) > 1 & time[1] < time[2]) |
        (direction == "forward" & length(time) > 1 & time[1] > time[2])) {
      event_direction <- if (time[1] < time[2]) "forward" else "backward"
      stop(sprintf("The new %s event (time %s) is inconsistent with the %s time direction assumed by the model",
                   event_direction, paste0(time, collapse = "-"), direction), call. = FALSE)
    }

    # time of event is consistent with the already established time direction
    if ((direction == "backward" & !all(previous_time >= time)) |
        (direction == "forward" & !all(previous_time <= time))) {
      stop(sprintf("The new event (time %s) pre-dates the last specified active event (%s) which is incompatible with the assumed %s time direction of the model",
                   paste(time, collapse = "-"), previous_time, direction),
           call. = FALSE)
    }
  } else
    stop(sprintf("Unknown time direction %s", direction), call. = FALSE)
}


check_present_time <- function(time, pop) {
  direction <- get_time_direction(pop)
  split_time <- get_lineage_splits(pop)[1]

  if (direction == "backward" & time > split_time)
    stop("Population ", pop$pop[1], " is not present at a time ", time, call. = FALSE)
  else if (direction == "forward" & time < split_time)
    stop("Population ", pop$pop[1], " is not present at a time ", time, call. = FALSE)
}


check_removal_time <- function(time, pop) {
  direction <- get_time_direction(pop)
  removal_time <- attr(pop, "remove")

  if (removal_time != -1 & direction == "forward" & any(time > removal_time)) {
    stop(sprintf("The specified event time (%d) is not consistent with the scheduled removal of %s (%s) given the assumed %s time direction",
                 time, pop$pop[1], removal_time, direction),
         call. = FALSE)
  }
  if (removal_time != -1 & direction == "backward" & any(time < removal_time)) {
    stop(sprintf("The specified event time (%d) is not consistent with the scheduled removal of %s (%s) given the assumed %s time direction",
                 time, pop$pop[1], removal_time, direction),
         call. = FALSE)
  }
}


# Calculate overlap between subsequent spatial maps
compute_overlaps <- function(x) {
  sf::st_agr(x) <- "constant"
  sapply(
    (1:nrow(x))[-1], function(i) {
      a <- x[i - 1, ]
      b <- x[i, ]
      intersection <- sf::st_intersection(a, b)
      if (nrow(intersection) == 0) return(0)
      sf::st_area(intersection) / sf::st_area(b)
    }
  )
}


# Take care of missing interactions and offspring distances
set_distances <- function(dispersal_table, resolution,
                          competition_dist, mate_dist, dispersal_dist) {
  if (any(is.na(dispersal_table$competition_dist))) {
    if (is.null(competition_dist)) {
      pop_names <- paste(dispersal_table[is.na(dispersal_table$competition_dist), ]$pop, collapse = ", ")
      stop("Parameter 'competition_dist' missing for ", pop_names, " and a general
  value of this parameter was not provided to the compile() function", call. = FALSE)
    } else
      dispersal_table$competition_dist[is.na(dispersal_table$competition_dist)] <- competition_dist
  }

  if (any(is.na(dispersal_table$mate_dist))) {
    if (is.null(mate_dist)) {
      pop_names <- paste(dispersal_table[is.na(dispersal_table$mate_dist), ]$pop, collapse = ", ")
      stop("Parameter 'mate_dist' missing for ", pop_names, " and a general
  value of this parameter was not provided to the compile() function", call. = FALSE)
    } else
      dispersal_table$mate_dist[is.na(dispersal_table$mate_dist)] <- mate_dist
  }

  if (any(is.na(dispersal_table$dispersal_dist))) {
    if (is.null(dispersal_dist)) {
      pop_names <- paste(dispersal_table[is.na(dispersal_table$dispersal_dist), ]$pop, collapse = ", ")
      stop("Parameter 'dispersal_dist' missing for ", pop_names, " and a general
  value of this parameter was not provided to the compile() function", call. = FALSE)
    } else
      dispersal_table$dispersal_dist[is.na(dispersal_table$dispersal_dist)] <- dispersal_dist
  }

  dispersal_table[, c("competition_dist", "mate_dist", "dispersal_dist")] <-
    dispersal_table[, c("competition_dist", "mate_dist", "dispersal_dist")] / resolution

  dispersal_table
}

# Return the map attribute of a slendr object
get_map <- function(x) {
  if (!inherits(x, "slendr"))
    stop("Can't access a map attribute of a non-slendr type object", call. = FALSE)

  map <- attr(x, "map")
  if (inherits(map, "slendr_map"))
    map
  else
    NULL
}

# Does a given object have an attribute map?
has_map <- function(x) {
  inherits(get_map(x), "slendr_map")
}


# Process the sampling schedue
process_sampling <- function(samples, model, script_path) {
  if (is.null(samples))
    return("NULL")

  df <- dplyr::group_by(samples, time, pop) %>%
    dplyr::summarise(n = sum(n), .groups = "drop") %>%
    dplyr::arrange(time) %>%
    convert_time(direction = model$direction,
                 columns = "time",
                 generation_time = model$generation_time,
                 max_time = model$length) %>%
    dplyr::arrange(time_gen)

  script_dir <- dirname(script_path)

  sampling_file <- stringr::str_replace(basename(script_path), ".slim", "_samples.tsv")
  sampling_path <- file.path(script_dir, sampling_file)

  readr::write_tsv(df, sampling_path)

  sampling_path
}


#' Pipe operator
#'
#' See \code{magrittr::\link[magrittr:pipe]{\%>\%}} for details.
#'
#' @name %>%
#' @rdname pipe
#' @keywords internal
#' @export
#' @importFrom magrittr %>%
#' @usage lhs \%>\% rhs
NULL

utils::globalVariables(
  names = c("time", "prop", "ancestry", "newx", "newy", "pop",
  "tblock", "start", ".", "tstart_orig", "tend_orig", "type", "rate",
  "node1.name", "node2.name", "from_x", "from_y", "from", "to_x", "to_y",
  "to"), package = "slendr"
)
