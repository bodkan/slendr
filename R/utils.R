# Get path to an appropriate SLiM binary
get_binary <- function(method) {
  if (method == "gui") {
    if (Sys.info()["sysname"] == "Darwin")
      return("open -a SLiMgui")
    else
      binary <- "SLiMgui"
  } else
    binary <- "slim"

  binary_path <- Sys.which(binary)
  if (all(binary_path == ""))
    stop(sprintf("%s binary not found. Please modify your $PATH accordingly or
specify the path manually by setting the 'binary_path' argument.", binary),
call. = FALSE)
  else
    return(as.character(binary_path))
}


# Check whether given population region has not yet been intersected
check_not_intersected <- function(pop) {
  if (!is.null(attr(pop, "intersected")))
    stop("An already intersected population range object was provided.
Please provide a range object before it was intersected against a map.",
         call. = FALSE)
}


# Check whether the given value makes sense given the map dimensions
check_resolution <- function(map, val) {
  xrange <- sf::st_bbox(map)[c("xmin", "xmax")]
  yrange <- sf::st_bbox(map)[c("ymin", "ymax")]
  if (diff(xrange) < val | diff(yrange) < val)
    stop(sprintf("Value of %s = %s larger than the overall world size",
                 deparse(substitute(val)), val),
         call. = FALSE)
}


# Set a bounding box of a given object, and return that object again
# (for some reason there's no builtin way to set a bounding box in
# sf <https://twitter.com/TimSalabim3/status/1063099774977667072>)
set_bbox <- function(x, xmin, xmax, ymin, ymax) {
  bbox <- c(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax)
  attr(bbox, "class") <- "bbox"
  attr(sf::st_geometry(x), "bbox") <- bbox
  x
}


# Does the object have a Coordinate Reference System assigned to it?
has_crs <- function(x) {
  !is.na(sf::st_crs(x)$epsg)
}


# Set slendr classes (or fix their priorities if already present)
set_class <- function(x, type) {
  other_classes <- class(x) %>% .[!grepl("^slendr", .)]
  c("slendr", paste0("slendr_", type), other_classes)
}


# Read ancestry proportion tables generated by the backend SLiM script
read_ancestries <- function(model_dir) {
  files <- list.files(model_dir, pattern = ".*ancestry_.*.tsv$", full.names = TRUE)
  if (!length(files))
    stop("No ancestry proportion tables found. Did you specify the correct path?",
         call. = FALSE)

  lapply(files, function(f) {
    anc_df <- data.table::fread(f)
    if (nrow(anc_df) > 0)
      anc_df$pop <- gsub(".*_ancestry_(.*).tsv", "\\1", f)
    anc_df
  }) %>% do.call(rbind, .)
}


# Get a data frame of geneflow events active at a given time point
get_geneflows <- function(model, time) {
  if (is.null(model$geneflow)) return(NULL)
  pop_names <- unique(unlist(sapply(model$populations, `[[`, "pop")))

  geneflows <- subset(model$geneflow, tstart_orig >= time & tend_orig <= time)
  geneflows$from <- factor(geneflows$from, levels = pop_names)
  geneflows$to <- factor(geneflows$to, levels = pop_names)

  migr_coords <- lapply(seq_len(nrow(geneflows)), function(row_i) {

    from <- model$populations[pop_names == geneflows[row_i, ]$from][[1]] %>%
      .[.$time >= time, ] %>%
      .[nrow(.), ]

    to <- model$populations[pop_names == geneflows[row_i, ]$to][[1]] %>%
      .[.$time >= time, ] %>%
      .[nrow(.), ]

    from_center <- sf::st_centroid(from) %>% sf::st_coordinates()
    to_center <- sf::st_centroid(to) %>% sf::st_coordinates()

    coords <- as.data.frame(cbind(from_center, to_center), stringsAsFactors = FALSE)
    colnames(coords) <- c("from_x", "from_y", "to_x", "to_y")
    coords

  }) %>%
  do.call(rbind, .)

  cbind(geneflows, migr_coords)
}


# Transfer given set of attributes from one object to another
copy_attributes <- function(to, from, which) {
  for (i in which)
    attr(to, i) <- attr(from, i)
  class(to) <- class(from)
  to
}


# Get split times of populations in the lineage of the given population
get_lineage_splits <- function(x) {
  parent <- attr(x, "parent")
  if (is.character(parent))
    return(x$time[1])
  else
    return(c(x$time[1], get_lineage_splits(parent)))
}


# Get direction of time implied by the model
get_time_direction <- function(pop) {
  split_times <- get_lineage_splits(pop)

  if (length(split_times) == 1) {
    event_times <- attr(pop, "history") %>%
      sapply(function(event) c(event$time, event$start, event$end)) %>%
      unlist
    if (length(event_times) == 1)
        "unknown"
    else if (all(diff(event_times) < 0))
      "backward"
    else
      "forward"
  } else if (all(diff(split_times) > 0))
    "backward"
  else
    "forward"
}


# Check the consistency of the given split time to the parent population
check_split_time <- function(time, parent) {
  parent_time <- parent$time[1]
  direction <- get_time_direction(parent)
  if (direction == "forward" & time <= parent_time) {
    stop(sprintf("The model implies forward time direction but the specified split
time (%d) is lower than the parent's (%s)",
                 time, parent_time),
         call. = FALSE)
  } else if (direction == "backward" & time >= parent_time) {
    stop(sprintf("The model implies backward time direction but the specified split
time (%s) is higher than the parent's (%s)",
                 time, parent_time),
         call. = FALSE)
  }
}


# Get time of the very last event currently specified
get_previous_time <- function(pop) {
  sapply(attr(pop, "history"), function(event) {
    c(event$time, event$start, event$end)
  }) %>%
    Filter(Negate(is.null), .) %>%
    unlist %>%
    tail(1)
}


check_event_time <- function(time, pop) {
  direction <- get_time_direction(pop)

  previous_time <- get_previous_time(pop)

  comp <- if (direction == "backward") `>` else `<`

  # test if all times are consistent with the assumed time direction
  if (direction != "unknown" & length(time) > 1 & all(comp(diff(time), 0)))
      stop(sprintf("The specified start-end time window is inconsistent with the %s time direction assumed by the model", direction),
           call. = FALSE)

  # check consistency of times with the last specified time event for
  # this population
  if (direction != "unknown" & !all(comp(previous_time, time)))
    stop(sprintf("The specified event time (%s) is inconsistent with last active time (%s) given the assumed %s time direction",
                 paste(time, collapse = "-"), previous_time, direction),
         call. = FALSE)
}


check_removal_time <- function(time, pop) {
  direction <- get_time_direction(pop)

  removal_time <- attr(pop, "remove")
  if (removal_time != -1 & direction == "forward" & any(time > removal_time)) {
    stop(sprintf("The specified event time (%d) is not consistent with the scheduled removal of %s (%s). ",
                 time, pop$pop[1], removal_time),
         call. = FALSE)
  }
  if (removal_time != -1 & direction == "backward" & any(time < removal_time)) {
    stop(sprintf("The specified event time (%d) is not consistent with the scheduled removal of %s (%s). ",
                 time, pop$pop[1], removal_time),
         call. = FALSE)
  }
}


# Calculate overlap between subsequent spatial maps
compute_overlaps <- function(x) {
  sf::st_agr(x) <- "constant"
  sapply(
    (1:nrow(x))[-1], function(i) {
      a <- x[i - 1, ]
      b <- x[i, ]
      intersection <- sf::st_intersection(a, b)
      if (nrow(intersection) == 0) return(0)
      sf::st_area(intersection) / sf::st_area(b)
    }
  )
}


# Take care of missing interactions and offspring distances
set_distances <- function(split_table, resolution,
                          competition_dist, mate_dist, offspring_dist) {
  if (any(is.na(split_table$competition_dist))) {
    if (is.null(competition_dist)) {
      pop_names <- paste(split_table[is.na(split_table$competition_dist), ]$pop, collapse = ", ")
      stop("Parameter 'competition_dist' missing for ", pop_names, " and a general
  value of this parameter was not provided to the compile() function", call. = FALSE)
    } else
      split_table$competition_dist[is.na(split_table$competition_dist)] <- competition_dist
  }

  if (any(is.na(split_table$mate_dist))) {
    if (is.null(mate_dist)) {
      pop_names <- paste(split_table[is.na(split_table$mate_dist), ]$pop, collapse = ", ")
      stop("Parameter 'mate_dist' missing for ", pop_names, " and a general
  value of this parameter was not provided to the compile() function", call. = FALSE)
    } else
      split_table$mate_dist[is.na(split_table$mate_dist)] <- mate_dist
  }

  if (any(is.na(split_table$offspring_dist))) {
    if (is.null(offspring_dist)) {
      pop_names <- paste(split_table[is.na(split_table$offspring_dist), ]$pop, collapse = ", ")
      stop("Parameter 'offspring_dist' missing for ", pop_names, " and a general
  value of this parameter was not provided to the compile() function", call. = FALSE)
    } else
      split_table$offspring_dist[is.na(split_table$offspring_dist)] <- offspring_dist
  }

  split_table[, c("competition_dist", "mate_dist", "offspring_dist")] <-
    split_table[, c("competition_dist", "mate_dist", "offspring_dist")] / resolution

  split_table
}


#' Pipe operator
#'
#' See \code{magrittr::\link[magrittr:pipe]{\%>\%}} for details.
#'
#' @name %>%
#' @rdname pipe
#' @keywords internal
#' @export
#' @importFrom magrittr %>%
#' @usage lhs \%>\% rhs
NULL

utils::globalVariables(
  names = c("time", "prop", "ancestry", "newx", "newy", "pop",
  "tblock", "start", ".", "tstart_orig", "tend_orig", "type", "rate",
  "node1.name", "node2.name", "from_x", "from_y", "from", "to_x", "to_y",
  "to"), package = "slendr"
)