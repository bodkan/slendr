#' Check whether given population region has not yet been intersected
check_not_intersected <- function(pop) {
  if (!is.null(attr(pop, "intersected")))
    stop("An already intersected population range object was provided.
Please provide a range object before it was intersected against a map.",
         call. = FALSE)
}


#' Check whether the given value makes sense given the map dimensions
check_resolution <- function(map, val) {
  xrange <- sf::st_bbox(map)[c("xmin", "xmax")]
  yrange <- sf::st_bbox(map)[c("ymin", "ymax")]
  if (diff(xrange) < val | diff(yrange) < val)
    stop(sprintf("Value of %s = %s larger than the overall world size",
                 deparse(substitute(val)), val),
         call. = FALSE)
}

#' Set a bounding box of a given object, and return that object again
#' (for some reason there's no builtin way to set a bounding box in
#' sf <https://twitter.com/TimSalabim3/status/1063099774977667072>)
set_bbox <- function(x, xmin, xmax, ymin, ymax) {
  bbox <- c(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax)
  attr(bbox, "class") <- "bbox"
  attr(sf::st_geometry(x), "bbox") <- bbox
  x
}


#' Does the object have a Coordinate Reference System assigned to it?
has_crs <- function(x) {
  !is.na(sf::st_crs(x)$epsg)
}


#' Set spannr classes (or fix their priorities if already present)
set_class <- function(x, type) {
  other_classes <- class(x) %>% .[!grepl("^spannr", .)]
  c("spannr", paste0("spannr_", type), other_classes)
}


#' Read ancestry proportion tables generated by the backend SLiM script
read_ancestries <- function(model_dir) {
  files <- list.files(model_dir, pattern = ".*ancestry_.*.tsv$", full.names = TRUE)
  if (!length(files))
    stop("No ancestry proportion tables found. Did you specify the correct path?", call. = FALSE)

  lapply(files, function(f) {
    anc_df <- read.table(f, header = TRUE)
    if (nrow(anc_df) > 0)
      anc_df$pop <- gsub(".*_ancestry_(.*).tsv", "\\1", f)
    anc_df
  }) %>% do.call(rbind, .)
}


#' Get a data frame of migration events active at a given time point
get_migrations <- function(model, time) {
  if (is.null(model$admixtures)) return(NULL)
  pop_names <- unique(unlist(sapply(model$populations, `[[`, "pop")))

  migrations <- subset(model$admixtures, tstart >= time & tend <= time)
  migrations$from <- factor(migrations$from, levels = pop_names)
  migrations$to <- factor(migrations$to, levels = pop_names)

  migr_coords <- lapply(seq_len(nrow(migrations)), function(row_i) {

    from <- model$populations[pop_names == migrations[row_i, ]$from][[1]] %>%
      .[.$time >= time, ] %>%
      .[nrow(.), ]

    to <- model$populations[pop_names == migrations[row_i, ]$to][[1]] %>%
      .[.$time >= time, ] %>%
      .[nrow(.), ]

    from_center <- sf::st_centroid(from) %>% sf::st_coordinates()
    to_center <- sf::st_centroid(to) %>% sf::st_coordinates()

    coords <- as.data.frame(cbind(from_center, to_center), stringsAsFactors = FALSE)
    colnames(coords) <- c("from_x", "from_y", "to_x", "to_y")
    coords

  }) %>% do.call(rbind, .)

  cbind(migrations, migr_coords)
}


#' Transfer given set of attributes from one object to another
copy_attributes <- function(to, from, which) {
  for (i in which) {
    if (!i %in% names(attributes(from)))
      stop("Unknown attribute ", i, call. = FALSE)
    attr(to, i) <- attr(from, i)
  }
  class(to) <- class(from)
  to
}


#' Pipe operator
#'
#' See \code{magrittr::\link[magrittr:pipe]{\%>\%}} for details.
#'
#' @name %>%
#' @rdname pipe
#' @keywords internal
#' @export
#' @importFrom magrittr %>%
#' @usage lhs \%>\% rhs
NULL
