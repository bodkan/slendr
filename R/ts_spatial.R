#' Convert tree sequence data to a spatial format
#'
#' @param ts pyslim.SlimTreeSequence object
#' @param crs For spatial models, which coordinate reference system to reproject
#'   individual locations to? If \code{NULL} (default), coordinates are
#'   reprojected to the coordinate reference system (CRS) of the entire spatial
#'   model. Alternatively, a CRS code accepted by GDAL, a valid integer EPSG
#'   value, an object of class \code{crs}, can be specified to change the
#'   reprojection to a different CRS.
#'
#' @return Spatial object of the class \code{slendr_ts} and \code{sf}
#'
#' @export
ts_spatial <- function(ts, crs = NULL) {
  check_ts_class(ts)

  if (!has_map(model$populations[[1]]))
    stop("Cannot create a spatial object from tree sequence data generated by a non-spatial model.",
         call. = FALSE)

  model <- ts_model(ts)
  individuals <- ts_individuals(ts)

  # process table of individuals to get locations and times of all nodes
  # (remembered or retained)
  nodes <- individuals %>%
    tidyr::gather("node", "node_id", c("chr1_id", "chr2_id")) %>%
    dplyr::select(name, time, pop, raster_x, raster_y, node_id) %>%
    dplyr::filter(!is.na(node_id)) # at least one node in an individual recorded

  nodes_sf <- convert_to_sf(nodes, model, crs)

  attr(nodes_sf, "model") <- model
  class(nodes_sf) <- set_class(nodes_sf, "spatial")

  nodes_sf
}


#' Extract the ancestral relationships for a set of nodes
#'
#' @param data Object of the class \code{slendr_spatial} carrying the
#'   spatio-temporal position of each individual node in the tree sequence
#' @param ts pyslim.SlimTreeSequence object of the class \code{slendr_ts}
#'   obtained by \code{link{ts_load}}, \code{link{ts_recapitate}},
#'   \code{link{ts_simplify}}, or \code{link{ts_mutate}}
#' @param x Either a string representing an individual name, or an integer
#'   number specifying a node in a tree sequence
#'
#' @export
ts_ancestors <- function(x, data, ts) {
  check_ts_class(ts)
  model <- ts_model(ts)
  edges <- ts_edges(ts)

  # collect child-parent links for all samples in the tree sequence
  collect_ancestors(x, edges)

  child_data <- dplyr::select(data, name, pop, node_id, time, location)
  parent_data <- dplyr::select(data, parent_pop = pop, parent_id = node_id, parent_time = time, parent_location = location)

  combined <-result %>%
    dplyr::inner_join(child_data, by = c("child" = "node_id")) %>%
    dplyr::inner_join(parent_data, by = c("parent" = "parent_id")) %>%
    sf::st_as_sf()

  connections <- purrr::map2(
    combined$location, combined$parent_location, ~
      sf::st_union(.x, .y) %>%
      sf::st_cast("LINESTRING") %>%
      sf::st_sfc() %>%
      sf::st_sf(connection = ., crs = sf::st_crs(combined))) %>%
    dplyr::bind_rows()

  final <- dplyr::bind_cols(combined, connections) %>%
    sf::st_set_geometry("connection") %>%
    dplyr::select(name, node_id = child, pop, time, location,
                  level, parent_id = parent, parent_pop, parent_time,
                  parent_location, connection,
                  left_pos = left, right_pos = right) %>%
    dplyr::mutate(level = as.factor(level))

  attr(final, "model") <- model
  class(final) <- set_class(final, "spatial")

  final
}

# Collect all ancestors of a given node up to the root by traversing the tree
# edges "bottom-up" using a queue
collect_ancestors <- function(node_id, edges) {
  # list collecting all edges leading from the focal node
  result <- list()

  # initialize the counter of nodes already processed by the queue
  n_nodes <- length(unique(c(edges$child, edges$parent)))
  processed_nodes <- vector(length = n_nodes + 1)

  # add all edges leading from the focal node to the queue
  edge <- edges[edges$child %in% node_id, ] %>% dplyr::mutate(level = 1)
  queue <- split(edge, edge$child)

  # repeat until the queue is empty (this homebrew queue implementation is
  # probably horribly inefficient but it will do for now)
  while (TRUE) {
    # pop out the first element
    item <- queue[[1]]; queue[[1]] <- NULL

    # add it to the final list
    result <- append(result, list(item))

    # iterate over all parents of the current node
    for (parent in split(item, item$parent)) {
      # get edges leading from the current parent to its own parent
      edge <- edges[edges$child == unique(parent$parent), ]

      # if the parent has no parent itself or its node has already been
      # processed, skip it and don't add it to the queue
      if (nrow(edge) == 0) next
      if (processed_nodes[unique(edge$child) + 1]) next

      # mark the node as processed...
      processed_nodes[unique(edge$child) + 1] <- TRUE
      # ... and add it to the queue
      edge$level <- item$level[1] + 1
      queue[[length(queue) + 1]] <- edge
    }

    if (length(queue) == 0) break
  }

  result <- dplyr::bind_rows(result)

  result
}

#' Plot locations of ancestors of given individual or node on a map
#'
#' @param spatial ts data XXXXX
#' @param x Either a string representing an individual name, or an integer
#'   number specifying a node in a tree sequence
#' @param full_scale Plot time gradient on the full scale (spanning the oldest
#'   sampled individual to the present)
#'
#' @export
plot_ancestors <- function(data, x, full_scale = TRUE,
                           younger_than = NULL, color = c("level", "time")) {
  model <- attr(data, "model")
  color <- match.arg(color)

  # if specified, narrow down samples to a given time window
  comp_op <- ifelse(model$direction == "backward", `>`, `<`)
  if (!is.null(younger_than)) data <- dplyr::filter(data, !comp_op(parent_time, younger_than))

  # a name of a sampled individual was specified
  if (is.character(x)) {
    if (!all(x %in% data$name))
      stop("Unknown individual", x[!x %in% data$name], call. = FALSE)
    id <- dplyr::filter(data, name %in% x)$node_id
  } else if (is.numeric(x))
    id <- x
  else
    stop("Unknown object given as an individual or a node", call. = FALSE)

  # extract the focal individual or node
  focal_node <- dplyr::filter(data, node_id %in% id) %>%
    sf::st_as_sf() %>%
    sf::st_set_geometry("location")

  link_aes <- if (color == "time") aes(color = time) else aes(color = level)

  ggplot() +
    # world map
    geom_sf(data = model$world, fill = "lightgray", color = NA) +

    # links between nodes ("spatial branches")
    geom_sf(data = data, link_aes, size = 0.5, alpha = 0.75) +

    # focal individual (or)
    geom_sf(data = focal_node, shape = 13, size = 3, color = "red") +

    # all ancestral nodes
    geom_sf(data = sf::st_set_geometry(data, "parent_location"),
            aes(shape = parent_pop), alpha = 0.5) +

    coord_sf(expand = 0) +
    ggtitle(paste("Spatio-temporal placement of the ancestors of", x)) +
    theme_bw()
}

#' Plot locations of sampled individuals
#'
#' @param spatial ts data XXXXX
#' @param pop Name of the population to plot
#' @param older_than,younger_than Time boundaries for the samples
#' @param full_scale Plot time gradient on the full scale (spanning the oldest
#'   sampled individual to the present)
#'
#' @return A ggplot2 object with a map and locations of sampled individual
#'
#' @export
plot_samples <- function(data, pop = NULL, full_scale = TRUE,
                         older_than = NULL, younger_than = NULL) {
  model <- attr(data, "model")

  # first subset only to explicitly sampled individuals (those have proper
  # names extracted from the sampling table)
  data <- dplyr::filter(data, !is.na(name))

  # if specified, narrow down samples to a given time window
  comp_op <- ifelse(model$direction == "backward", `>`, `<`)
  if (!is.null(older_than)) data <- dplyr::filter(data, comp_op(time, older_than))
  if (!is.null(younger_than)) data <- dplyr::filter(data, !comp_op(time, younger_than))

  # if specified, subset the samples to those from a given population
  if (!is.null(pop)) data <- dplyr::filter(data, pop == !!pop)

  p <- ggplot() +
    geom_sf(data = model$world, fill = "lightgray", color = NA) +
    geom_sf(data = data, aes(shape = pop, color = time)) +
    coord_sf(expand = 0) +
    ggtitle("Spatio-temporal placement of sampled individuals") +
    theme_bw()

  if (full_scale)
    p <- p + scale_color_gradient(limits = c(0, model$length))

  p
}

# Convert a data frame of information extracted from a tree sequence
# table to an sf spatial object
convert_to_sf <- function(df, model, crs) {
  # reproject coordinates to the original crs
  if (has_crs(model$world)) {
    if (is.null(crs)) crs <- sf::st_crs(model$world)

    locations <- reproject(
      from = "raster", to = crs, coords = df, model = model,
      input_prefix = "raster_", output_prefix = "", add = TRUE
    )
  } else {
    locations <- df
    locations$x <- locations$raster_x
    locations$y <- locations$raster_y
  }

  result <- sf::st_as_sf(locations, coords = c("x", "y"), crs = crs) %>%
    dplyr::mutate(time = as.integer(time)) %>%
    dplyr::select(name, pop, node_id, time, location = geometry)

  result
}
