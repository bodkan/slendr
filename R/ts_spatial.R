#' Convert tree sequence data to a spatial format
#'
#' @param ts pyslim.SlimTreeSequence object
#' @param crs For spatial models, which coordinate reference system to reproject
#'   individual locations to? If \code{NULL} (default), coordinates are
#'   reprojected to the coordinate reference system (CRS) of the entire spatial
#'   model. Alternatively, a CRS code accepted by GDAL, a valid integer EPSG
#'   value, an object of class \code{crs}, can be specified to change the
#'   reprojection to a different CRS.
#'
#' @return Spatial object of the class \code{slendr_ts} and \code{sf}
#'
#' @export
ts_spatial <- function(ts, crs = NULL) {
  check_ts_class(ts)

  if (!has_map(model$populations[[1]]))
    stop("Cannot create a spatial object from tree sequence data generated by a non-spatial model.",
         call. = FALSE)

  model <- ts_model(ts)
  individuals <- ts_individuals(ts)

  # process table of individuals to get locations and times of all nodes
  # (remembered or retained)
  nodes <- individuals %>%
    tidyr::gather("node", "node_id", c("chr1_id", "chr2_id")) %>%
    dplyr::select(name, time, pop, raster_x, raster_y, node_id) %>%
    dplyr::filter(!is.na(node_id)) # at least one node in an individual recorded

  nodes_sf <- convert_to_sf(nodes, model, crs)

  attr(nodes_sf, "model") <- model
  class(nodes_sf) <- set_class(nodes_sf, "spatial")

  nodes_sf
}


#' Extract the ancestral relationships for a set of nodes
#'
#' @param data Object of the class \code{slendr_spatial} carrying the
#'   spatio-temporal position of each individual node in the tree sequence
#' @param ts pyslim.SlimTreeSequence object of the class \code{slendr_ts}
#'   obtained by \code{link{ts_load}}, \code{link{ts_recapitate}},
#'   \code{link{ts_simplify}}, or \code{link{ts_mutate}}
#' @param x Either a string representing an individual name, or an integer
#'   number specifying a node in a tree sequence
#'
#' @export
ts_ancestors <- function(x, data, ts) {
  check_ts_class(ts)
  model <- ts_model(ts)
  edges <- ts_edges(ts)

  # collect child-parent links for all samples in the tree sequence
  collect_ancestors(x, edges)

  child_data <- dplyr::select(data, name, pop, node_id, time, location)
  parent_data <- dplyr::select(data, parent_pop = pop, parent_id = node_id, parent_time = time, parent_location = location)

  combined <-result %>%
    dplyr::inner_join(child_data, by = c("child" = "node_id")) %>%
    dplyr::inner_join(parent_data, by = c("parent" = "parent_id")) %>%
    sf::st_as_sf()

  connections <- purrr::map2(
    combined$location, combined$parent_location, ~
      sf::st_union(.x, .y) %>%
      sf::st_cast("LINESTRING") %>%
      sf::st_sfc() %>%
      sf::st_sf(connection = ., crs = sf::st_crs(combined))) %>%
    dplyr::bind_rows()

  final <- dplyr::bind_cols(combined, connections) %>%
    sf::st_set_geometry("connection") %>%
    dplyr::select(name, node_id = child, pop, time, location,
                  level, parent_id = parent, parent_pop, parent_time,
                  parent_location, connection,
                  left_pos = left, right_pos = right) %>%
    dplyr::mutate(level = as.factor(level))

  attr(final, "model") <- model
  class(final) <- set_class(final, "spatial")

  final
}

# Collect all ancestors of a given node up to the root by traversing the tree
# edges "bottom-up" using a queue
collect_ancestors <- function(node_id, edges) {
  # list collecting all edges leading from the focal node
  result <- list()

  # initialize the counter of nodes already processed by the queue
  n_nodes <- length(unique(c(edges$child, edges$parent)))
  processed_nodes <- vector(length = n_nodes + 1)

  # add all edges leading from the focal node to the queue
  edge <- edges[edges$child %in% node_id, ] %>% dplyr::mutate(level = 1)
  queue <- split(edge, edge$child)

  # repeat until the queue is empty (this homebrew queue implementation is
  # probably horribly inefficient but it will do for now)
  while (TRUE) {
    # pop out the first element
    item <- queue[[1]]; queue[[1]] <- NULL

    # add it to the final list
    result <- append(result, list(item))

    # iterate over all parents of the current node
    for (parent in split(item, item$parent)) {
      # get edges leading from the current parent to its own parent
      edge <- edges[edges$child == unique(parent$parent), ]

      # if the parent has no parent itself or its node has already been
      # processed, skip it and don't add it to the queue
      if (nrow(edge) == 0) next
      if (processed_nodes[unique(edge$child) + 1]) next

      # mark the node as processed...
      processed_nodes[unique(edge$child) + 1] <- TRUE
      # ... and add it to the queue
      edge$level <- item$level[1] + 1
      queue[[length(queue) + 1]] <- edge
    }

    if (length(queue) == 0) break
  }

  result <- dplyr::bind_rows(result)

  result
}

# Convert a data frame of information extracted from a tree sequence
# table to an sf spatial object
convert_to_sf <- function(df, model, crs) {
  # reproject coordinates to the original crs
  if (has_crs(model$world)) {
    if (is.null(crs)) crs <- sf::st_crs(model$world)

    locations <- reproject(
      from = "raster", to = crs, coords = df, model = model,
      input_prefix = "raster_", output_prefix = "", add = TRUE
    )
  } else {
    locations <- df
    locations$x <- locations$raster_x
    locations$y <- locations$raster_y
  }

  result <- sf::st_as_sf(locations, coords = c("x", "y"), crs = crs) %>%
    dplyr::mutate(time = as.integer(time)) %>%
    dplyr::select(name, pop, node_id, time, location = geometry)

  result
}
