#' Compile the spatial maps and split/admixture tables
#'
#' @param populations Population map objects of the \code{spammr_pop} class (a
#'   list of such object or a single element)
#' @param model_dir Directory to which to save the entire model
#' @param admixtures Admixture events generated by the \code{admixture} function
#'   (either a list of data.frame objects - one per admixture event, or a single
#'   data.frame for one admixture event)
#' @param gen_time Generation time (in model's time units, i.e. years)
#' @param resolution How many kilometers per pixel?
#' @param overwrite Overwrite the contents of the output directory (in case it
#'   already exists)?
#'
#' @export
compile <- function(populations, model_dir, gen_time, resolution, admixtures = NULL, overwrite = FALSE) {
  if (!inherits(populations, "list"))
    populations <- list(populations)

  # save split and admixture tables which will be returned in the model object
  # in separate objects (tables serialized for SLiM will have to be stripped
  # first)
  return_splits <- compile_splits(populations)
  if (!is.null(admixtures)) {
    # lets take care of the fact that most users will input single admixture
    # events as just a single data frame (can't blame them)
    if (is.data.frame(admixtures))
      admixtures <- list(admixtures)
    return_admixtures <- do.call(rbind, admixtures)
    names(return_admixtures)[1:2] <- c("from", "to")
  } else
    return_admixtures <- NULL

  # convert times into generations (only in the table of splits which will be
  # saved for later SLiM runs)
  splits_table <- return_splits
  splits_table$tsplit <- splits_table$tsplit / gen_time
  splits_table$tremove[splits_table$tremove != -1] <- splits_table$tremove[splits_table$tremove != -1] / gen_time

  # compile the spatial maps
  maps_table <- compile_maps(populations, splits_table, resolution * 1000)

  # prepare the model output directory
  if (dir.exists(model_dir)) {
    if (!overwrite)
      stop("Output directory already exists - either delete it or set 'overwrite = TRUE'",
           call. = FALSE)
    else
      unlink(model_dir, recursive = TRUE, force = TRUE)

  }
  dir.create(model_dir)

  # save the rasterized maps as PNG files
  write_maps(maps_table, model_dir)

  # keep the original spatial map table for returning as a model object later
  return_maps <- maps_table
  return_maps$path <- return_maps$map_number %>%
    paste0(., ".png") %>% file.path(model_dir, .) %>% gsub("//", "/", .)

  # take care of Inf/NA values for downstream SLiM runs (-1 will be interpreted
  # as a special value, such as for the "split time" of ancestral populations,
  # or their "parental" populations) - this is very ugly, but we're limited by
  # what SLiM's programming language can do...
  splits_table$tsplit <- ifelse(splits_table$tsplit == Inf, -1, splits_table$tsplit)
  maps_table$time <- ifelse(maps_table$time == Inf, -1, maps_table$time)
  maps_table$time[maps_table$time != -1] <- maps_table$time[maps_table$time != -1] / gen_time
  splits_table$parent_id <- ifelse(is.na(splits_table$parent_id), -1, splits_table$parent_id)

  # reformat the admixture table
  if (!is.null(return_admixtures)) {
    # make a copy of the admixture table for processing and saving
    admix_table <- return_admixtures

    admix_table$tstart <- admix_table$tstart / gen_time
    admix_table$tend <- admix_table$tend / gen_time
    admix_table$rate <- as.integer(admix_table$rate * 100)
    # convert population names and their parents' names to SLiM numbers
    admix_table$from_id <- unlist(lapply(
      admix_table$from,
      function(i) splits_table[splits_table$pop == i, ]$pop_id
    ))
    admix_table$to_id <- unlist(lapply(
      admix_table$to,
      function(i) splits_table[splits_table$pop == i, ]$pop_id
    ))
    admix_table$overlap <- as.integer(admix_table$overlap)
  } else
    admix_table <- NULL

  write_model(model_dir, populations, splits_table, admix_table, maps_table, gen_time)

  result <- list(
    config = list(
      directory = model_dir,
      splits = file.path(model_dir, "splits.tsv"),
      maps = file.path(model_dir, "maps.tsv"),
      admixtures = if (is.null(admixtures)) NULL else file.path(model_dir, "admixtures.tsv")
    ),
    populations = populations,
    splits = return_splits[, c("pop", "parent", "tsplit", "Ne", "tremove")],
    admixtures = return_admixtures,
    maps = return_maps[, c("pop", "time", "path")],
    gen_time = gen_time
  )

  class(result) <- set_class(result, "model")

  result
}


#' Load a previously serialized spammr model
#'
#' @param model_dir Directory with all required configuration files
#'
#' @export
load <- function(model_dir) {
  # paths to files which are saved by the compile() function and are necessary
  # for running the backend script using the run() function
  path_populations <- file.path(model_dir, "populations.rds")
  path_splits <- file.path(model_dir, "splits.tsv")
  path_admixtures <- file.path(model_dir, "admixtures.tsv")
  path_maps <- file.path(model_dir, "maps.tsv")
  path_names <- file.path(model_dir, "names.txt")
  path_gen_time <- file.path(model_dir, "gen_time.txt")

  if (!dir.exists(model_dir))
    stop(sprintf("Model directory '%s' does not exist", model_dir), call. = FALSE)

  if (!all(file.exists(c(path_populations, path_splits, path_maps, path_names))))
    stop(sprintf("Directory '%s' does not contain all spammr configuration files.
Please make sure that populations.rds, {splits,admixtures,maps}.tsv, names.txt and gen_time.txt are all present", model_dir), call. = FALSE)

  pop_names <- scan(path_names, what = "character", quiet = TRUE)
  gen_time <- scan(path_gen_time, what = integer(), quiet = TRUE)

  # load the split table from disk and re-format it to the original format
  splits <- read.table(path_splits, header = TRUE, stringsAsFactors = FALSE)
  # add population labels and parent population labels (these are striped away
  # during model saving because SLiM can't handle mixed types in matrices)
  splits$pop <- pop_names[splits$pop_id + 1]
  ancestral <- splits$parent == -1
  splits$parent[ancestral] <- "ancestor"
  if (any(!ancestral))
    splits$parent[!ancestral] <- pop_names[splits$parent_id[!ancestral] + 1]

  # load and reformat the admixtures table (if present - if absent, no admixture
  # was specified)
  admixtures <- NULL
  if (file.exists(path_admixtures)) {
    admixtures <- read.table(path_admixtures, header = TRUE, stringsAsFactors = FALSE)
    admixtures$from <- pop_names[admixtures$from + 1]
    admixtures$to <- pop_names[admixtures$to + 1]
    admixtures$rate <- admixtures$rate / 100
    admixtures$tstart <- round(admixtures$tstart * gen_time)
    admixtures$tend <- round(admixtures$tend * gen_time)
    admixtures$overlap <- admixtures$overlap == 1
    admixtures <- admixtures[, c("from", "to", "tstart", "tend", "rate", "overlap")]
  }

  # load and reformat the maps table
  maps <- read.table(path_maps, header = TRUE, stringsAsFactors = FALSE)
  # reconstruct the paths to each raster map (again, stripped away because SLiM
  # can't handle strings and numbers in a single matrix/data frame)
  maps$path <- file.path(model_dir, paste0(maps$map_number, ".png")) %>% gsub("//", "/", .)
  if (!all(file.exists(maps$path)))
    stop(sprintf("Directory '%s' does not contain all maps required by the model configuration (%s)", model_dir, maps$map), call. = FALSE)
  # recreate the user-specified population labels
  maps$pop <- pop_names[maps$pop_id + 1]

  # convert times to their original value before conversion for SLiM (this
  # handling of -1 and Inf special cases is absolutely awful, but we are
  # currently forced to do this because we need to interface with the rather
  # limited SLiM builtin language)
  splits$tsplit[splits$tsplit == -1] <- Inf
  maps$time[maps$time == -1] <- Inf
  # convert generations back to years
  splits$tsplit <- round(splits$tsplit * gen_time)
  splits$tremove[splits$tremove != -1] <- round(splits$tremove[splits$tremove != -1] * gen_time)
  maps$time <- round(maps$time * gen_time)

  result <- list(
    config = list(
      directory = model_dir,
      splits = path_splits,
      maps = path_maps,
      admixtures = if (is.null(admixtures)) NULL else file.path(model_dir, "admixtures.tsv")
    ),
    populations = readRDS(path_populations),
    splits = splits[, c("pop", "parent", "tsplit", "Ne", "tremove")],
    admixtures = admixtures,
    maps = maps[, c("pop", "time", "path")],
    gen_time = gen_time
  )

  class(result) <- set_class(result, "model")

  result
}


#' Open the compiled spatial model in SLiM
#'
#' When run, the compiled SLiM script will save the location of each individual
#' that ever lived, and will also record a sample of ancient individuals from
#' each population in a tree sequence data structure which will be saved for all
#' "present-day" individuals at the end of the simulation. This obviously does
#' not make sense for all potential uses and the exact specification of output
#' formats will be changed at some point soon.
#'
#' @param model Compiled model object
#' @param gen_time Generation time (in model's time units, i.e. years)
#' @param burnin Length of the burnin (in model's time units, i.e. years)
#' @param sim_length Total length of the simulation (in model's time units, i.e.
#'   years)
#' @param seq_length Total length of the simulated sequence in base-pairs
#' @param recomb_rate Recombination rate of the simulated sequence
#' @param max_distance,max_spread Maximum values for spatial interaction and
#'   mating choice (max_distance) and maximum distance for offspring from its
#'   parents (max_spread)
#' @param save_locations Save location of each individual throughout the
#'   simulation?
#' @param track_ancestry Track ancestry proportion dynamics in all populations
#'   throughout the simulations (default FALSE)? If a non-zero integer is
#'   provided, ancestry will be tracked using the number number of neutral
#'   ancestry markers equal to this number.
#' @param gui Run in SLiM GUI instead of command-line? (default)
#' @param include Vector of paths to custom SLiM scripts which should be
#'   combined with the backend SLiM code
#' @param output_dir Where to put potential output files?
#'
#' @export
run <- function(model, burnin, sim_length, seq_length, recomb_rate,
                max_distance, max_spread,
                save_locations = FALSE, track_ancestry = FALSE,
                gui = TRUE, verbose = FALSE, include = NULL,
                output_dir = model$config$directory) {
  model_dir <- model$config$directory
  if (!dir.exists(model_dir))
    stop(sprintf("Model directory '%s' does not exist", model_dir), call. = FALSE)

  if (!dir.exists(output_dir)) dir.create(output_dir)

  if (!all(file.exists(file.path(model_dir, c("splits.tsv", "maps.tsv")))))
    stop(sprintf("Directory '%s' does not contain spammr configuration files", model_dir), call. = FALSE)

  if (!length(list.files(model_dir, pattern = "*.png") == 0))
    stop(sprintf("Directory '%s' does not contain any spammr spatial raster maps", model_dir), call. = FALSE)

  if (!is.logical(track_ancestry) & !is.numeric(track_ancestry)) {
    stop("'track_ancestry' must be either FALSE or 0 (no tracking), or
a non-zero integer number (number of neutral ancestry markers)", call. = FALSE)
  } else
    markers_count <- as.integer(track_ancestry)

  backend_script <- system.file("extdata", "backend.slim", package = "spammr")

  burnin <- round(burnin / model$gen_time)
  sim_length <- round(sim_length / model$gen_time)

  if (burnin < 1 | sim_length < 1)
    stop("Simulation length and burnin must take at least one generation", call. = FALSE)

  base_script <- script(
    path = backend_script,

    model_dir = normalizePath(model_dir),
    output_dir = normalizePath(output_dir),
    burnin = burnin,
    sim_length = sim_length,
    max_distance = max_distance,
    max_spread = max_spread,
    seq_length = seq_length,
    recomb_rate = recomb_rate,
    ancestry_markers = markers_count,
    save_locations = if (save_locations) "T" else "F",
    gen_time = model$gen_time
  )

  # compile all script components, including the backend script, into one file
  script_components <- unlist(lapply(c(base_script, include), readLines))
  complete_script <- file.path(model_dir, "script.slim")
  writeLines(script_components, complete_script)

  if (gui)
    system(sprintf("open -a SLiMgui %s", complete_script))
  else
    system(sprintf("slim %s", complete_script), ignore.stdout = !verbose)
}


#' Substitute variables in a template SLiM script
#'
#' Variables in the template script must conform to the Mustache specification,
#' i.e. {{variable_name}}. For more information see the Mustache specification
#' at: <http://mustache.github.io/>
#'
#' @param path Path to a template SLiM script
#' @param output Where to save the substituted SLiM script (temporary location
#'   by default)
#' @param ... Variable values to be substituted
#'
#' @return Name of the substituted SLiM script
#'
#' @export
script <- function(path, output = NULL, ...) {
  if (!file.exists(path))
    stop(sprintf("File '%s' not found", path), call. = FALSE)

    if (is.null(output)) output <- paste0(tempfile(), ".slim")

  template <- readLines(path)

  # extract variables to be substituted in the template script
  vars <- strsplit(template, split = "\\{\\{") %>%
    unlist %>%
    .[grepl("\\}\\}", .)] %>%
    gsub("\\}\\}.*$", "", .)

  # collect all variables provided by the user and make sure that
  # none are missing
  subst <- list(...)
  if (!all(vars %in% names(subst)))
    stop(sprintf("Values of %s must be specified",
                 paste(vars[!vars %in% names(subst)], collapse = ", ")), call. = FALSE)

  # fill in the variable substitution in the template script and
  # save it to disk
  rendered <- whisker::whisker.render(template, subst)
  writeLines(rendered, output)

  output
}


#' Write model specification tables which will be loaded into SLiM
write_model <- function(model_dir, populations, splits_table, admix_table, maps_table, gen_time) {
  saveRDS(populations, file.path(model_dir, "populations.rds"))

  write.table(
    splits_table[, c("pop_id", "Ne", "parent_id", "tsplit", "tremove")],
    file.path(model_dir, "splits.tsv"),
    sep = "\t", quote = FALSE, row.names = FALSE
  )

  if (!is.null(admix_table)) {
    write.table(
      admix_table[, c("from_id", "to_id", "tstart", "tend", "rate", "overlap")],
      file.path(model_dir, "admixtures.tsv"),
      sep = "\t", quote = FALSE, row.names = FALSE
    )
  }

  write.table(
    maps_table[, c("pop_id", "time", "map_number")],
    file.path(model_dir, "maps.tsv"),
    sep = "\t", quote = FALSE, row.names = FALSE
  )

  # save the population names (SLiM doesn't do data frames with mixed numeric
  # and character types, so this needs to be saved separately)
  writeLines(splits_table$pop, con = file.path(model_dir, "names.txt"))

  write(gen_time, file.path(model_dir, "gen_time.txt"))
}


#' Iterate over population objects and convert he information about
#' population split hierarchy and split times into a data frame
compile_splits <- function(populations) {
  splits_table <- lapply(populations, function(p) {
    parent <- attr(p, "parent")
    if (is.character(parent) && parent == "ancestor") {
      parent_name <- parent
    } else {
      parent_name <- unique(attr(p, "parent")$pop)
    }

    tremove <- unique(attr(p, "remove"))

    data.frame(
      pop = unique(p$pop),
      parent = parent_name,
      tsplit = p$time[1],
      Ne = unique(p$Ne),
      tremove = ifelse(!is.null(tremove), tremove, -1),
      stringsAsFactors = FALSE
    )
  }) %>% do.call(rbind, .)

  # order populations by split time and assign a numeric identifier to each
  splits_table <- splits_table[
    order(splits_table$tsplit, decreasing = TRUE, na.last = FALSE), ]
  splits_table$pop_id <- 1:nrow(splits_table) - 1
  splits_table$parent_id <- lapply(
    splits_table$parent,
    function(i) splits_table[splits_table$pop == i, ]$pop_id
  ) %>% unlist() %>% c(NA, .)

  splits_table
}

#' Process vectorized population boundaries into a table with
#' rasterized map objects
compile_maps <- function(populations, splits_table, resolution) {
  # generate rasterized maps
  maps <- render(populations, resolution)

  # convert list of rasters into data frame, adding the spatial
  # maps themselves as a list column
  maps_table <- lapply(maps, function(m) {
    as.data.frame(m[c("pop", "time")], stringsAsFactors = FALSE)
  }) %>%
    do.call(rbind, .)
  # add column with a numeric population identifier (used later by SLiM)
  maps_table$pop_id <- unlist(lapply(
    maps_table$pop,
    function(i) splits_table[splits_table$pop == i, ]$pop_id
  ))
  maps_table$map <- I(lapply(maps, function(m) m$map))
  maps_table <- maps_table[order(maps_table$time, decreasing = TRUE, na.last = FALSE), ]

  maps_table$time <- round(maps_table$time)

  # number maps sequentially in the order SLiM will be swapping them
  # later (each map number X corresponds to X.png)
  maps_table$map_number <- seq_len(nrow(maps_table))

  maps_table
}


#' Save the rasterized spatial maps as PNG files into a target
#' directory
write_maps <- function(maps_table, output_dir) {
  for (i in seq_len(nrow(maps_table))) {
    map_row <- maps_table[i, ]
    # the first spatial map has necessarily a nonsensical time stamp,
    # so let's take care of that first
    time <- ifelse(map_row$time == Inf, "ancestor", map_row$time)

    ## filename <- sprintf("map_%d_%s_%s.png", i, map_row$pop, time)
    filename <- sprintf("%d.png", i)
    path <- file.path(output_dir, filename)

    save_png(map_row$map[[1]], path)
  }
}


#' Render population boundaries to black-and-white spatial maps
#'
#' @param pops Spatial population objects of the 'spammr_pop' class
#'
#' @import ggplot2
render <- function(pops, resolution) {
  raster_list <- lapply(pops, function(pop) {
    # iterate over temporal maps for the current population
    snapshots <- lapply(unique(pop$time), function(t) {
      snapshot <- pop[pop$time == t, ]
      class(snapshot) <- set_class(snapshot, "pop")

      # render the population if needed
      if (is.null(attr(pop, "intersected")))
        snapshot <- intersect_features(snapshot)

      raster_map <- rasterize(snapshot, resolution)

      # return the rendered spatial map with the population name and the
      # appropriate time stamp (unique-ing because intersecting splits
      # the spatial object into multiple disjoint features)
      list(
        pop = unique(snapshot$pop),
        time = unique(snapshot$time),
        map = raster_map
      )
    })
    snapshots
  })

  # flatten the list of ggplot objects
  rasters <- do.call(c, raster_list)

  rasters
}


#' Rasterize the vector form of a population spatial boundary
#'
#' @param x Object of the 'spammr_pop' class
#' @param resolution How many kilometers per pixel?
rasterize <- function(x, resolution) {
  # add a dummy variable for plotting the bi-color map
  x$fill <- factor(1)

  # create a template object for rasterization (i.e. size of the final raster)
  if (inherits(x, "spammr_world"))
    bbox <- sf::st_bbox(x)
  else
    bbox <- sf::st_bbox(attr(x, "world"))

  template <- stars::st_as_stars(bbox, dx = resolution, dy = resolution)

  # perform the rasterization using the dummy single-value factor column
  raster <- stars::st_rasterize(x["fill"], template)

  raster
}


#' Save the rasterized stars object to a PNG file
#'
#' @param raster Object of a stars type
#' @param path Full path of an output PNG file
save_png <- function(raster, path) {
  tmp_tiff <- paste0(tempfile(), ".tiff")

  # write stars raster as a TIFF format
  stars::write_stars(raster, tmp_tiff)

  # convert the stars TIFF into a PNG (the only format SLiM supports)
  img <- ijtiff::read_tif(tmp_tiff, msg = FALSE)
  unlink(tmp_tiff)

  # subset the multidimensional array only to pixel two-dimensional matrix
  img_matrix <- img[, , 1, 1]

  # binarize the matrix (st_rasterize assigns a different color to each
  # fragmented spatial feature after intersect_features() call)
  img_matrix[img_matrix > 0] <- 1

  png::writePNG(img_matrix, path)
}
