#' Compile the spatial demographic model
#'
#' First, compiles the vectorized population spatial maps into a series of
#' binary raster PNG files, which is the format that SLiM understands and uses
#' it to define population boundaries. Then extracts the demographic model
#' defined by the user (i.e. population divergences and gene flow events) into a
#' series of tables which are later used by the built-in SLiM script to program
#' the timing of simulation events.
#'
#' @param populations Object(s) of the \code{slendr_pop} class
#'   (multiple objects need to be specified in a \code{list})
#' @param generation_time Generation time (in model time units)
#' @param resolution How many distance units per pixel?
#' @param geneflow Geneflow events generated by the \code{geneflow}
#'   function (either a list of data.frame objects in the format
#'   defined by the \code{geneflow} function, or a single data.frame)
#' @param competition_dist,mate_dist Maximum spatial competition and
#'   mating choice distance
#' @param dispersal_dist Standard deviation of the normal distribution
#'   of the parent-offspring distance
#' @param dir Output directory for the model configuration files which
#'   will be loaded by the backend SLiM script
#' @param overwrite Overwrite the contents of the output directory in
#'   case it already exists?
#' @param sim_length Total length of the simulation (required for
#'   forward time models, optional for models specified in backward
#'   time units which by default run to "the present time")
#' @param direction Intended direction of time. Under normal
#'   circumstances this parameter is inferred from the model and does
#'   not need to be set manually.
#'
#' @return Compiled \code{slendr_model} model object
#' @export
compile <- function(populations, dir, generation_time, resolution = NULL,
                    competition_dist = NULL, mate_dist = NULL, dispersal_dist = NULL,
                    geneflow = list(), overwrite = FALSE,
                    sim_length = NULL, direction = NULL) {
  if (inherits(populations, "slendr_pop"))  populations <- list(populations)

  # make sure that all parents are present
  pop_names <- purrr::map_chr(populations, ~ .x$pop[1])
  parent_names <- unique(purrr::map_chr(populations, function(pop) {
    parent <- attr(pop, "parent")
    if (is.character(parent))
      return(pop$pop[1])
    else
      parent$pop[1]
  }))
  if (!all(parent_names %in% pop_names))
    stop("The following parent populations are missing: ", parent_names[!parent_names %in% pop_names], call. = FALSE)

  if (length(populations) != length(unique(sapply(populations, `[[`, "pop"))))
    stop("All populations must have unique names", call. = FALSE)

  # prepare the model output directory
  if (dir.exists(dir)) {
    if (!overwrite)
      stop("Output directory already exists - either delete it or set 'overwrite = TRUE'",
           call. = FALSE)
    else
      unlink(dir, recursive = TRUE, force = TRUE)

  }
  dir.create(dir)

  if (is.data.frame(geneflow)) geneflow <- list(geneflow)

  if (length(unique(sapply(populations, has_map))) != 1)
    stop("Populations must be either all spatial or non-spatial, but not both", call. = FALSE)

  # make sure all populations share the same direction of time
  time_dir <- setdiff(unique(sapply(populations, get_time_direction)), "unknown")

  if (!is.null(direction) & any(direction != time_dir))
    stop("The direction that was explicitly specified contradicts the direction implied by the model", call. = FALSE)

  if (length(time_dir) > 1)
    stop("Inconsistent direction of time among the specified populations", call. = FALSE)

  if (length(time_dir) == 0 | all(time_dir == "forward")) {
    if (!is.null(direction) & all(direction == "backward"))
      time_dir <- "backward"
    else if (is.null(sim_length))
      stop("The specified model implies a forward direction of time. However,
forward models require that the 'sim_length' parameter is explicitly
specified in order to know when to terminate the simulation. If you
intended to run a backward time model instead, you can state this by
setting `direction = 'backward'.`", call. = FALSE)
    else
      time_dir <- "forward"
  }

  if (time_dir == "backward" | is.null(sim_length))
    max_time <- c(sapply(populations, function(pop) {
      sapply(attr(pop, "history"), function(event)
        c(event$time, event$tsplit, event$tstart, event$tend))
      }),
      sapply(geneflow, function(x) max(x$tstart)),
      sapply(geneflow, function(x) max(x$tend))) %>% unlist %>% max(na.rm = TRUE)
  else
    max_time <- sim_length

  map <- get_map(populations[[1]])

  split_table <- compile_splits(populations, generation_time, time_dir, max_time)
  admix_table <- compile_geneflows(geneflow, split_table, generation_time, time_dir, max_time)
  resize_table <- compile_resizes(populations, generation_time, time_dir, max_time, split_table)

  if (inherits(map, "slendr_map")) {
    if (!is.null(competition_dist)) check_resolution(map, competition_dist)
    if (!is.null(mate_dist)) check_resolution(map, mate_dist)
    if (!is.null(dispersal_dist)) check_resolution(map, dispersal_dist)
    check_resolution(map, resolution)

    map_table <- compile_maps(populations, split_table, resolution, generation_time, time_dir, max_time, dir)
    dispersal_table <- compile_dispersals(populations, generation_time, time_dir, max_time, split_table,
                                        resolution, competition_dist, mate_dist, dispersal_dist)

    return_maps <-  map_table[, c("pop", "pop_id", "tmap_orig", "tmap_gen", "path")]
  } else {
    map_table <- return_maps <- dispersal_table <- NULL
  }

  checksums <- write_model(
    dir, populations, admix_table, map_table, split_table, resize_table,
    dispersal_table, generation_time, resolution, max_time, time_dir
  )

  # compile the result
  result <- list(
    path = dir,
    world = map,
    populations = populations,
    splits = split_table,
    geneflow = admix_table,
    maps = return_maps,
    dispersals = dispersal_table,
    generation_time = generation_time,
    resolution = resolution,
    length = if (is.null(sim_length)) max_time else sim_length,
    direction = time_dir,
    checksums = checksums
  )
  class(result) <- set_class(result, "model")

  result
}


calculate_checksums <- function(files) {
  if (!all(file.exists(files)))
    stop("Not all compiled files are present", call. = FALSE)

  data.frame(
    file = basename(files),
    hash = as.vector(tools::md5sum(files))
  )
}


# Make sure the checksums of a given set of files matches the expectation
verify_checksums <- function(files, hashes) {
  failed <- FALSE
  for (i in seq_along(files)) {
    if (tools::md5sum(files[i]) != hashes[i]) {
      message(sprintf("Checksum of '%s' does not match", basename(files[i])))
      failed <- TRUE
    }
  }
  if (failed)
    stop("Checksum test of some slendr configuration files failed -- see above.
Please make sure that the configuration files have not been changed, overwritten, or otherwise tampered with.", call. = FALSE)
}


#' Read a previously serialized model configuration
#'
#' Reads all configuration tables and other model data from a location
#' where it was previously compiled to by the \code{compile} function.
#'
#' @param dir Directory with all required configuration files
#'
#' @export
read <- function(dir) {
  # paths to files which are saved by the compile() function and are necessary
  # for running the backend script using the run() function
  path_populations <- file.path(dir, "populations.rds")
  path_splits <- file.path(dir, "splits.tsv")
  path_geneflow <- file.path(dir, "geneflow.tsv")
  path_maps <- file.path(dir, "maps.tsv")
  path_generation_time <- file.path(dir, "generation_time.txt")
  path_resolution <- file.path(dir, "resolution.txt")
  path_length <- file.path(dir, "length.txt")
  path_direction <- file.path(dir, "direction.txt")

  if (!dir.exists(dir))
    stop(sprintf("Model directory '%s' does not exist", dir), call. = FALSE)

  # verify checksums of serialized model configuration files
  checksums <- read.table(file.path(dir, "checksums.tsv"), header = TRUE)
  verify_checksums(file.path(dir, checksums$file), checksums$hash)

  generation_time <- scan(path_generation_time, what = integer(), quiet = TRUE)
  sim_length <- scan(path_length, what = integer(), quiet = TRUE)

  split_table <- utils::read.table(path_splits, header = TRUE, stringsAsFactors = FALSE)

  admix_table <- NULL
  if (file.exists(path_geneflow)) {
    admix_table <- read.table(path_geneflow, header = TRUE, stringsAsFactors = FALSE)
    admix_table$overlap <- admix_table$overlap == 1
  }

  populations <- readRDS(path_populations)

  if (file.exists(path_maps)) {
    maps <- read.table(path_maps, header = TRUE, stringsAsFactors = FALSE)
    resolution <- scan(path_resolution, what = integer(), quiet = TRUE)
    world <- attr(populations[[1]], "map")
  } else
    maps <- world <- resolution <- NULL

  direction <- scan(path_direction, what = character(), quiet = TRUE)

  result <- list(
    path = dir,
    world = world,
    populations = populations,
    splits = split_table,
    geneflow = admix_table,
    maps = maps,
    generation_time = generation_time,
    resolution = resolution,
    length = sim_length,
    direction = direction,
    checksums = checksums
  )
  class(result) <- set_class(result, "model")
  result
}


#' Run a slendr model as a SLiM script
#'
#' Generates a SLiM script from a built-in slendr template, substituting all
#' required parameters by values specified by the user. The user has an option
#' to either run the script in batch mode, open it in SLiMgui, or simply save
#' the generated SLiM script to a given location for later use.
#'
#' @param model Model object created by the \code{compile} function
#' @param seq_length Total length of the simulated sequence (in base-pairs)
#' @param recomb_rate Recombination rate of the simulated sequence (in
#'   recombinations per basepair per generation)
#' @param output_dir A directory where to put simulation outputs (by default,
#'   all output files are placed in a model directory)
#' @param output_prefix A common prefix of output files (by default, all files
#'   will share a prefix \code{"output"})
#' @param ts_recording Turn on tree sequence recording during SLiM
#'   initialization?
#' @param save_locations Save location of each individual throughout the
#'   simulation?
#' @param track_ancestry Track ancestry proportion dynamics in all populations
#'   throughout the simulations (default FALSE)? If a non-zero integer is
#'   provided, ancestry will be tracked using the number number of neutral
#'   ancestry markers equal to this number.
#' @param samples A data frame of times at which a given number of individuals
#'   should be remembered in the tree-sequence (see \code{sampling} for a
#'   function that can generate the sampling schedule in the correct format). If
#'   missing, only individuals present at the end of the simulation will be
#'   recorded in the tree-sequence output file.
#' @param method How to run the script? ("gui" - open in SLiMgui, "batch" - run
#'   on the command-line, "script" - simply return the script)
#' @param include Vector of paths to custom SLiM scripts which should be
#'   combined with the backend SLiM code
#' @param slim_path Optional way to specify path to an appropriate SLiM binary
#' @param burnin Length of the burnin (in model's time units, i.e. years)
#' @param seed Random seed (if missing, SLiM's own seed will be used)
#' @param verbose Write the SLiM output log to the console (default
#'   \code{FALSE})?
#' @param overwrite Overwrite the contents of the output directory (default
#'   \code{FALSE})?
#'
#' @export
slim <- function(model, seq_length, recomb_rate,
                 output_dir = model$path, output_prefix = "output",
                 save_locations = FALSE, track_ancestry = FALSE,
                 ts_recording = FALSE, sampling = NULL,
                 method, verbose = TRUE, include = NULL, burnin = 0,
                 seed = NULL, slim_path = NULL, overwrite = FALSE) {
  dir <- model$path
  if (!dir.exists(dir))
    stop(sprintf("Model directory '%s' does not exist", dir), call. = FALSE)

  if (!method %in% c("gui", "batch", "script"))
    stop("Only 'gui', 'batch', and 'script' are recognized as values of
the 'method' argument", call. = FALSE)

  if (is.character(slim_path) && !all(file.exists(slim_path)))
    stop("SLiM binary not found at ", slim_path, call. = FALSE)

  if (!is.logical(track_ancestry) & !is.numeric(track_ancestry)) {
    stop("'track_ancestry' must be either FALSE or 0 (no tracking), or
a non-zero integer number (number of neutral ancestry markers)", call. = FALSE)
  } else
    markers_count <- as.integer(track_ancestry)

  if (!file.exists(output_dir)) {
    message("Directory '", output_dir, "' not existent. Creating...")
    dir.create(output_dir)
  }

  if (length(list.files(output_dir, pattern = output_prefix)) && !overwrite)
    stop("Files already present in '", output_dir, "' with the same prefix. ",
         "If you wish to proceed, set `overwrite = TRUE`.", call. = FALSE)

  script_path <- file.path(output_dir, paste0(output_prefix, "_script.slim"))

  backend_script <- system.file("extdata", "backend.slim", package = "slendr")

  if (!is.null(sampling) && !ts_recording)
    stop("Sampling (remembering) of individuals only makes sense when `ts_recording = TRUE`", call. = FALSE)

  sampling_schedule <- process_sampling(sampling, model, script_path, verbose)
  base_script <- script(
    spatial = if (inherits(model$world, "slendr_map")) "T" else "F",
    path = backend_script,
    model_dir = dir,
    output_prefix = path.expand(file.path(output_dir, output_prefix)),
    burnin = round(burnin / model$generation_time),
    length = round(model$length / model$generation_time),
    ts_recording = if (ts_recording) "T" else "F",
    seq_length = seq_length,
    recomb_rate = recomb_rate,
    ancestry_markers = markers_count,
    track_ancestry = if (markers_count > 0) "T" else "F",
    save_locations = if (save_locations) "T" else "F",
    generation_time = model$generation_time,
    direction = model$direction,
    seed = if (is.null(seed)) "getSeed()" else seed,
    sampling = sampling_schedule
  )

  # compile all script components, including the backend script, into one file
  script_components <- unlist(lapply(c(base_script, include), readLines))
  writeLines(script_components, script_path)

  if (method == "script")
    message("Final compiled SLiM script is in ", script_path)
  else {
    if (!is.null(slim_path)) {
      cmd <- slim_path
    } else {
      cmd <- get_binary(method)
    }
    system(sprintf("%s %s", cmd, script_path), ignore.stdout = !verbose)
  }
}


#' Substitute variables in a template SLiM script
#'
#' Variables in the template script must conform to the Mustache
#' specification, i.e. specified as {{variable_name}}. For more
#' information see the Mustache specification at:
#' <http://mustache.github.io/>
#'
#' @param path Path to a template SLiM script
#' @param output Where to save the substituted SLiM script (temporary location
#'   by default)
#' @param ... Variable values to be substituted
#'
#' @return Name of the substituted SLiM script
#'
#' @export
script <- function(path, output = NULL, ...) {
  if (!file.exists(path))
    stop(sprintf("File '%s' not found", path), call. = FALSE)

    if (is.null(output)) output <- paste0(tempfile(), ".slim")

  template <- readLines(path)

  # extract variables to be substituted in the template script
  vars <- strsplit(template, split = "\\{\\{") %>%
    unlist %>%
    .[grepl("\\}\\}", .)] %>%
    gsub("\\}\\}.*$", "", .)

  # collect all variables provided by the user and make sure that
  # none are missing
  subst <- list(...)
  if (!all(vars %in% names(subst))) {
    stop(sprintf("Values of %s must be specified",
                 paste(vars[!vars %in% names(subst)], collapse = ", ")),
         call. = FALSE)
  }

  # fill in the variable substitution in the template script and
  # save it to disk
  rendered <- whisker::whisker.render(template, subst)
  writeLines(rendered, output)

  output
}


# Write a compiled slendr model to disk and return a table of
# checksums
write_model <- function(dir, populations, admix_table, map_table, split_table,
                        resize_table, dispersal_table,
                        generation_time, resolution, length, direction) {
  saved_files <- c()

  # table of split times and initial population sizes
  saved_files["splits"] <- file.path(dir, "splits.tsv")
  utils::write.table(split_table, saved_files[["splits"]],
                     sep = "\t", quote = FALSE, row.names = FALSE)

  # table of geneflow events
  if (!is.null(admix_table)) {
    saved_files["geneflow"] <- file.path(dir, "geneflow.tsv")
    admix_table$overlap <- as.integer(admix_table$overlap)
    utils::write.table(admix_table, saved_files[["geneflow"]],
                       sep = "\t", quote = FALSE, row.names = FALSE)
  }

  if (!is.null(map_table)) {
    # rasterized spatial maps
    for (i in seq_len(nrow(map_table))) {
      saved_files[paste0("map", i)] <- file.path(dir, sprintf("%d.png", i))
      map_row <- map_table[i, ]
      save_png(map_row$map[[1]], saved_files[paste0("map", i)])
    }

    # table of paths to raster files
    saved_files["maps"] <- file.path(dir, "maps.tsv")
    utils::write.table(
      map_table[, c("pop", "pop_id", "tmap_orig", "tmap_gen", "path")],
      saved_files[["maps"]], sep = "\t", quote = FALSE, row.names = FALSE
    )

    saved_files["resolution"] <- file.path(dir, "resolution.txt")
    base::write(resolution, saved_files[["resolution"]])
  }

  # table of interaction and dispersal distances
  if (!is.null(dispersal_table)) {
    saved_files["dispersal"] <- file.path(dir, "dispersals.tsv")
    utils::write.table(dispersal_table, saved_files[["dispersal"]],
                       sep = "\t", quote = FALSE, row.names = FALSE)
  }

  # serialized population objects
  saved_files["populations"] <- file.path(dir, "populations.rds")
  saveRDS(populations, saved_files[["populations"]])

  # table of scheduled resize events
  if (!is.null(resize_table)) {
    saved_files["resizes"] <- file.path(dir, "resizes.tsv")
    utils::write.table(resize_table, saved_files["resizes"], sep = "\t",
                       quote = FALSE, row.names = FALSE)
  }

  saved_files["generation_time"] <- file.path(dir, "generation_time.txt")
  saved_files["length"] <- file.path(dir, "length.txt")
  saved_files["direction"] <- file.path(dir, "direction.txt")
  base::write(as.integer(generation_time), file.path(dir, "generation_time.txt"))
  base::write(as.integer(length), file.path(dir, "length.txt"))
  base::write(direction, file.path(dir, "direction.txt"))

  checksums <- calculate_checksums(saved_files)
  utils::write.table(checksums, file.path(dir, "checksums.tsv"), sep = "\t",
                     quote = FALSE, row.names = FALSE)

  checksums
}


# Iterate over population objects and convert he information about
# population split hierarchy and split times into a data frame
compile_splits <- function(populations, generation_time, direction, max_time) {
  split_table <- lapply(populations, function(p) {
    parent <- attr(p, "parent")
    if (is.character(parent) && parent == "ancestor") {
      parent_name <- parent
    } else {
      parent_name <- unique(attr(p, "parent")$pop)
    }

    tremove <- attr(p, "remove")

    data.frame(
      pop = unique(p$pop),
      parent = parent_name,
      tsplit = attr(p, "history")[[1]]$time,
      N = attr(p, "history")[[1]]$N,
      tremove = ifelse(!is.null(tremove), tremove, -1),
      stringsAsFactors = FALSE
    )
  }) %>% do.call(rbind, .)

  # convert times into a forward direction
  split_table <- convert_time(
    split_table,
    direction = direction,
    columns = c("tsplit", "tremove"),
    max_time = max_time,
    generation_time = generation_time
  )

  # order populations by split time and assign a numeric identifier to each
  split_table <- split_table[
    order(split_table$tsplit_gen, decreasing = FALSE, na.last = FALSE), ]
  split_table$pop_id <- seq_len(nrow(split_table)) - 1
  split_table$parent_id <- lapply(
    split_table$parent,
    function(i) {
      if (i == "ancestor") -1
      else split_table[split_table$pop == i, ]$pop_id
    }
  ) %>% unlist()

  split_table
}

# Process vectorized population boundaries into a table with
# rasterized map objects
compile_maps <- function(populations, split_table, resolution, generation_time,
                         direction, max_time, dir) {
  # generate rasterized maps
  maps <- render(populations, resolution)

  # convert list of rasters into data frame, adding the spatial
  # maps themselves as a list column
  map_table <- lapply(maps, function(m) {
    as.data.frame(m[c("pop", "tmap")], stringsAsFactors = FALSE)
  }) %>%
    do.call(rbind, .)
  # add column with a numeric population identifier (used later by SLiM)
  map_table$pop_id <- unlist(lapply(
    map_table$pop,
    function(i) split_table[split_table$pop == i, ]$pop_id
  ))
  map_table$map <- I(lapply(maps, function(m) m$map))

  map_table <- convert_time(
    map_table,
    direction = direction,
    columns = "tmap",
    max_time = max_time,
    generation_time = generation_time
  )

  # number maps sequentially in the order SLiM will be swapping them
  # later (each map number X corresponds to X.png)
  map_table <- map_table[order(map_table$tmap_gen, na.last = FALSE), ]
  # in some situations, multiple maps are scheduled for a single generation
  # for one population - this removes the duplicates, but ideally this kind
  # of problem should be caught somewhere upstream
  map_table <- map_table[!duplicated(map_table[, c("pop", "tmap_gen")]), ]
  map_table$path <- seq_len(nrow(map_table)) %>%
    paste0(., ".png") %>%
    file.path(dir, .) %>%
    sub("//", "/", .)

  map_table
}


compile_geneflows <- function(geneflow, split_table, generation_time,
                              direction, max_time) {
  if (length(geneflow) == 0)
    return(NULL)

  admix_table <- do.call(rbind, geneflow)
  admix_table <- convert_time(
    admix_table,
    direction = direction,
    columns = c("tstart", "tend"),
    max_time = max_time,
    generation_time = generation_time
  )
  names(admix_table)[1:2] <- c("from", "to")

  # convert population names and their parents' names to SLiM numbers
  admix_table$from_id <- unlist(lapply(
    admix_table$from,
    function(i) split_table[split_table$pop == i, ]$pop_id
  ))
  admix_table$to_id <- unlist(lapply(
    admix_table$to,
    function(i) split_table[split_table$pop == i, ]$pop_id
  ))

  admix_table
}


# Compile table of population resize events
compile_resizes <- function(populations, generation_time, direction,
                            max_time, split_table) {
  resize_events <- lapply(populations, function(p) {
    lapply(attr(p, "history"), function(event) {
      if (event$event == "resize") event
    }) %>% do.call(rbind, .)
  }) %>% do.call(rbind, .)

  if (is.null(resize_events))
    return(NULL)
  else
    resize_events$tend[is.na(resize_events$tend)] <- -1

  resize_table <- convert_time(
    resize_events,
    direction = direction,
    columns = c("tresize", "tend"),
    max_time = max_time,
    generation_time = generation_time
  )

  resize_table$pop_id <- sapply(
    resize_table$pop,
    function(i) split_table[split_table$pop == i, ]$pop_id
  ) %>% as.numeric

  resize_table[, c("pop", "pop_id", "how", "N", "prev_N",
                   "tresize_orig", "tresize_gen", "tend_orig", "tend_gen")]
}

# Compile table of population resize events
compile_dispersals <- function(populations, generation_time, direction,
                               max_time, split_table, resolution,
                               competition_dist, mate_dist, dispersal_dist) {
  dispersal_events <- lapply(populations, function(p) {
    lapply(attr(p, "history"), function(event) {
      if (event$event == "split") {
        event$N <- NULL
        names(event) <- c("pop", "event", "time", "competition_dist", "mate_dist", "dispersal_dist")
        event$event <- "dispersal"
        event
      } else if (event$event == "dispersal") {
        event
      }
    }) %>% do.call(rbind, .)
  }) %>% do.call(rbind, .)

  if (is.null(dispersal_events))
    return(NULL)

  dispersal_events$tdispersal <- dispersal_events$time
  dispersal_events$time <- NULL

  dispersal_table <- convert_time(
    dispersal_events,
    direction = direction,
    columns = "tdispersal",
    max_time = max_time,
    generation_time = generation_time
  )

  dispersal_table$pop_id <- sapply(
    dispersal_table$pop,
    function(i) split_table[split_table$pop == i, ]$pop_id
  ) %>% as.numeric

  # take care of missing interactions and offspring distances
  dispersal_table <- set_distances(dispersal_table, resolution, competition_dist, mate_dist, dispersal_dist)

  dispersal_table <- dispersal_table[order(dispersal_table$tdispersal_gen, na.last = FALSE), ]

  dispersal_table[, c("pop", "pop_id", "tdispersal_gen", "tdispersal_orig",
                      "competition_dist", "mate_dist", "dispersal_dist")]
}


# Render population boundaries to black-and-white spatial maps
render <- function(pops, resolution) {
  raster_list <- lapply(pops, function(pop) {
    # iterate over temporal maps for the current population
    snapshots <- lapply(unique(pop$tmap), function(t) {
      snapshot <- pop[pop$tmap == t, ]
      class(snapshot) <- set_class(snapshot, "pop")

      # render the population if needed
      if (is.null(attr(pop, "intersected")))
        snapshot <- intersect_features(snapshot)

      raster_map <- rasterize(snapshot, resolution)

      # return the rendered spatial map with the population name and the
      # appropriate time stamp (unique-ing because intersecting splits
      # the spatial object into multiple disjoint features)
      list(
        pop = unique(snapshot$pop),
        tmap = unique(snapshot$tmap),
        map = raster_map
      )
    })
    snapshots
  })

  # flatten the list of ggplot objects
  rasters <- do.call(c, raster_list)

  rasters
}


# Rasterize the vector form of a population spatial boundary
rasterize <- function(x, resolution) {
  # add a dummy variable for plotting the bi-color map
  x$fill <- factor(1)

  # create a template object for rasterization (i.e. size of the final raster)
  if (inherits(x, "slendr_map"))
    bbox <- sf::st_bbox(x)
  else
    bbox <- sf::st_bbox(attr(x, "map"))

  template <- stars::st_as_stars(bbox, dx = resolution, dy = resolution)

  # perform the rasterization using the dummy single-value factor column
  raster <- stars::st_rasterize(x["fill"], template)

  if (length(table(raster$ID)) == 1) {
    stop(sprintf("
The generated raster map of %s at time %s is blank.
This would cause SLiM to crash as it would not be able to place
any individuals on the map. Please check the spatial boundary for
this population at this time point.", x$pop, x$time), call. = FALSE)
  }

  raster
}


# Save the rasterized stars object to a PNG file
save_png <- function(raster, path) {
  tmp_tiff <- paste0(tempfile(), ".tiff")

  # write stars raster as a TIFF format
  stars::write_stars(raster, tmp_tiff)

  # convert the stars TIFF into a PNG (the only format SLiM supports)
  img <- ijtiff::read_tif(tmp_tiff, msg = FALSE)
  unlink(tmp_tiff)

  # subset the multidimensional array only to pixel two-dimensional matrix
  img_matrix <- img[, , 1, 1]

  # binarize the matrix (st_rasterize assigns a different color to each
  # fragmented spatial feature after intersect_features() call)
  img_matrix[img_matrix > 0] <- 1

  png::writePNG(img_matrix, path)
}


# Convert time from backward to forward direction (if necessary) and to generations
convert_time <- function(df, direction, columns, max_time, generation_time) {
  for (column in columns) {
    times <- df[[column]]

    # if necessary, convert to forward direction
    if (direction == "backward")
      times[times != -1] <- max_time - times[times != -1] + generation_time

    # convert to generations
    times[times != -1] <- as.integer(round(times[times != -1] / generation_time))

    df[[paste0(column, "_gen")]] <- times
    df[[paste0(column, "_orig")]] <- df[[column]]
    df[[column]] <- NULL
  }
  df
}
