#' Iterate over population objects and convert he information about
#' population split hierarchy and split times into a data frame
compile_splits <- function(populations) {
  splits_table <- lapply(populations, function(p) {
    parent <- attr(p, "parent")
    if (is.character(parent) && parent == "ancestor") {
      parent_name <- parent
    } else {
      parent_name <- unique(attr(p, "parent")$pop)
    }

    tremove <- unique(attr(p, "remove"))

    data.frame(
      pop = unique(p$pop),
      parent = parent_name,
      tsplit = p$time[1],
      Ne = unique(p$Ne),
      tremove = ifelse(!is.null(tremove), tremove, -1),
      stringsAsFactors = FALSE
    )
  }) %>% do.call(rbind, .)

  # order populations by split time and assign a numeric identifier to each
  splits_table <- splits_table[
    order(splits_table$tsplit, decreasing = TRUE, na.last = FALSE), ]
  splits_table$pop_id <- 1:nrow(splits_table) - 1
  splits_table$parent_id <- lapply(
    splits_table$parent,
    function(i) splits_table[splits_table$pop == i, ]$pop_id
  ) %>% unlist() %>% c(NA, .)

  splits_table
}

#' Process vectorized population boundaries into a table with
#' rasterized map objects
compile_maps <- function(populations, splits_table, resolution) {
  # generate rasterized maps
  maps <- render(populations, resolution)

  # convert list of rasters into data frame, adding the spatial
  # maps themselves as a list column
  maps_table <- lapply(maps, function(m) {
    as.data.frame(m[c("pop", "time")], stringsAsFactors = FALSE)
  }) %>%
    do.call(rbind, .)
  maps_table$time <- round(maps_table$time)
  # add column with a numeric population identifier (used later by SLiM)
  maps_table$pop_id <- unlist(lapply(
    maps_table$pop,
    function(i) splits_table[splits_table$pop == i, ]$pop_id
  ))
  maps_table$map <- I(lapply(maps, function(m) m$map))
  maps_table <- maps_table[order(maps_table$time, decreasing = TRUE, na.last = FALSE), ]

  # number maps sequentially in the order SLiM will be swapping them
  # later (each map number X corresponds to X.png)
  maps_table$map_number <- seq_len(nrow(maps_table))

  maps_table
}


#' Save the rasterized spatial maps as PNG files into a target
#' directory
write_maps <- function(maps_table, output_dir) {
  for (i in seq_len(nrow(maps_table))) {
    map_row <- maps_table[i, ]
    # the first spatial map has necessarily a nonsensical time stamp,
    # so let's take care of that first
    time <- ifelse(map_row$time == Inf, "ancestor", map_row$time)

    ## filename <- sprintf("map_%d_%s_%s.png", i, map_row$pop, time)
    filename <- sprintf("%d.png", i)
    path <- file.path(output_dir, filename)

    save_png(map_row$map[[1]], path)
  }
}

#' Compile the spatial maps and split/admixture tables
#'
#' @param populations Population map objects of the \code{spammr_pop} class (a
#'   list of such object or a single element)
#' @param output_dir Directory to which to save the entire model
#' @param admixtures Admixture events generated by the \code{admixture} function
#'   (either a list of data.frame objects - one per admixture event, or a single
#'   data.frame for one admixture event)
#' @param resolution How many kilometers per pixel?
#' @param overwrite Overwrite the contents of the output directory (in case it
#'   already exists)?
#'
#' @export
compile <- function(populations, output_dir, admixtures = NULL, resolution, overwrite = FALSE) {
  if (!inherits(populations, "list"))
    populations <- list(populations)

  if (!is.null(admixtures) & is.data.frame(admixtures))
    admixtures <- list(admixtures)

  # summarize the full population map data into a tabular form
  # (including rasterized map objects)
  splits_table <- compile_splits(populations)
  maps_table <- compile_maps(populations, splits_table, resolution * 1000)

  # prepare the model output directory
  if (dir.exists(output_dir)) {
    if (!overwrite)
      stop("Output directory already exists - either delete it or set 'overwrite = TRUE'",
           call. = FALSE)
    else
      unlink(output_dir, recursive = TRUE, force = TRUE)

  }
  dir.create(output_dir)

  # save the rasterized PNG files
  write_maps(maps_table, output_dir)

  # take care of Inf/NA values for downstream SLiM processing
  splits_table$tsplit <- ifelse(splits_table$tsplit == Inf, -1, splits_table$tsplit)
  maps_table$time <- ifelse(maps_table$time == Inf, -1, maps_table$time)
  splits_table$parent_id <- ifelse(is.na(splits_table$parent_id), -1, splits_table$parent_id)

  # save the table with spatial map paths
  write.table(
    maps_table[, c("pop_id", "time", "map_number")],
    file.path(output_dir, "maps.tsv"),
    sep = "\t", quote = FALSE, row.names = FALSE
  )

  # save the population splits table
  write.table(
    splits_table[, c("pop_id", "Ne", "parent_id", "tsplit", "tremove")],
    file.path(output_dir, "splits.tsv"),
    sep = "\t", quote = FALSE, row.names = FALSE
  )

  # save the population names (SLiM doesn't do data frames with mixed numeric
  # and character types, so this needs to be saved separately)
  writeLines(splits_table$pop, con = file.path(output_dir, "names.txt"))

  # save the admixture table
  if (is.null(admixtures))
    admix_table <- data.frame(from = NULL, to = NULL, tstart = NULL, tend = NULL, rate = NULL, overlap = NULL, stringsAsFactors = FALSE)
  else {
    admix_table <- do.call(rbind, admixtures)
    admix_table$rate <- as.integer(admix_table$rate * 100)
    admix_table$from <- unlist(lapply(
      admix_table$from_name,
      function(i) splits_table[splits_table$pop == i, ]$pop_id
    ))
    admix_table$to <- unlist(lapply(
      admix_table$to_name,
      function(i) splits_table[splits_table$pop == i, ]$pop_id
    ))
    admix_table <- admix_table[, c("from", "to", "tstart", "tend", "rate", "overlap")]
  }
  write.table(
    admix_table,
    file.path(output_dir, "admixtures.tsv"),
    sep = "\t", quote = FALSE, row.names = FALSE
  )
}


#' Render population boundaries to black-and-white spatial maps
#'
#' @param pops Spatial population objects of the 'spammr_pop' class
#'
#' @import ggplot2
render <- function(pops, resolution) {
  raster_list <- lapply(pops, function(pop) {
    # iterate over temporal maps for the current population
    snapshots <- lapply(unique(pop$time), function(t) {
      snapshot <- pop[pop$time == t, ]
      class(snapshot) <- set_class(snapshot, "pop")

      # render the population if needed
      if (is.null(attr(pop, "intersected")))
        snapshot <- intersect_features(snapshot)

      raster_map <- rasterize(snapshot, resolution)

      # return the rendered spatial map with the population name and the
      # appropriate time stamp (unique-ing because intersecting splits
      # the spatial object into multiple disjoint features)
      list(
        pop = unique(snapshot$pop),
        time = unique(snapshot$time),
        map = raster_map
      )
    })
    snapshots
  })

  # flatten the list of ggplot objects
  rasters <- do.call(c, raster_list)

  rasters
}


#' Calculate pixel location of a spatial point (sf object) on a given
#' raster
#'
#' @param x Point object of the sf type (see `get_centroid`)
#' @param raster Raster object of the class 'stars'
#' @param world Underlying world object
#'
#' @return Two-dimensional numeric vector of pixel coordinates
raster_center <- function(pop, raster) {
  # get the dimension of the whole world raster bitmap
  raster_width <- dim(raster)["x"]
  raster_height <- dim(raster)["y"]

  # get the dimension of the world in the real CRS units
  bbox <- sf::st_bbox(attr(pop, "world"))
  world_width <- bbox["xmax"] - bbox["xmin"]
  world_height <- bbox["ymax"] - bbox["ymin"]

  center <- sf::st_coordinates(sf::st_centroid(pop))
  xpoint <- as.integer(center[1] - bbox["xmin"])
  ypoint <- as.integer(center[2] - bbox["ymin"])

  coords <- as.integer(c(xpoint / world_width * raster_width,
                         ypoint / world_height * raster_height))

  coords
}


#' Rasterize the vector form of a population spatial boundary
#'
#' @param x Object of the 'spammr_pop' class
#' @param resolution How many kilometers per pixel?
rasterize <- function(x, resolution) {
  # add a dummy variable for plotting the bi-color map
  x$fill <- factor(1)

  # create a template object for rasterization (i.e. size of the final raster)
  if (inherits(x, "spammr_world"))
    bbox <- sf::st_bbox(x)
  else
    bbox <- sf::st_bbox(attr(x, "world"))

  template <- stars::st_as_stars(bbox, dx = resolution, dy = resolution)

  # perform the rasterization using the dummy single-value factor column
  raster <- stars::st_rasterize(x["fill"], template)

  raster
}


#' Save the rasterized stars object to a PNG file
#'
#' @param raster Object of a stars type
#' @param path Full path of an output PNG file
save_png <- function(raster, path) {
  tmp_tiff <- paste0(tempfile(), ".tiff")

  # write stars raster as a TIFF format
  stars::write_stars(raster, tmp_tiff)

  # convert the stars TIFF into a PNG (the only format SLiM supports)
  img <- ijtiff::read_tif(tmp_tiff, msg = FALSE)
  unlink(tmp_tiff)

  # subset the multidimensional array only to pixel two-dimensional matrix
  img_matrix <- img[, , 1, 1]

  # binarize the matrix (st_rasterize assigns a different color to each
  # fragmented spatial feature after intersect_features() call)
  img_matrix[img_matrix > 0] <- 1

  png::writePNG(img_matrix, path)
}


#' Open the compiled spatial model in SLiM
#'
#' When run, the compiled SLiM script will save the location of each
#' individual that ever lived, and will also record a sample of
#' ancient individuals from each population in a tree sequence data
#' structure which will be saved for all "present-day" individuals at
#' the end of the simulation. This obviously does not make sense for
#' all potential uses and the exact specification of output formats
#' will be changed at some point soon.
#'
#' @param model_dir Directory where \code{compile} saved all spatial
#'   maps and other model configuration files
#' @param gen_time Generation time (in model's time units, i.e. years)
#' @param burnin Length of the burnin (in model's time units, i.e. years)
#' @param sim_length Total length of the simulation (in model's time units, i.e.
#'   years)
#' @param seq_length Total length of the simulated sequence in base-pairs
#' @param recomb_rate Recombination rate of the simulated sequence
#' @param interaction,max_interaction Standard deviation of the spatial interaction/mate choice
#'   Gaussian distance kernel and the maximum interaction distance
#' @param spread Sigma parameter of the offspring spread normal distribution
#' @param track_ancestry Track ancestry proportion dynamics in all populations
#'   throughout the simulations (default FALSE)? If a non-zero integer is
#'   provided, ancestry will be tracked using the number number of neutral
#'   ancestry markers equal to this number.
#' @param output_prefix Directory and shared prefix of all output files (all
#'   output files will be placed into the model directory by default)
#'
#' @export
run <- function(model_dir, gen_time, burnin, sim_length, seq_length, recomb_rate,
                interaction, max_interaction = interaction * 3, spread, track_ancestry = FALSE,
                output_prefix = file.path(normalizePath(model_dir), "output_"),
                ..., include = NULL) {
  if (!dir.exists(model_dir))
    stop(sprintf("Directory '%s' does not exist", model_dir), call. = FALSE)

  if (!all(file.exists(file.path(model_dir, c("admixtures.tsv", "splits.tsv", "maps.tsv")))))
    stop(sprintf("Directory '%s' does not contain spammr configuration files", model_dir), call. = FALSE)

  if (!length(list.files(model_dir, pattern = "*.png") == 0))
    stop(sprintf("Directory '%s' does not contain any spammr spatial raster maps", model_dir), call. = FALSE)

  if (!is.logical(track_ancestry) & !is.numeric(track_ancestry))
    stop("'track_ancestry' must be either FALSE or 0 (no tracking), or
a non-zero integer number (number of neutral ancestry markers)", call. = FALSE)
  else
    markers_count <- as.integer(track_ancestry)

  # compile the SLiM backend script
  template <- readLines(system.file("extdata", "backend.slim", package = "spammr"))

  subst <- list(
    model_dir = normalizePath(model_dir),
    output_prefix = output_prefix,
    gen_time = gen_time,
    burnin = burnin,
    sim_length = sim_length,
    interaction = interaction,
    max_interaction = max_interaction,
    spread = spread,
    seq_length = seq_length,
    recomb_rate = recomb_rate,
    ancestry_markers = markers_count
  )
  if (length(list(...)) > 0 ) subst <- c(subst, list(...))
  print(subst)
  if (!is.null(include)) {
    template <- c(template, sapply(include, readLines))
  }
  rendered <- whisker::whisker.render(template, subst)

  script <- file.path(subst[["model_dir"]], "script.slim")
  writeLines(rendered, script)

  system(sprintf("open -a SLiMgui %s", script))
}
