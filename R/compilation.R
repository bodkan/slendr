#' Compile the spatial demographic model
#'
#' First, compiles the vectorized population spatial maps into a
#' series of binary raster PNG files, which is the format that SLiM
#' understands and uses it to define population boundaries. Then
#' extracts the demographic model defined by the user (i.e. population
#' divergences and gene flow events) into a series of tables which are
#' later used by the built-in SLiM script to program the timing of
#' simulation events.
#'
#' @param populations Object(s) of the \code{spannr_pop} class
#'   (multiple objects need to be specified in a \code{list})
#' @param model_dir Output directory for the model configuration files
#'   which will be loaded by the backend SLiM script
#' @param generation_time Generation time (in model time units)
#' @param resolution How many distance units per pixel?
#' @param admixtures Admixture events generated by the
#'   \code{admixture} function (either a list of data.frame objects in
#'   the format defined by the \code{admixture} function, or a single
#'   data.frame)
#' @param overwrite Overwrite the contents of the output directory in
#'   case it already exists?
#'
#' @export
compile <- function(populations, model_dir, generation_time,
                    resolution, admixtures = NULL, overwrite = FALSE) {
  if (!inherits(populations, "list"))  populations <- list(populations)

  map <- attr(populations[[1]], "map")

  xrange <- sf::st_bbox(map)[c("xmin", "xmax")]
  yrange <- sf::st_bbox(map)[c("ymin", "ymax")]
  if (diff(xrange) < resolution | diff(yrange) < resolution)
    stop("Pixel size larger than the overall world size", call. = FALSE)

  # save split and admixture tables which will be returned in the model object
  # in separate objects (tables serialized for SLiM will have to be stripped
  # first)
  return_splits <- compile_splits(populations)
  if (!is.null(admixtures)) {
    # lets take care of the fact that most users will input single admixture
    # events as just a single data frame (can't blame them)
    if (is.data.frame(admixtures))
      admixtures <- list(admixtures)
    return_admixtures <- do.call(rbind, admixtures)
    names(return_admixtures)[1:2] <- c("from", "to")
  } else
    return_admixtures <- NULL

  # convert times into generations (only in the table of splits which will be
  # saved for later SLiM runs)
  splits_table <- return_splits
  splits_table$tsplit <- splits_table$tsplit / generation_time
  splits_table$tremove[splits_table$tremove != -1] <- splits_table$tremove[splits_table$tremove != -1] / generation_time

  # compile the spatial maps
  maps_table <- compile_maps(populations, splits_table, resolution)

  # prepare the model output directory
  if (dir.exists(model_dir)) {
    if (!overwrite)
      stop("Output directory already exists - either delete it or set 'overwrite = TRUE'",
           call. = FALSE)
    else
      unlink(model_dir, recursive = TRUE, force = TRUE)

  }
  dir.create(model_dir)

  # save the rasterized maps as PNG files
  write_maps(maps_table, model_dir)

  # keep the original spatial map table for returning as a model object later
  return_maps <- maps_table
  return_maps$path <- return_maps$map_number %>%
    paste0(., ".png") %>% file.path(model_dir, .) %>% gsub("//", "/", .)

  # take care of Inf/NA values for downstream SLiM runs (-1 will be interpreted
  # as a special value, such as for the "split time" of ancestral populations,
  # or their "parental" populations) - this is very ugly, but we're limited by
  # what SLiM's programming language can do...
  splits_table$tsplit <- ifelse(splits_table$tsplit == Inf, -1, splits_table$tsplit)
  maps_table$time <- ifelse(maps_table$time == Inf, -1, maps_table$time)
  maps_table$time[maps_table$time != -1] <- maps_table$time[maps_table$time != -1] / generation_time
  splits_table$parent_id <- ifelse(is.na(splits_table$parent_id), -1, splits_table$parent_id)

  # reformat the admixture table
  if (!is.null(return_admixtures)) {
    # make a copy of the admixture table for processing and saving
    admix_table <- return_admixtures

    admix_table$tstart <- admix_table$tstart / generation_time
    admix_table$tend <- admix_table$tend / generation_time
    admix_table$rate <- as.integer(admix_table$rate * 100)
    # convert population names and their parents' names to SLiM numbers
    admix_table$from_id <- unlist(lapply(
      admix_table$from,
      function(i) splits_table[splits_table$pop == i, ]$pop_id
    ))
    admix_table$to_id <- unlist(lapply(
      admix_table$to,
      function(i) splits_table[splits_table$pop == i, ]$pop_id
    ))
    admix_table$overlap <- as.integer(admix_table$overlap)
  } else
    admix_table <- NULL

  write_model(model_dir, populations, splits_table, admix_table, maps_table, generation_time, resolution)

  result <- list(
    config = list(
      directory = model_dir,
      splits = file.path(model_dir, "splits.tsv"),
      maps = file.path(model_dir, "maps.tsv"),
      admixtures = if (is.null(admixtures)) NULL else file.path(model_dir, "admixtures.tsv")
    ),
    map = map,
    populations = populations,
    splits = return_splits[, c("pop", "parent", "tsplit", "N", "tremove")],
    admixtures = return_admixtures,
    maps = return_maps[, c("pop", "time", "path")],
    generation_time = generation_time,
    resolution = resolution
  )

  class(result) <- set_class(result, "model")

  result
}


#' Read a previously serialized model configuration
#'
#' Reads all configuration tables and other model data from a location
#' where it was previously compiled to by the \code{compile} function.
#'
#' @param model_dir Directory with all required configuration files
#'
#' @export
read <- function(model_dir) {
  # paths to files which are saved by the compile() function and are necessary
  # for running the backend script using the run() function
  path_populations <- file.path(model_dir, "populations.rds")
  path_splits <- file.path(model_dir, "splits.tsv")
  path_admixtures <- file.path(model_dir, "admixtures.tsv")
  path_maps <- file.path(model_dir, "maps.tsv")
  path_names <- file.path(model_dir, "names.txt")
  path_generation_time <- file.path(model_dir, "generation_time.txt")
  path_resolution <- file.path(model_dir, "resolution.txt")

  if (!dir.exists(model_dir))
    stop(sprintf("Model directory '%s' does not exist", model_dir), call. = FALSE)

  if (!all(file.exists(c(path_populations, path_splits, path_maps, path_names))))
    stop(sprintf("Directory '%s' does not contain all spannr configuration files.
Please make sure that populations.rds, {splits,admixtures,maps}.tsv, names.txt and generation_time.txt are all present", model_dir), call. = FALSE)

  pop_names <- scan(path_names, what = "character", quiet = TRUE)
  generation_time <- scan(path_generation_time, what = integer(), quiet = TRUE)
  resolution <- scan(path_resolution, what = integer(), quiet = TRUE)

  # load the split table from disk and re-format it to the original format
  splits <- read.table(path_splits, header = TRUE, stringsAsFactors = FALSE)
  # add population labels and parent population labels (these are striped away
  # during model saving because SLiM can't handle mixed types in matrices)
  splits$pop <- pop_names[splits$pop_id + 1]
  ancestral <- splits$parent == -1
  splits$parent[ancestral] <- "ancestor"
  if (any(!ancestral))
    splits$parent[!ancestral] <- pop_names[splits$parent_id[!ancestral] + 1]

  # load and reformat the admixtures table (if present - if absent, no admixture
  # was specified)
  admixtures <- NULL
  if (file.exists(path_admixtures)) {
    admixtures <- read.table(path_admixtures, header = TRUE, stringsAsFactors = FALSE)
    admixtures$from <- pop_names[admixtures$from + 1]
    admixtures$to <- pop_names[admixtures$to + 1]
    admixtures$rate <- admixtures$rate / 100
    admixtures$tstart <- round(admixtures$tstart * generation_time)
    admixtures$tend <- round(admixtures$tend * generation_time)
    admixtures$overlap <- admixtures$overlap == 1
    admixtures <- admixtures[, c("from", "to", "tstart", "tend", "rate", "overlap")]
  }

  # load and reformat the maps table
  maps <- read.table(path_maps, header = TRUE, stringsAsFactors = FALSE)
  # reconstruct the paths to each raster map (again, stripped away because SLiM
  # can't handle strings and numbers in a single matrix/data frame)
  maps$path <- file.path(model_dir, paste0(maps$map_number, ".png")) %>% gsub("//", "/", .)
  if (!all(file.exists(maps$path)))
    stop(sprintf("Directory '%s' does not contain all maps required by the model configuration (%s)", model_dir, maps$map), call. = FALSE)
  # recreate the user-specified population labels
  maps$pop <- pop_names[maps$pop_id + 1]

  # convert times to their original value before conversion for SLiM (this
  # handling of -1 and Inf special cases is absolutely awful, but we are
  # currently forced to do this because we need to interface with the rather
  # limited SLiM builtin language)
  splits$tsplit[splits$tsplit == -1] <- Inf
  maps$time[maps$time == -1] <- Inf
  # convert generations back to years
  splits$tsplit <- round(splits$tsplit * generation_time)
  splits$tremove[splits$tremove != -1] <- round(splits$tremove[splits$tremove != -1] * generation_time)
  maps$time <- round(maps$time * generation_time)

  populations <- readRDS(path_populations)

  result <- list(
    config = list(
      directory = model_dir,
      splits = path_splits,
      maps = path_maps,
      admixtures = if (is.null(admixtures)) NULL else file.path(model_dir, "admixtures.tsv")
    ),
    map = attr(populations[[1]], "map"),
    populations = populations,
    splits = splits[, c("pop", "parent", "tsplit", "N", "tremove")],
    admixtures = admixtures,
    maps = maps[, c("pop", "time", "path")],
    generation_time = generation_time,
    resolution = resolution
  )

  class(result) <- set_class(result, "model")

  result
}


#' Run a spannr model as a SLiM script
#'
#' Generates a SLiM script from a built-in spannr template,
#' substituting all required parameters by values specified by the
#' user. The user has an option to either run the script in batch
#' mode, open it in SLiMgui, or simply save the generated SLiM script
#' to a given location for later use.
#' 
#' @param model Model object created by the \code{compile} function
#' @param sim_length Total length of the simulation (in model time
#'   units, i.e.  years)
#' @param seq_length Total length of the simulated sequence (in
#'   base-pairs)
#' @param recomb_rate Recombination rate of the simulated sequence (in
#'   recombinations per basepair per generation)
#' @param max_interaction Maximum spatial interaction and mating
#'   choice distance
#' @param spread Standard deviation of the normal distribution for a
#'   distance from of an offspring from one of its parents (randomly
#'   determined by SLiM)
#' @param keep_pedigrees Turn on \code{keepPedigrees} during SLiM
#'   initialization?
#' @param ts_recording Turn on tree sequence recording during SLiM
#'   initialization?
#' @param save_locations Save location of each individual throughout
#'   the simulation?
#' @param track_ancestry Track ancestry proportion dynamics in all
#'   populations throughout the simulations (default FALSE)? If a
#'   non-zero integer is provided, ancestry will be tracked using the
#'   number number of neutral ancestry markers equal to this number.
#' @param how How to run the script? ("gui" - open in SLiMgui, "batch"
#'   - run on the command-line, "dry-run" - simply return the script)
#' @param include Vector of paths to custom SLiM scripts which should
#'   be combined with the backend SLiM code
#' @param generation_time Generation time (in model's time units,
#'   i.e. years)
#' @param burnin Length of the burnin (in model's time units,
#'   i.e. years)
#' @param script_path Name of the compiled output script
#' @param output_prefix Common prefix (including path) for all output
#'   files
#'
#' @export
run <- function(model, sim_length, seq_length, recomb_rate,
                max_interaction, spread,
                save_locations = FALSE, track_ancestry = FALSE,
                keep_pedigrees = FALSE, ts_recording = FALSE,
                how = "gui", verbose = FALSE, include = NULL, burnin = NULL,
                script_path = file.path(model$config$directory, "script.slim"),
                output_prefix = file.path(model$config$directory, "output")) {
  model_dir <- model$config$directory
  if (!dir.exists(model_dir))
    stop(sprintf("Model directory '%s' does not exist", model_dir), call. = FALSE)

  if (!all(file.exists(file.path(model_dir, c("splits.tsv", "maps.tsv")))))
    stop(sprintf("Directory '%s' does not contain spannr configuration files", model_dir), call. = FALSE)

  if (!length(list.files(model_dir, pattern = "*.png") == 0))
    stop(sprintf("Directory '%s' does not contain any spannr spatial raster maps", model_dir), call. = FALSE)

  if (!is.logical(track_ancestry) & !is.numeric(track_ancestry)) {
    stop("'track_ancestry' must be either FALSE or 0 (no tracking), or
a non-zero integer number (number of neutral ancestry markers)", call. = FALSE)
  } else
    markers_count <- as.integer(track_ancestry)

  backend_script <- system.file("extdata", "backend.slim", package = "spannr")

  burnin <- if (!is.null(burnin)) round(burnin / model$generation_time) else 1
  sim_length <- round(sim_length / model$generation_time)

  if (burnin < 1 | sim_length < 1)
    stop("Simulation length and burnin must take at least one generation", call. = FALSE)

  base_script <- script(
    path = backend_script,

    model_dir = model_dir,
    output_prefix = output_prefix,
    burnin = burnin,
    sim_length = sim_length,
    keep_pedigrees = if (keep_pedigrees) "T" else "F",
    ts_recording = if (ts_recording) "T" else "F",
    max_interaction = max_interaction / model$resolution,
    spread = spread / model$resolution,
    seq_length = seq_length,
    recomb_rate = recomb_rate,
    ancestry_markers = markers_count,
    save_locations = if (save_locations) "T" else "F",
    generation_time = model$generation_time
  )

  # compile all script components, including the backend script, into one file
  script_components <- unlist(lapply(c(base_script, include), readLines))
  writeLines(script_components, script_path)

  if (how == "gui")
    system(sprintf("open -a SLiMgui %s", script_path))
  else if (how == "batch")
    system(sprintf("slim %s", script_path), ignore.stdout = !verbose)
  else if (how == "dry-run")
    message("Final compiled SLiM script is in ", script_path)
  else
    stop("Only 'gui', 'batch', and 'dry-run' are recognized as values of the 'how' argument", call. = FALSE)
}


#' Substitute variables in a template SLiM script
#'
#' Variables in the template script must conform to the Mustache
#' specification, i.e. specified as {{variable_name}}. For more
#' information see the Mustache specification at:
#' <http://mustache.github.io/>
#'
#' @param path Path to a template SLiM script
#' @param output Where to save the substituted SLiM script (temporary location
#'   by default)
#' @param ... Variable values to be substituted
#'
#' @return Name of the substituted SLiM script
#'
#' @export
script <- function(path, output = NULL, ...) {
  if (!file.exists(path))
    stop(sprintf("File '%s' not found", path), call. = FALSE)

    if (is.null(output)) output <- paste0(tempfile(), ".slim")

  template <- readLines(path)

  # extract variables to be substituted in the template script
  vars <- strsplit(template, split = "\\{\\{") %>%
    unlist %>%
    .[grepl("\\}\\}", .)] %>%
    gsub("\\}\\}.*$", "", .)

  # collect all variables provided by the user and make sure that
  # none are missing
  subst <- list(...)
  if (!all(vars %in% names(subst)))
    stop(sprintf("Values of %s must be specified",
                 paste(vars[!vars %in% names(subst)], collapse = ", ")), call. = FALSE)

  # fill in the variable substitution in the template script and
  # save it to disk
  rendered <- whisker::whisker.render(template, subst)
  writeLines(rendered, output)

  output
}


#' Write model specification tables which will be loaded into SLiM
write_model <- function(model_dir, populations, splits_table, admix_table, maps_table, generation_time, resolution) {
  saveRDS(populations, file.path(model_dir, "populations.rds"))

  write.table(
    splits_table[, c("pop_id", "N", "parent_id", "tsplit", "tremove")],
    file.path(model_dir, "splits.tsv"),
    sep = "\t", quote = FALSE, row.names = FALSE
  )

  if (!is.null(admix_table)) {
    write.table(
      admix_table[, c("from_id", "to_id", "tstart", "tend", "rate", "overlap")],
      file.path(model_dir, "admixtures.tsv"),
      sep = "\t", quote = FALSE, row.names = FALSE
    )
  }

  write.table(
    maps_table[, c("pop_id", "time", "map_number")],
    file.path(model_dir, "maps.tsv"),
    sep = "\t", quote = FALSE, row.names = FALSE
  )

  # save the population names (SLiM doesn't do data frames with mixed numeric
  # and character types, so this needs to be saved separately)
  writeLines(splits_table$pop, con = file.path(model_dir, "names.txt"))

  write(generation_time, file.path(model_dir, "generation_time.txt"))
  write(resolution, file.path(model_dir, "resolution.txt"))
}


#' Iterate over population objects and convert he information about
#' population split hierarchy and split times into a data frame
compile_splits <- function(populations) {
  splits_table <- lapply(populations, function(p) {
    parent <- attr(p, "parent")
    if (is.character(parent) && parent == "ancestor") {
      parent_name <- parent
    } else {
      parent_name <- unique(attr(p, "parent")$pop)
    }

    tremove <- unique(attr(p, "remove"))

    data.frame(
      pop = unique(p$pop),
      parent = parent_name,
      tsplit = p$time[1],
      N = unique(p$N),
      tremove = ifelse(!is.null(tremove), tremove, -1),
      stringsAsFactors = FALSE
    )
  }) %>% do.call(rbind, .)

  # order populations by split time and assign a numeric identifier to each
  splits_table <- splits_table[
    order(splits_table$tsplit, decreasing = TRUE, na.last = FALSE), ]
  splits_table$pop_id <- 1:nrow(splits_table) - 1
  splits_table$parent_id <- lapply(
    splits_table$parent,
    function(i) splits_table[splits_table$pop == i, ]$pop_id
  ) %>% unlist() %>% c(NA, .)

  splits_table
}

#' Process vectorized population boundaries into a table with
#' rasterized map objects
compile_maps <- function(populations, splits_table, resolution) {
  # generate rasterized maps
  maps <- render(populations, resolution)

  # convert list of rasters into data frame, adding the spatial
  # maps themselves as a list column
  maps_table <- lapply(maps, function(m) {
    as.data.frame(m[c("pop", "time")], stringsAsFactors = FALSE)
  }) %>%
    do.call(rbind, .)
  # add column with a numeric population identifier (used later by SLiM)
  maps_table$pop_id <- unlist(lapply(
    maps_table$pop,
    function(i) splits_table[splits_table$pop == i, ]$pop_id
  ))
  maps_table$map <- I(lapply(maps, function(m) m$map))
  maps_table <- maps_table[order(maps_table$time, decreasing = TRUE, na.last = FALSE), ]

  maps_table$time <- round(maps_table$time)

  # number maps sequentially in the order SLiM will be swapping them
  # later (each map number X corresponds to X.png)
  maps_table$map_number <- seq_len(nrow(maps_table))

  maps_table
}


#' Save the rasterized spatial maps as PNG files into a target
#' directory
write_maps <- function(maps_table, output_dir) {
  for (i in seq_len(nrow(maps_table))) {
    map_row <- maps_table[i, ]
    # the first spatial map has necessarily a nonsensical time stamp,
    # so let's take care of that first
    time <- ifelse(map_row$time == Inf, "ancestor", map_row$time)

    ## filename <- sprintf("map_%d_%s_%s.png", i, map_row$pop, time)
    filename <- sprintf("%d.png", i)
    path <- file.path(output_dir, filename)

    save_png(map_row$map[[1]], path)
  }
}


#' Render population boundaries to black-and-white spatial maps
render <- function(pops, resolution) {
  raster_list <- lapply(pops, function(pop) {
    # iterate over temporal maps for the current population
    snapshots <- lapply(unique(pop$time), function(t) {
      snapshot <- pop[pop$time == t, ]
      class(snapshot) <- set_class(snapshot, "pop")

      # render the population if needed
      if (is.null(attr(pop, "intersected")))
        snapshot <- intersect_features(snapshot)

      raster_map <- rasterize(snapshot, resolution)

      # return the rendered spatial map with the population name and the
      # appropriate time stamp (unique-ing because intersecting splits
      # the spatial object into multiple disjoint features)
      list(
        pop = unique(snapshot$pop),
        time = unique(snapshot$time),
        map = raster_map
      )
    })
    snapshots
  })

  # flatten the list of ggplot objects
  rasters <- do.call(c, raster_list)

  rasters
}


#' Rasterize the vector form of a population spatial boundary
rasterize <- function(x, resolution) {
  # add a dummy variable for plotting the bi-color map
  x$fill <- factor(1)

  # create a template object for rasterization (i.e. size of the final raster)
  if (inherits(x, "spannr_map"))
    bbox <- sf::st_bbox(x)
  else
    bbox <- sf::st_bbox(attr(x, "map"))

  template <- stars::st_as_stars(bbox, dx = resolution, dy = resolution)

  # perform the rasterization using the dummy single-value factor column
  raster <- stars::st_rasterize(x["fill"], template)

  raster
}


#' Save the rasterized stars object to a PNG file
save_png <- function(raster, path) {
  tmp_tiff <- paste0(tempfile(), ".tiff")

  # write stars raster as a TIFF format
  stars::write_stars(raster, tmp_tiff)

  # convert the stars TIFF into a PNG (the only format SLiM supports)
  img <- ijtiff::read_tif(tmp_tiff, msg = FALSE)
  unlink(tmp_tiff)

  # subset the multidimensional array only to pixel two-dimensional matrix
  img_matrix <- img[, , 1, 1]

  # binarize the matrix (st_rasterize assigns a different color to each
  # fragmented spatial feature after intersect_features() call)
  img_matrix[img_matrix > 0] <- 1

  png::writePNG(img_matrix, path)
}
