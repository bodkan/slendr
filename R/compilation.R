#' Compile the spatial maps and split/admixture tables
#'
#' @param populations Population map objects of the 'spammr_pop' class
#' @param output_dir Directory to which to save the entire model
#' @param admixtures List of admixture events generated by the \code{admixture}
#'   function
#' @param overwrite Overwrite the contents of the output directory (in case it
#'   already exists)?
#'
#' @export
compile <- function(populations, output_dir, admixtures = NULL, overwrite = FALSE) {
  if (!is.null(admixtures) & is.data.frame(admixtures))
    admixtures <- list(admixtures)

  pops <- populations
  # iterate over all spammr population objects and extract
  # information about population split hierarchy and split times
  # into a data frame
  splits_table <- lapply(pops, function(p) {
    parent <- attr(p, "parent")
    if (is.character(parent) && parent == "ancestor") {
      parent_name <- parent
    } else {
      parent_name <- unique(attr(p, "parent")$pop)
    }

    tremove <- unique(attr(p, "remove"))

    data.frame(
      pop = unique(p$pop),
      parent = parent_name,
      tsplit = p$time[1],
      Ne = unique(p$Ne),
      tremove = ifelse(!is.null(tremove), tremove, -1)
    )
  }) %>% do.call(rbind, .)

  # order populations by split time and assign a numeric identifier to each
  splits_table <- splits_table[
    order(splits_table$tsplit, decreasing = TRUE, na.last = FALSE), ]
  splits_table$pop_id <- 1:nrow(splits_table) - 1
  splits_table$parent_id <- lapply(
    splits_table$parent,
    function(i) splits_table[splits_table$pop == i, ]$pop_id
  ) %>% unlist() %>% c(NA, .)

  # generate rasterized maps
  maps <- render(populations)

  # convert list of rasters into data frame, adding the spatial
  # maps themselves as a list column
  maps_table <- lapply(maps, function(m) {
    as.data.frame(m[c("pop", "time")])
  }) %>%
    do.call(rbind, .)
  maps_table$time <- round(maps_table$time)
  # add column with a numeric population identifier (used later by SLiM)
  maps_table$pop_id <- unlist(lapply(
    maps_table$pop,
    function(i) splits_table[splits_table$pop == i, ]$pop_id
  ))
  maps_table$map <- I(lapply(maps, function(m) m$map))
  maps_table <- maps_table[order(maps_table$time, decreasing = TRUE, na.last = FALSE), ]

  # prepare the model output directory
  if (dir.exists(output_dir)) {
    if (!overwrite)
      stop("Output directory already exists - either delete it or set 'overwrite = TRUE'",
           call. = FALSE)
    else
      unlink(output_dir, recursive = TRUE, force = TRUE)

  }
  dir.create(output_dir)

  # save the rasterized spatial maps
  for (i in seq_len(nrow(maps_table))) {
    map_row <- maps_table[i, ]
    # the first spatial map has necessarily a nonsensical time stamp,
    # so let's take care of that first
    time <- ifelse(map_row$time == Inf, "ancestor", map_row$time)

    ## filename <- sprintf("map_%d_%s_%s.png", i, map_row$pop, time)
    filename <- sprintf("%d.png", i)
    path <- file.path(output_dir, filename)

    save_png(map_row$map[[1]], path)
  }

  # get pixel coordinates of population centers based on the first
  # spatial map defined for each population
  centers_table <- lapply(1:nrow(splits_table), function(i) {
    pop_name <- splits_table[i, "pop"]
    time <- splits_table[i, "tsplit"]
    # get the first spatial map object of the current population
    pop <- Filter(function(i) unique(i$pop == pop_name), pops)[[1]][1, ]

    # get center point and the raster of the first spatial map
    raster <- maps_table[maps_table$pop == pop_name & maps_table$time == time, ]$map[[1]]
    coords <- raster_center(pop, raster)

    data.frame(pop = pop_name, x = coords[1], y = coords[2])
  }) %>% do.call(rbind, .)

  # merge splits table with the pixel locations of population centers
  splits_table <- merge(splits_table, centers_table, by = "pop")
  splits_table <- splits_table[order(splits_table$pop_id), ]

  # take care of Inf/NA values for downstream SLiM processing
  splits_table$tsplit <- ifelse(splits_table$tsplit == Inf, -1, splits_table$tsplit)
  maps_table$time <- ifelse(maps_table$time == Inf, -1, maps_table$time)
  splits_table$parent_id <- ifelse(is.na(splits_table$parent_id), -1, splits_table$parent_id)

  # save the table with spatial map paths
  maps_table$map <- seq_len(nrow(maps_table))
  write.table(
    maps_table[, c("pop_id", "time", "map")],
    file.path(output_dir, "maps.tsv"),
    sep = "\t", quote = FALSE, row.names = FALSE
  )

  # save the population splits table
  write.table(
    splits_table[, c("pop_id", "Ne", "x", "y", "parent_id", "tsplit", "tremove")],
    file.path(output_dir, "splits.tsv"),
    sep = "\t", quote = FALSE, row.names = FALSE
  )

  # save the population names (SLiM doesn't do data frames with mixed numeric
  # and character types, so this needs to be saved separately)
  writeLines(splits_table$pop, con = file.path(output_dir, "names.txt"))

  # save the admixture table
  if (is.null(admixtures))
    admix_table <- data.frame(from = NULL, to = NULL, tstart = NULL, tend = NULL, rate = NULL)
  else {
    admix_table <- do.call(rbind, admixtures)
    admix_table$rate <- as.integer(admix_table$rate * 100)
    admix_table$from <- unlist(lapply(
      admix_table$from_name,
      function(i) splits_table[splits_table$pop == i, ]$pop_id
    ))
    admix_table$to <- unlist(lapply(
      admix_table$to_name,
      function(i) splits_table[splits_table$pop == i, ]$pop_id
    ))
    admix_table <- admix_table[, c("from", "to", "tstart", "tend", "rate")]
  }
  write.table(
    admix_table,
    file.path(output_dir, "admixtures.tsv"),
    sep = "\t", quote = FALSE, row.names = FALSE
  )
}


#' Render population boundaries to black-and-white spatial maps
#'
#' @param pops Spatial population objects of the 'spammr_pop' class
#'
#' @import ggplot2
render <- function(pops) {
  raster_list <- lapply(pops, function(pop) {
    # iterate over temporal maps for the current population
    snapshots <- lapply(unique(pop$time), function(t) {
      snapshot <- pop[pop$time == t, ]
      class(snapshot) <- set_class(snapshot, "pop")

      # render the population if needed
      if (is.null(attr(pop, "intersected")))
        snapshot <- intersect_features(snapshot)

      raster_map <- rasterize(snapshot)

      # return the rendered spatial map with the population name and the
      # appropriate time stamp (unique-ing because intersecting splits
      # the spatial object into multiple disjoint features)
      list(
        pop = unique(snapshot$pop),
        time = unique(snapshot$time),
        map = raster_map
      )
    })
    snapshots
  })

  # flatten the list of ggplot objects
  rasters <- do.call(c, raster_list)

  rasters
}


#' Calculate pixel location of a spatial point (sf object) on a given
#' raster
#'
#' @param x Point object of the sf type (see `get_centroid`)
#' @param raster Raster object of the class 'stars'
#' @param world Underlying world object
#'
#' @return Two-dimensional numeric vector of pixel coordinates
raster_center <- function(pop, raster) {
  # get the dimension of the whole world raster bitmap
  raster_width <- dim(raster)["x"]
  raster_height <- dim(raster)["y"]

  # get the dimension of the world in the real CRS units
  bbox <- sf::st_bbox(attr(pop, "world"))
  world_width <- bbox["xmax"] - bbox["xmin"]
  world_height <- bbox["ymax"] - bbox["ymin"]

  center <- sf::st_coordinates(sf::st_centroid(pop))
  xpoint <- as.integer(center[1] - bbox["xmin"])
  ypoint <- as.integer(center[2] - bbox["ymin"])

  coords <- as.integer(c(xpoint / world_width * raster_width,
                         ypoint / world_height * raster_height))

  coords
}


#' Rasterize the vector form of a population spatial boundary
#'
#' @param x Object of the 'spammr_pop' class
#' @param pixel_dim Two-dimensional numeric vector specifying pixel
#'   dimension (in units of the CRS used in the definition of the
#'   world)
#' @param raster_dim Two-dimendional numeric vectory specifying the
#'   absolute dimension of the raster map
rasterize <- function(x, pixel_dim = c(10000, 10000), raster_dim = NULL) {
  # add a dummy variable for plotting the bi-color map
  x$fill <- factor(1)

  # create a template object for rasterization (i.e. size of the final raster)
  if (inherits(x, "spammr_world"))
    bbox <- sf::st_bbox(x)
  else
    bbox <- sf::st_bbox(attr(x, "world"))
  if (length(pixel_dim) == 2) {
    template <- stars::st_as_stars(bbox, dx = pixel_dim[1], dy = pixel_dim[2])
  } else if (length(raster_dim) == 2) {
    template <- stars::st_as_stars(bbox, nx = raster_dim[1], ny = raster_dim[2])
  } else {
    template <- stars::st_as_stars(bbox)
  }

  # perform the rasterization using the dummy single-value factor column
  raster <- stars::st_rasterize(x["fill"], template)

  raster
}


#' Save the rasterized stars object to a PNG file
#'
#' @param raster Object of a stars type
#' @param path Full path of an output PNG file
save_png <- function(raster, path) {
  tmp_tiff <- paste0(tempfile(), ".tiff")

  # write stars raster as a TIFF format
  stars::write_stars(raster, tmp_tiff)

  # convert the stars TIFF into a PNG (the only format SLiM supports)
  img <- ijtiff::read_tif(tmp_tiff, msg = FALSE)
  unlink(tmp_tiff)

  # subset the multidimensional array only to pixel two-dimensional matrix
  img_matrix <- img[, , 1, 1]

  # binarize the matrix (st_rasterize assigns a different color to each
  # fragmented spatial feature after intersect_features() call)
  img_matrix[img_matrix > 0] <- 1

  png::writePNG(img_matrix, path)
}


#' Open the SLiM backend script in the SLiM gui
#'
#' @param gen_time Generation time (in model's time units, i.e. years)
#' @param burnin Length of the burnin (in model's time units,
#'   i.e. years)
#' @param sim_length Total length of the simulation (in model's time
#'   units, i.e. years)
#' @param seq_length Total length of the simulated sequence in
#'   base-pairs
#' @param interaction Spatial interaction/mate choice distance
#'   parameter
#' @param spread Sigma parameter of the offspring spread normal
#'   distribution
#' @param output_prefix Directory and shared prefix of all output
#'   files (all output files will be placed into the model directory
#'   by default)
#'
#' @export
run <- function(model_dir, gen_time, burnin, sim_length,
                interaction, spread, seq_length, recomb_rate,
                track_ancestry = FALSE,
                output_prefix = file.path(normalizePath(model_dir), "output_")) {
  if (!dir.exists(model_dir))
    stop(sprintf("Directory '%s' does not exist", model_dir), call. = FALSE)

  if (!all(file.exists(file.path(model_dir, c("admixtures.tsv", "splits.tsv", "maps.tsv")))))
    stop(sprintf("Directory '%s' does not contain spammr configuration files", model_dir), call. = FALSE)

  if (!length(list.files(model_dir, pattern = "*.png") == 0))
    stop(sprintf("Directory '%s' does not contain any spammr spatial raster maps", model_dir), call. = FALSE)

  # compile the SLiM backend script
  template <- readLines("~/projects/spammr/inst/extdata/backend.slim")

  subst <- list(
    model_dir = normalizePath(model_dir),
    output_prefix = output_prefix,
    gen_time = gen_time,
    burnin = burnin,
    sim_length = sim_length,
    interaction = interaction,
    spread = spread,
    seq_length = seq_length,
    recomb_rate = recomb_rate,
    track_ancestry = if (track_ancestry) "T" else "F"
  )
  rendered <- whisker::whisker.render(template, subst)

  script <- file.path(subst[["model_dir"]], "script.slim")
  writeLines(rendered, script)

  system(sprintf("open -a SLiMgui %s", script))
}

