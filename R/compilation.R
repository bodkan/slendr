#' Compile the spatial demographic model
#'
#' First, compiles the vectorized population spatial maps into a series of
#' binary raster PNG files, which is the format that SLiM understands and uses
#' it to define population boundaries. Then extracts the demographic model
#' defined by the user (i.e. population divergences and gene flow events) into a
#' series of tables which are later used by the built-in SLiM script to program
#' the timing of simulation events.
#'
#' @param populations Object(s) of the \code{spannr_pop} class (multiple objects
#'   need to be specified in a \code{list})
#' @param generation_time Generation time (in model time units)
#' @param resolution How many distance units per pixel?
#' @param admixtures Admixture events generated by the \code{admixture} function
#'   (either a list of data.frame objects in the format defined by the
#'   \code{admixture} function, or a single data.frame)
#' @param competition_dist,mate_dist Maximum spatial competition and mating
#'   choice distance
#' @param offspring_dist Standard deviation of the normal distribution of the
#'   parent-offspring distance
#' @param dir Output directory for the model configuration files which will be
#'   loaded by the backend SLiM script
#' @param overwrite Overwrite the contents of the output directory in case it
#'   already exists?
#'
#' @return Compiled \code{spannr_model} model object
#' @export
compile <- function(populations, dir, generation_time, resolution,
                    competition_dist = NULL, mate_dist = NULL, offspring_dist = NULL,
                    admixtures = NULL, overwrite = FALSE) {
  if (!inherits(populations, "list"))  populations <- list(populations)

  # prepare the model output directory
  if (dir.exists(dir)) {
    if (!overwrite)
      stop("Output directory already exists - either delete it or set 'overwrite = TRUE'",
           call. = FALSE)
    else
      unlink(dir, recursive = TRUE, force = TRUE)

  }
  dir.create(dir)

  map <- attr(populations[[1]], "map")

  if (!is.null(competition_dist)) check_resolution(map, competition_dist)
  if (!is.null(mate_dist)) check_resolution(map, mate_dist)
  if (!is.null(offspring_dist)) check_resolution(map, offspring_dist)
  check_resolution(map, resolution)

  # save split and admixture tables which will be returned in the model object
  # in separate objects (tables serialized for SLiM will have to be stripped
  # first)
  split_table <- compile_splits(populations)

  # take care of missing interactions and offspring distances
  if (any(is.na(split_table$competition_dist))) {
    if (is.null(competition_dist)) {
      pop_names <- paste(split_table[is.na(split_table$competition_dist), ]$pop, collapse = ", ")
      stop("Parameter 'competition_dist' missing for ", pop_names, " and a general value of this parameter was not provided to the compile() function", call. = FALSE)
    } else
      split_table$competition_dist[is.na(split_table$competition_dist)] <- competition_dist
  }
  if (any(is.na(split_table$mate_dist))) {
    if (is.null(mate_dist)) {
      pop_names <- paste(split_table[is.na(split_table$mate_dist), ]$pop, collapse = ", ")
      stop("Parameter 'mate_dist' missing for ", pop_names, " and a general value of this parameter was not provided to the compile() function", call. = FALSE)
    } else
      split_table$mate_dist[is.na(split_table$mate_dist)] <- mate_dist
  }
  if (any(is.na(split_table$offspring_dist))) {
    if (is.null(offspring_dist)) {
      pop_names <- paste(split_table[is.na(split_table$offspring_dist), ]$pop, collapse = ", ")
      stop("Parameter 'offspring_dist' missing for ", pop_names, " and a general value of this parameter was not provided to the compile() function", call. = FALSE)
    } else
      split_table$offspring_dist[is.na(split_table$offspring_dist)] <- offspring_dist
  }
  split_table[, c("competition_dist", "mate_dist", "offspring_dist")] <-
    split_table[, c("competition_dist", "mate_dist", "offspring_dist")] / resolution

  if (!is.null(admixtures)) {
    if (is.data.frame(admixtures)) admixtures <- list(admixtures)
    admix_table <- do.call(rbind, admixtures)
    names(admix_table)[1:2] <- c("from", "to")
    admix_table$tstart_gen <- admix_table$tstart / generation_time
    admix_table$tend_gen <- admix_table$tend / generation_time
    # convert population names and their parents' names to SLiM numbers
    admix_table$from_id <- unlist(lapply(
      admix_table$from,
      function(i) split_table[split_table$pop == i, ]$pop_id
    ))
    admix_table$to_id <- unlist(lapply(
      admix_table$to,
      function(i) split_table[split_table$pop == i, ]$pop_id
    ))
  } else
    admix_table <- NULL

  # compile the spatial maps
  map_table <- compile_maps(populations, split_table, resolution)

  map_table$path <-map_table$map_number %>%
    paste0(., ".png") %>% file.path(dir, .) %>% gsub("//", "/", .)

  map_table$time_gen <- map_table$time
  map_table$time_gen[map_table$time_gen != -1] <-
    map_table$time_gen[map_table$time_gen != -1] / generation_time
  split_table$parent_id <- ifelse(is.na(split_table$parent_id), -1, split_table$parent_id)

  # convert times into generations (only in the table of splits which will be
  # saved for later SLiM runs)
  split_table$tsplit_gen <- split_table$tsplit / generation_time
  split_table$tremove_gen <- split_table$tremove
  split_table$tremove_gen[split_table$tremove_gen != -1] <-
    split_table$tremove[split_table$tremove_gen != -1] / generation_time

  if (is.null(admix_table)) {
    return_admixtures <- NULL
  } else {
    return_admixtures <-
      admix_table[,c("from", "from_id", "to", "to_id", "tstart", "tstart_gen",
                     "tend", "tend_gen", "rate", "overlap")]
  }

  # compile the result
  result <- list(
    config = list(
      directory = dir,
      splits = file.path(dir, "splits.tsv"),
      maps = file.path(dir, "maps.tsv"),
      admixtures = if (is.null(admixtures)) NULL else file.path(dir, "admixtures.tsv")
    ),
    world = map,
    populations = populations,
    splits = split_table[, c("pop", "pop_id", "parent", "parent_id", "N",
                             "tsplit", "tsplit_gen", "tremove", "tremove_gen",
                             "competition_dist", "mate_dist", "offspring_dist")],
    admixtures = return_admixtures,
    maps = map_table[, c("pop", "pop_id", "time", "time_gen", "path")],
    generation_time = generation_time,
    resolution = resolution
  )
  class(result) <- set_class(result, "model")

  write_model(dir, populations, admix_table, map_table, split_table,
              generation_time, resolution)

  result
}


#' Read a previously serialized model configuration
#'
#' Reads all configuration tables and other model data from a location
#' where it was previously compiled to by the \code{compile} function.
#'
#' @param dir Directory with all required configuration files
#'
#' @export
read <- function(dir) {
  # paths to files which are saved by the compile() function and are necessary
  # for running the backend script using the run() function
  path_populations <- file.path(dir, "populations.rds")
  path_splits <- file.path(dir, "splits.tsv")
  path_admixtures <- file.path(dir, "admixtures.tsv")
  path_maps <- file.path(dir, "maps.tsv")
  path_names <- file.path(dir, "names.txt")
  path_generation_time <- file.path(dir, "generation_time.txt")
  path_resolution <- file.path(dir, "resolution.txt")

  if (!dir.exists(dir))
    stop(sprintf("Model directory '%s' does not exist", dir), call. = FALSE)

  if (!all(file.exists(c(path_populations, path_splits, path_maps, path_names))))
    stop(sprintf("Directory '%s' does not contain all spannr configuration files.
Please make sure that populations.rds, {splits,admixtures,maps}.tsv, names.txt
and generation_time.txt are all present", dir), call. = FALSE)

  pop_names <- scan(path_names, what = "character", quiet = TRUE)
  generation_time <- scan(path_generation_time, what = integer(), quiet = TRUE)
  resolution <- scan(path_resolution, what = integer(), quiet = TRUE)

  # load the split table from disk and re-format it to the original format
  splits <- read.table(path_splits, header = TRUE, stringsAsFactors = FALSE)
  # add population labels and parent population labels (these are striped away
  # during model saving because SLiM can't handle mixed types in matrices)
  splits$pop <- pop_names[splits$pop_id + 1]
  ancestral <- splits$parent == -1
  splits$parent[ancestral] <- "ancestor"
  if (any(!ancestral))
    splits$parent[!ancestral] <- pop_names[splits$parent_id[!ancestral] + 1]

  # load and reformat the admixtures table (if present - if absent, no admixture
  # was specified)
  admix_table <- NULL
  if (file.exists(path_admixtures)) {
    admix_table <- read.table(path_admixtures, header = TRUE, stringsAsFactors = FALSE)
    admix_table$from <- pop_names[admix_table$from_id + 1]
    admix_table$to <- pop_names[admix_table$to_id + 1]
    admix_table$rate <- admix_table$rate / 100
    admix_table$tstart <- round(admix_table$tstart_gen * generation_time)
    admix_table$tend <- round(admix_table$tend_gen * generation_time)
    admix_table$overlap <- admix_table$overlap == 1
    admix_table <- admix_table[, c("from", "from_id", "to", "to_id", "tstart",
                                   "tstart_gen", "tend", "tend_gen", "rate", "overlap")]
  }

  # load and reformat the maps table
  map_table <- read.table(path_maps, header = TRUE, stringsAsFactors = FALSE)
  # reconstruct the paths to each raster map (again, stripped away because SLiM
  # can't handle strings and numbers in a single matrix/data frame)
  map_table$path <- file.path(dir, paste0(map_table$map_number, ".png")) %>% gsub("//", "/", .)
  if (!all(file.exists(map_table$path)))
    stop(sprintf("Directory '%s' does not contain all maps required by the model configuration (%s)", dir, map_table$map), call. = FALSE)
  # recreate the user-specified population labels
  map_table$pop <- pop_names[map_table$pop_id + 1]

  # convert times to their original value before conversion for SLiM (this
  # handling of -1 and Inf special cases is absolutely awful, but we are
  # currently forced to do this because we need to interface with the rather
  # limited SLiM builtin language)
  # convert generations back to years
  splits$tsplit <- round(splits$tsplit * generation_time)
  splits$tremove[splits$tremove != -1] <-
    round(splits$tremove[splits$tremove != -1] * generation_time)
  map_table$time[map_table$time != -1] <-
    round(map_table$time[map_table$time != -1] * generation_time)

  populations <- readRDS(path_populations)

  result <- list(
    config = list(
      directory = dir,
      splits = path_splits,
      maps = path_maps,
      admixtures = if (is.null(admix_table)) NULL else file.path(dir, "admixtures.tsv")
    ),
    world = attr(populations[[1]], "map"),
    populations = populations,
    splits = splits[, c("pop", "pop_id", "parent", "parent_id", "N", "tsplit",
                        "tsplit_gen", "tremove", "tremove_gen",
                        "competition_dist", "mate_dist", "offspring_dist")],
    admixtures = admix_table,
    maps = map_table[, c("pop", "pop_id", "time", "time_gen", "path")],
    generation_time = generation_time,
    resolution = resolution
  )
  class(result) <- set_class(result, "model")
  result
}


#' Run a spannr model as a SLiM script
#'
#' Generates a SLiM script from a built-in spannr template,
#' substituting all required parameters by values specified by the
#' user. The user has an option to either run the script in batch
#' mode, open it in SLiMgui, or simply save the generated SLiM script
#' to a given location for later use.
#'
#' @param model Model object created by the \code{compile} function
#' @param sim_length Total length of the simulation (in model time
#'   units, i.e.  years)
#' @param seq_length Total length of the simulated sequence (in
#'   base-pairs)
#' @param recomb_rate Recombination rate of the simulated sequence (in
#'   recombinations per basepair per generation)
#' @param keep_pedigrees Turn on \code{keepPedigrees} during SLiM
#'   initialization?
#' @param ts_recording Turn on tree sequence recording during SLiM
#'   initialization?
#' @param save_locations Save location of each individual throughout
#'   the simulation?
#' @param track_ancestry Track ancestry proportion dynamics in all
#'   populations throughout the simulations (default FALSE)? If a
#'   non-zero integer is provided, ancestry will be tracked using the
#'   number number of neutral ancestry markers equal to this number.
#' @param method How to run the script? ("gui" - open in SLiMgui, "batch"
#'   - run on the command-line, "script" - simply return the script)
#' @param include Vector of paths to custom SLiM scripts which should
#'   be combined with the backend SLiM code
#' @param generation_time Generation time (in model's time units,
#'   i.e. years)
#' @param burnin Length of the burnin (in model's time units,
#'   i.e. years)
#' @param script_path Name of the compiled output script
#' @param output_prefix Common prefix (including path) for all output
#'   files
#'
#' @export
slim <- function(model, seq_length, recomb_rate,
                 save_locations = FALSE, track_ancestry = FALSE,
                 keep_pedigrees = FALSE, ts_recording = FALSE,
                 method = "gui", verbose = FALSE, include = NULL, burnin = NULL,
                 script_path = file.path(model$config$directory, "script.slim"),
                 output_prefix = file.path(model$config$directory, "output")) {
  dir <- model$config$directory
  if (!dir.exists(dir))
    stop(sprintf("Model directory '%s' does not exist", dir), call. = FALSE)

  if (!all(file.exists(file.path(dir, c("splits.tsv", "maps.tsv")))))
    stop(sprintf("Directory '%s' does not contain spannr configuration files", dir), call. = FALSE)

  if (!length(list.files(dir, pattern = "*.png") == 0))
    stop(sprintf("Directory '%s' does not contain any spannr spatial raster maps", dir), call. = FALSE)

  if (!is.logical(track_ancestry) & !is.numeric(track_ancestry)) {
    stop("'track_ancestry' must be either FALSE or 0 (no tracking), or
a non-zero integer number (number of neutral ancestry markers)", call. = FALSE)
  } else
    markers_count <- as.integer(track_ancestry)

  backend_script <- system.file("extdata", "backend.slim", package = "spannr")

  burnin <- if (!is.null(burnin)) round(burnin / model$generation_time) else 1

  base_script <- script(
    path = backend_script,

    model_dir = dir,
    output_prefix = output_prefix,
    burnin = burnin,
    keep_pedigrees = if (keep_pedigrees) "T" else "F",
    ts_recording = if (ts_recording) "T" else "F",
    seq_length = seq_length,
    recomb_rate = recomb_rate,
    ancestry_markers = markers_count,
    save_locations = if (save_locations) "T" else "F",
    generation_time = model$generation_time
  )

  # compile all script components, including the backend script, into one file
  script_components <- unlist(lapply(c(base_script, include), readLines))
  writeLines(script_components, script_path)

  if (method == "gui")
    system(sprintf("open -a SLiMgui %s", script_path))
  else if (method == "batch")
    system(sprintf("slim %s", script_path), ignore.stdout = !verbose)
  else if (method == "script")
    message("Final compiled SLiM script is in ", script_path)
  else
    stop("Only 'gui', 'batch', and 'script' are recognized as values of
the 'method' argument", call. = FALSE)
}


#' Substitute variables in a template SLiM script
#'
#' Variables in the template script must conform to the Mustache
#' specification, i.e. specified as {{variable_name}}. For more
#' information see the Mustache specification at:
#' <http://mustache.github.io/>
#'
#' @param path Path to a template SLiM script
#' @param output Where to save the substituted SLiM script (temporary location
#'   by default)
#' @param ... Variable values to be substituted
#'
#' @return Name of the substituted SLiM script
#'
#' @export
script <- function(path, output = NULL, ...) {
  if (!file.exists(path))
    stop(sprintf("File '%s' not found", path), call. = FALSE)

    if (is.null(output)) output <- paste0(tempfile(), ".slim")

  template <- readLines(path)

  # extract variables to be substituted in the template script
  vars <- strsplit(template, split = "\\{\\{") %>%
    unlist %>%
    .[grepl("\\}\\}", .)] %>%
    gsub("\\}\\}.*$", "", .)

  # collect all variables provided by the user and make sure that
  # none are missing
  subst <- list(...)
  if (!all(vars %in% names(subst))) {
    stop(sprintf("Values of %s must be specified",
                 paste(vars[!vars %in% names(subst)], collapse = ", ")),
         call. = FALSE)
  }

  # fill in the variable substitution in the template script and
  # save it to disk
  rendered <- whisker::whisker.render(template, subst)
  writeLines(rendered, output)

  output
}


#' Write a compiled spannr model to disk
write_model <- function(dir, populations, admix_table, map_table,
                        split_table, generation_time, resolution) {
  if (!is.null(admix_table)) {
    admix_table$rate <- as.integer(admix_table$rate * 100)
    admix_table$overlap <- as.integer(admix_table$overlap)

    write.table(
      admix_table[, c("from_id", "to_id", "tstart_gen", "tend_gen",
                      "rate", "overlap")],
      file.path(dir, "admixtures.tsv"),
      sep = "\t", quote = FALSE, row.names = FALSE
    )
  }

  for (i in seq_len(nrow(map_table))) {
    map_row <- map_table[i, ]
    path <- file.path(dir, sprintf("%d.png", i))
    save_png(map_row$map[[1]], path)
  }

  saveRDS(populations, file.path(dir, "populations.rds"))

  write.table(
    split_table[, c("pop_id", "N", "parent_id", "tsplit_gen", "tremove_gen",
                    "competition_dist", "mate_dist", "offspring_dist")],
    file.path(dir, "splits.tsv"),
    sep = "\t", quote = FALSE, row.names = FALSE
  )

  write.table(
    map_table[, c("pop_id", "time_gen", "map_number")],
    file.path(dir, "maps.tsv"),
    sep = "\t", quote = FALSE, row.names = FALSE
  )

  # save the population names (SLiM doesn't do data frames with mixed numeric
  # and character types, so this needs to be saved separately)
  writeLines(split_table$pop, con = file.path(dir, "names.txt"))

  base::write(generation_time, file.path(dir, "generation_time.txt"))
  base::write(resolution, file.path(dir, "resolution.txt"))
}


#' Iterate over population objects and convert he information about
#' population split hierarchy and split times into a data frame
compile_splits <- function(populations) {
  splits_table <- lapply(populations, function(p) {
    parent <- attr(p, "parent")
    if (is.character(parent) && parent == "ancestor") {
      parent_name <- parent
    } else {
      parent_name <- unique(attr(p, "parent")$pop)
    }

    tremove <- attr(p, "remove")

    competition_dist <- attr(p, "competition_dist")
    mate_dist <- attr(p, "mate_dist")
    offspring_dist <- attr(p, "offspring_dist")

    data.frame(
      pop = unique(p$pop),
      parent = parent_name,
      tsplit = p$time[1],
      N = unique(p$N),
      tremove = ifelse(!is.null(tremove), tremove, -1),
      competition_dist = ifelse(is.null(competition_dist), NA, competition_dist),
      mate_dist = ifelse(is.null(mate_dist), NA, mate_dist),
      offspring_dist = ifelse(is.null(offspring_dist), NA, offspring_dist),
      stringsAsFactors = FALSE
    )
  }) %>% do.call(rbind, .)

  # order populations by split time and assign a numeric identifier to each
  splits_table <- splits_table[
    order(splits_table$tsplit, decreasing = TRUE, na.last = FALSE), ]
  splits_table$pop_id <- 1:nrow(splits_table) - 1
  splits_table$parent_id <- lapply(
    splits_table$parent,
    function(i) {
      if (i == "ancestor") -1
      else splits_table[splits_table$pop == i, ]$pop_id
    }
  ) %>% unlist()

  splits_table
}

#' Process vectorized population boundaries into a table with
#' rasterized map objects
compile_maps <- function(populations, splits_table, resolution) {
  # generate rasterized maps
  maps <- render(populations, resolution)

  # convert list of rasters into data frame, adding the spatial
  # maps themselves as a list column
  maps_table <- lapply(maps, function(m) {
    as.data.frame(m[c("pop", "time")], stringsAsFactors = FALSE)
  }) %>%
    do.call(rbind, .)
  # add column with a numeric population identifier (used later by SLiM)
  maps_table$pop_id <- unlist(lapply(
    maps_table$pop,
    function(i) splits_table[splits_table$pop == i, ]$pop_id
  ))
  maps_table$map <- I(lapply(maps, function(m) m$map))
  maps_table <- maps_table[order(maps_table$time,
                                 decreasing = TRUE, na.last = FALSE), ]

  maps_table$time <- round(maps_table$time)

  # number maps sequentially in the order SLiM will be swapping them
  # later (each map number X corresponds to X.png)
  maps_table$map_number <- seq_len(nrow(maps_table))

  maps_table
}


#' Render population boundaries to black-and-white spatial maps
render <- function(pops, resolution) {
  raster_list <- lapply(pops, function(pop) {
    # iterate over temporal maps for the current population
    snapshots <- lapply(unique(pop$time), function(t) {
      snapshot <- pop[pop$time == t, ]
      class(snapshot) <- set_class(snapshot, "pop")

      # render the population if needed
      if (is.null(attr(pop, "intersected")))
        snapshot <- intersect_features(snapshot)

      raster_map <- rasterize(snapshot, resolution)

      # return the rendered spatial map with the population name and the
      # appropriate time stamp (unique-ing because intersecting splits
      # the spatial object into multiple disjoint features)
      list(
        pop = unique(snapshot$pop),
        time = unique(snapshot$time),
        map = raster_map
      )
    })
    snapshots
  })

  # flatten the list of ggplot objects
  rasters <- do.call(c, raster_list)

  rasters
}


#' Rasterize the vector form of a population spatial boundary
rasterize <- function(x, resolution) {
  # add a dummy variable for plotting the bi-color map
  x$fill <- factor(1)

  # create a template object for rasterization (i.e. size of the final raster)
  if (inherits(x, "spannr_map"))
    bbox <- sf::st_bbox(x)
  else
    bbox <- sf::st_bbox(attr(x, "map"))

  template <- stars::st_as_stars(bbox, dx = resolution, dy = resolution)

  # perform the rasterization using the dummy single-value factor column
  raster <- stars::st_rasterize(x["fill"], template)

  if (length(table(raster$ID)) == 1) {
    stop(sprintf("
The generated raster map of %s at time %s is blank.
This would cause SLiM to crash as it would not be able to place
any individuals on the map. Please check the spatial boundary for
this population at this time point.", x$pop, x$time), call. = FALSE)
  }

  raster
}


#' Save the rasterized stars object to a PNG file
save_png <- function(raster, path) {
  tmp_tiff <- paste0(tempfile(), ".tiff")

  # write stars raster as a TIFF format
  stars::write_stars(raster, tmp_tiff)

  # convert the stars TIFF into a PNG (the only format SLiM supports)
  img <- ijtiff::read_tif(tmp_tiff, msg = FALSE)
  unlink(tmp_tiff)

  # subset the multidimensional array only to pixel two-dimensional matrix
  img_matrix <- img[, , 1, 1]

  # binarize the matrix (st_rasterize assigns a different color to each
  # fragmented spatial feature after intersect_features() call)
  img_matrix[img_matrix > 0] <- 1

  png::writePNG(img_matrix, path)
}
