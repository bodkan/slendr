# tree sequence processing ------------------------------------------------

#' Load a tree sequence file produced by a given model
#'
#' This function loads a tree sequence file simulated from a given slendr model.
#' Optionally, the tree sequence can be recapitated and simplified.
#'
#' The loading, recapitation and simplification is performed using the Python
#' module pyslim which serves as a link between tree sequences generated by SLiM
#' and the tskit module for manipulation of tree sequence data. All of these
#' steps have been modelled after the official pyslim tutorial and documentation
#' available at: <https://pyslim.readthedocs.io/en/latest/tutorial.html>.
#'
#' The recapitation and simplification steps can also be performed individually
#' using the functions \code{\link{ts_recapitate}} and
#' \code{\link{ts_simplify}}.
#'
#' @param model Compiled \code{slendr_model} model object
#' @param output_dir A directory where to look for simulation outputs (by
#'   default, all output files are in a model directory)
#' @param output_prefix A common prefix of output files (by default, all files
#'   will share a prefix \code{"output"})
#' @param recapitate Should the tree sequence be recapitated?
#' @param simplify Should the tree sequence be simplified down to only
#'   remembered (i.e. "sampled", in \emph{slendr} parlance) individuals?
#' @param spatial Should spatial information encoded in the tree sequence data
#'   be converted to spatial R datastructures? If FALSE, pixel-based
#'   raster-dimensions will not be converted to the coordinate reference system
#'   implied by the model. If TRUE (default), reprojection of coordinates will
#'   be performed. If the model was non-spatial, the value of this parameter is
#'   disregarded.
#' @param recombination_rate,Ne Arguments passed to \code{ts_recapitate}
#' @param random_seed Random seed passed to pyslim's \code{recapitate} method
#' @param simplify_to A character vector of individual names. If NULL, all
#'   remembered individuals will be retained. Only used when \code{simplify =
#'   TRUE}.
#'
#' @return \code{pyslim.SlimTreeSequence} object of the class \code{slendr_ts}
#'
#' @seealso [\code{\link{ts_data}}] for extracting useful information about
#'   individuals, nodes, coalescent times and geospatial locations of nodes on a
#'   map
#'
#' @export
ts_load <- function(model, output_dir = model$path, output_prefix = "output",
                    recapitate = FALSE, simplify = FALSE,
                    spatial = TRUE, recombination_rate = NULL,
                    Ne = NULL, random_seed = NULL, simplify_to = NULL) {
  if (is.null(model$world)) spatial <- FALSE

  if (recapitate && (is.null(recombination_rate) || is.null(Ne)))
    stop("Recombination rate and Ne must be specified for recapitation", call. = FALSE)

  if (!inherits(model, "slendr_model"))
    stop("A compiled slendr model object must be provided to be able to fetch metadata from", call. = FALSE)

  file <- file.path(output_dir, paste0(output_prefix, "_ts.trees"))
  ts <- pyslim$load(path.expand(file))

  attr(ts, "model") <- model
  attr(ts, "sampling") <- get_sampling(ts)

  class(ts) <- c("slendr_ts", class(ts))

  # process tree sequence tables only in case recapitation and simplification
  # are not to be performed during loading (this avoids computing data that
  # would be overwritten immediately after)
  if (!recapitate && !simplify) {
    attr(ts, "nodes") <- get_ts_nodes(ts)
    attr(ts, "edges") <- get_ts_edges(ts)
    attr(ts, "individuals") <- get_ts_individuals(ts)

    attr(ts, "data") <- get_table_data(ts, model, spatial)
  }

  if (recapitate)
    ts <- ts_recapitate(ts, recombination_rate = recombination_rate, Ne = Ne,
                        random_seed = random_seed, spatial = spatial)

  if (simplify) ts <- ts_simplify(ts, simplify_to, spatial = spatial)

  ts
}

#' Recapitate the tree sequence
#'
#' @param ts \code{pyslim.SlimTreeSequence} object loaded by \code{ts_load}
#' @param recombination_rate A constant value of the recombination rate
#' @param Ne Effective population size during the recapitation process
#' @param spatial Should spatial information encoded in the tree sequence data
#'   be converted to spatial R data structures? If FALSE, pixel-based
#'   raster-dimensions will not be converted to the coordinate reference system
#'   implied by the model. If TRUE (default), reprojection of coordinates will
#'   be performed. If the model was non-spatial, the value of this parameter is
#'   disregarded.
#' @param random_seed Random seed passed to pyslim's \code{recapitate} method
#'
#' @return \code{pyslim.SlimTreeSequence} object of the class \code{slendr_ts}
#'
#' @seealso [\code{\link{ts_data}}] for extracting useful information about
#'   individuals, nodes, coalescent times and geospatial locations of nodes on a
#'   map
#'
#' @export
ts_recapitate <- function(ts, recombination_rate, Ne, spatial = TRUE,
                          random_seed = NULL) {
  check_ts_class(ts)

  model <- attr(ts, "model")

  if (is.null(model$world)) spatial <- FALSE

  if (ts_coalesced(ts))
    message("No need to recapitate, all trees already coalesced")

  ts_new <- ts$recapitate(recombination_rate = recombination_rate, Ne = Ne,
                          random_seed = random_seed)

  attr(ts_new, "model") <- model
  attr(ts_new, "sampling") <- attr(ts, "sampling")

  attr(ts_new, "nodes") <- get_ts_nodes(ts_new)
  attr(ts_new, "edges") <- get_ts_edges(ts_new)
  attr(ts_new, "individuals") <- get_ts_individuals(ts_new)

  attr(ts_new, "data") <- get_table_data(ts_new, model, spatial)

  class(ts_new) <- c("slendr_ts", class(ts_new))

  ts_new
}

#' Simplify the tree sequence down to a given set of individuals
#'
#' This function is a convenience wrapper around the \code{simplify} method
#' implemented in tskit, designed to work on tree sequence data simulated by
#' SLiM using the \pkg{slendr} R package.
#'
#' The simplification process is used to remove redundant information from the
#' tree sequence and retains only information necessary to describe the
#' genealogical history of a set of samples.
#'
#' For more information on how simplification works in pyslim and tskit, see the
#' official documentation at
#' <https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.simplify>
#' and
#' <https://pyslim.readthedocs.io/en/latest/python_api.html?pyslim.SlimTreeSequence.simplify#pyslim.SlimTreeSequence.simplify>.
#'
#' A very clear description of the difference between remembering and retaining
#' and how to use these techniques to implement historical individuals (i.e.
#' ancient DNA samples) is in the pyslim documentation at
#' <https://pyslim.readthedocs.io/en/latest/tutorial.html?highlight=retainCoalescentOnly#historical-individuals>.
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param simplify_to A character vector of individual names. If NULL, all
#'   explicitly remembered individuals (i.e. those specified via the
#'   \code{\link{sampling}} function will be left in the tree sequence after the
#'   simplification.
#' @param spatial Should spatial information encoded in the tree sequence data
#'   be converted to spatial R datastructures? If FALSE, pixel-based
#'   raster-dimensions will not be converted to the coordinate reference system
#'   implied by the model. If TRUE (default), reprojection of coordinates will
#'   be performed. If the model was non-spatial, the value of this parameter is
#'   disregarded.
#'
#' @return \code{pyslim.SlimTreeSequence} object of the class \code{slendr_ts}
#'
#' @seealso [\code{\link{ts_data}}] for extracting useful information about
#'   individuals, nodes, coalescent times and geospatial locations of nodes on a
#'   map
#'
#' @export
ts_simplify <- function(ts, simplify_to = NULL, spatial = TRUE) {
  check_ts_class(ts)

  model <- attr(ts, "model")
  if (is.null(model$world)) spatial <- FALSE

  data <- attr(ts, "data")
  # table data was not processed yet (i.e. simplification is being performed
  # during loading of the tree sequence data)
  if (is.null(data))
    data <- get_table_data(ts, model, spatial)

  if (is.null(simplify_to))
    samples <- dplyr::filter(data, remembered)$node_id
  else if (!all(simplify_to %in% data$name))
      stop("The following individuals are not present in the tree sequence: ",
           paste0(simplify_to[!simplify_to %in% data$name], collapse = ", "),
           call. = FALSE)
  else
    samples <- dplyr::filter(data, name %in% simplify_to)$node_id

  ts_new <- ts$simplify(as.integer(samples),
                        filter_populations = FALSE)

  # get the name and location from the original table with the pedigree_id key
  cols <- c("pedigree_id", "pop", "name")
  if (spatial) cols <- c(cols, "location")
  # we need to deduplicate the rows because the table is stored in a long format
  # (but we removed the node_id column which each diploid individual has two
  # values of)
  keep_data <- data[, cols] %>%
    dplyr::filter(!duplicated(pedigree_id))

  # get node IDs of individuals present in the simplified tree sequence
  # (sort by individual ID and time)
  nodes_new <- get_ts_nodes(ts_new) %>%
    dplyr::arrange(ind_id, time) %>%
    dplyr::select(node_id, ind_id) %>%
    .$node_id

  location_col <- if (spatial) "location" else NULL

  # get other data about individuals in the simplified tree sequence, sort them
  # also by their IDs and times, and add their node IDs extracted above
  # (this works because we sorted both in the same way)
  data_new <- get_table_data(ts_new, model, spatial, simplify_to) %>%
    as.data.frame() %>%
    dplyr::arrange(ind_id, time) %>%
    dplyr::select(ind_id, pedigree_id, time, alive, remembered, retained) %>%
    dplyr::inner_join(keep_data, by = "pedigree_id") %>%
    dplyr::mutate(node_id = nodes_new)

  if (spatial)
    data_new <- sf::st_as_sf(data_new, crs = sf::st_crs(data))

  attr(ts_new, "model") <- model
  attr(ts_new, "sampling") <- attr(ts, "sampling")

  attr(ts_new, "nodes") <- get_ts_nodes(ts_new)
  attr(ts_new, "edges") <- get_ts_edges(ts_new)
  attr(ts_new, "individuals") <- get_ts_individuals(ts_new)

  attr(ts_new, "data") <- data_new[, c("name", "pop", "ind_id", "node_id",
                                       "time", location_col, "remembered",
                                       "retained", "alive", "pedigree_id")]

  class(ts_new) <- c("slendr_ts", class(ts_new))

  ts_new
}

#' Add mutations to the given tree sequence
#'
#' @param ts Object of the type \code{pyslim.SlimTreeSequence}
#' @param mutation_rate Mutation rate used by msprime to simulate mutations
#' @param random_seed Random seed passed to msprime's \code{mutate} method
#' @param keep_existing Keep existing mutations?
#'
#' @return \code{pyslim.SlimTreeSequence} object of the class \code{slendr_ts}
#'
#' @seealso [\code{\link{ts_data}}] for extracting useful information about
#'   individuals, nodes, coalescent times and geospatial locations of nodes on a
#'   map
#'
#' @export
ts_mutate <- function(ts, mutation_rate, random_seed = NULL, keep_existing = TRUE) {
  check_ts_class(ts)

  ts_mutated <-
    msprime$mutate(ts, rate = mutation_rate, keep = keep_existing, random_seed = random_seed) %>%
    pyslim$SlimTreeSequence()

  attr(ts_mutated, "model") <- attr(ts, "model")
  attr(ts_mutated, "sampling") <- attr(ts, "sampling")

  attr(ts_mutated, "nodes") <- attr(ts, "nodes")
  attr(ts_mutated, "edges") <- attr(ts, "edges")
  attr(ts_mutated, "individuals") <- attr(ts, "individuals")

  attr(ts_mutated, "data") <- attr(ts, "data")

  class(ts_mutated) <- c("slendr_ts", class(ts_mutated))

  ts_mutated
}

# genotype conversion -----------------------------------------------------

#' Extract genotype table from the tree sequence
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#'
#' @return Data frame object of the class \code{tibble}
#'
#' @export
ts_genotypes <- function(ts) {
  genotypes <- ts$genotype_matrix()

  chromosomes <- ts_data(ts, remembered = TRUE) %>%
    dplyr::as_tibble() %>%
    dplyr::mutate(chr_name = sprintf("%s_chr%i", name, 1:2)) %>%
    dplyr::select(chr_name, node_id) %>%
    dplyr::arrange(node_id)

  colnames(genotypes) <- chromosomes$chr_name

  dplyr::as_tibble(genotypes) %>%
    dplyr::mutate(pos = ts$tables$sites$position) %>%
    dplyr::select(pos, dplyr::everything())
}

#' Extract genotypes from the tree sequence in the EIGENSTRAT format
#'
#' EIGENSTRAT data produced by this function can be used by the admixr R package
#' (<https://bodkan.net/admixr>).
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param prefix EIGENSTRAT trio prefix
#'
#' @return Object of the class EIGENSTRAT created by the admixr package
#'
#' @export
ts_eigenstrat <- function(ts, prefix, chrom = "chr1", quiet = FALSE) {
  chrom_genotypes <- ts_genotypes(ts)
  chr1_genotypes <- dplyr::select(chrom_genotypes, dplyr::ends_with("_chr1"))
  chr2_genotypes <- dplyr::select(chrom_genotypes, dplyr::ends_with("_chr2"))

  # create a geno file table
  geno <- dplyr::as_tibble(2 - (chr1_genotypes + chr2_genotypes))
  individuals <- gsub("_chr.", "", colnames(geno))
  colnames(geno) <- individuals

  # create an ind file table
  ind <- dplyr::tibble(id = individuals, sex = "U", label = individuals)

  # create a snp file table
  positions <- round(ts$tables$sites$position)
  snp <- dplyr::tibble(
    id = sprintf("%s_%s", chrom, as.character(positions)),
    chrom = chrom,
    gen = 0.0,
    pos = positions,
    ref = "G",
    alt = "T"
  )

  dup_muts <- duplicated(positions)
  if (any(dup_muts)) {
    message(sum(dup_muts), " mutations (out of ", nrow(snp), ") have been ",
            "removed because they appeared on a position already occupied by ",
            "another mutation. This is a consequence of mutations ",
            "positions in tskit being in floating-point values but normal ",
            "genomic locations being integer values.")
    snp <- snp[!dup_muts, ]
    geno <- geno[!dup_muts, ]
  }

  # save the EIGENSTRAT trio
  if (!dir.exists(dirname(prefix))) dir.create(dirname(prefix))
  admixr::write_geno(geno, paste0(prefix, ".geno"))
  admixr::write_snp(snp, paste0(prefix, ".snp"))
  admixr::write_ind(ind, paste0(prefix, ".ind"))

  # return the admixr eigenstrat object
  admixr::eigenstrat(prefix = prefix)
}

#' Save genotypes from the tree sequenceas a VCF file
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param vcf Path to a VCF file
#' @param individuals A character vector of individuals in the tree sequence. If
#'   missing, all individuals present in the tree sequence will be saved.
#'
#' @export
ts_vcf <- function(ts, vcf, individuals = NULL) {
  data <- ts_data(ts, remembered = TRUE) %>%
    dplyr::as_tibble() %>%
    dplyr::distinct(name, ind_id)

  if (is.null(individuals)) individuals <- data$name

  present <- individuals %in% unique(data$name)
  if (!all(present))
    stop("", paste(individuals[!present], collapse = ", "),
         " not present in the tree sequence", call. = FALSE)

  gzip <- reticulate::import("gzip")
  with(reticulate::`%as%`(gzip$open(path.expand(vcf), "wt"), vcf_file), {
    ts$write_vcf(vcf_file,
                 individuals = as.integer(data$ind_id),
                 individual_names = data$name)
  })
}


# tree sequence tables ----------------------------------------------------

#' Extract combined annotated table of individuals and nodes
#'
#' This function combines information from the table of individuals and table of
#' nodes into a single data frame which can be used in downstream analyses.
#'
#' The source of data (tables of individuals and nodes recorded in the tree
#' sequence generated by SLiM) are combined into a single data frame. If the
#' model which generated the data was spatial, coordinates of nodes (which are
#' pixel-based by default because SLiM spatial simulations occur on a raster),
#' the coordinates are automatically converted to an explicit spatial object of
#' the \code{sf} class unless \code{spatial = FALSE}. See
#' <https://r-spatial.github.io/sf/> for an extensive introduction to the sf
#' package and the ways in which spatial data can be processed, analysed, and
#' visualised.
#'
#' @seealso [\code{\link{ts_individuals}}] [\code{\link{ts_nodes}}]
#'   [\code{\link{ts_edges}}] for accessing raw tree sequence tables without
#'   added metadata annotation. See also [\code{\link{ts_ancestors}}] to learn
#'   how to extract information about relationship beteween nodes in the tree
#'   sequence, and how to analysed data about distances between nodes in the
#'   spatial context.
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param remembered,retained,alive Only extract information about nodes and
#'   times of individuals with the specific flag
#'
#' @return Data frame with processed information from the tree sequence object.
#'   If the model which generated this data was spatial, result will be returned
#'   as a spatial object of the class \code{sf}. See description for more
#'   information.
#'
#' @export
ts_data <- function(ts, remembered = NULL, retained = NULL, alive = NULL) {
  check_ts_class(ts)

  data <- attr(ts, "data")
  if (!is.null(remembered)) data <- dplyr::filter(data, remembered)
  if (!is.null(retained)) data <- dplyr::filter(data, retained)
  if (!is.null(alive)) data <- dplyr::filter(data, alive)

  attr(data, "model") <- attr(ts, "model")

  class(data) <- set_class(data, "spatial")

  data
}

#' Get the table of individuals/nodes/edges from the tree sequence
#'
#' This function extract data from a given tree sequence table
#'
#' This function extracts the raw table data. For further processing and
#' analyses, the output of the function \code{\link{ts_data}} might be more
#' useful, as it merges the information in node and individual tables into one
#' table and further annotates it with useful information from the model
#' configuration data.
#'
#' @seealso [\code{\link{ts_data}}] for accessing processed and annotated treee
#'   sequence table data
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#'
#' @return Data frame with the information from the give tree sequence table
#'
#' @export
ts_individuals <- function(ts) {
  check_ts_class(ts)
  attr(ts, "individuals")
}

#' @rdname ts_individuals
#' @export
ts_edges <- function(ts) {
  check_ts_class(ts)
  attr(ts, "edges")
}

#' @rdname ts_individuals
#' @export
ts_nodes <- function(ts) {
  check_ts_class(ts)
  attr(ts, "nodes")
}

#' Extract information about permanently remembered individuals
ts_samples <- function(ts) attr(ts, "sampling")

#' Infer spatio-temporal ancestral history for given nodes/individuals
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param x Either a character vector with individual names, or an integer
#'   vector of node IDs
#'
#' @export
ts_ancestors <- function(ts, x = NULL) {
  check_ts_class(ts)

  model <- attr(ts, "model")

  if (is.null(model$world))
    stop("Cannot process locations of ancestral nodes for non-spatial tree sequence data",
         call. = FALSE)

  edges <- ts_edges(ts)

  data <- ts_data(ts)

  ids <- get_node_ids(ts, x)

  # collect child-parent branches starting from the "focal nodes"
  branches <- purrr::map_dfr(ids, ~ collect_ancestors(.x, edges))

  child_data <- dplyr::select(data, name, ind_id, pop, node_id, time, location)
  parent_data <- dplyr::select(data, parent_pop = pop, parent_id = node_id, parent_time = time, parent_location = location)

  combined <- branches %>%
    dplyr::inner_join(child_data, by = c("child" = "node_id")) %>%
    dplyr::inner_join(parent_data, by = c("parent" = "parent_id")) %>%
    sf::st_as_sf()

  connections <- purrr::map2(
    combined$location, combined$parent_location, ~
      sf::st_union(.x, .y) %>%
      sf::st_cast("LINESTRING") %>%
      sf::st_sfc() %>%
      sf::st_sf(connection = ., crs = sf::st_crs(combined))) %>%
    dplyr::bind_rows()

  final <- dplyr::bind_cols(combined, connections) %>%
    sf::st_set_geometry("connection") %>%
    dplyr::select(name, pop, ind_id, focal_id, node_id = child, time, location,
                  level, parent_id = parent, parent_pop, parent_time,
                  parent_location, connection,
                  left_pos = left, right_pos = right) %>%
    dplyr::mutate(level = as.factor(level))

  attr(final, "model") <- model

  final
}

# tree operations ---------------------------------------------------------

#' Get a tree from a given tree sequence
#'
#' For more information about optional keyword arguments see tskit documentation:
#' <https://tskit.dev/tskit/docs/stable/python-api.html#the-treesequence-class>
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param i Position of the tree in the tree sequence. If \code{mode = "index"},
#'   an i-th tree will be returned (in one-based indexing), if \code{mode =
#'   "position"}, a tree covering an i-th base of the simulated genome will be
#'   returned.
#' @param ... Additional keyword arguments accepted by
#'   \code{tskit.TreeSequence.at and tskit.TreeSequence.at_index} methods
#'
#' @return Object of the type tskit.trees.Tree
#'
#' @export
ts_tree <- function(ts, i, mode = c("index", "position"), ...) {
  mode <- match.arg(mode)
  if (mode == "index")
    tree <- ts$at_index(index = i - 1, ...)
  else
    tree <- ts$at(position = i - 1, ...)
  tree
}

#' Plot a graphical representation of a single tree
#'
#' This function first obtains an SVG representation of the tree by calling the
#' \code{draw_svg} method of tskit and renders it as a bitmap image in R. All of
#' the many optional keyword arguments of the \code{draw_svg} method can be
#' provided and will be automatically passed to the method behind the scenes.
#'
#' @param x A single tree extracted by \code{\link{ts_tree}}
#' @param width,height Pixel dimensions of the rendered bitmap
#' @param labels Label each node with the individual name?
#' @param ts \code{pyslim.SlimTreeSequence} object of the class \code{slendr_ts}
#'   obtained by \code{link{ts_load}}, \code{link{ts_recapitate}},
#'   \code{link{ts_simplify}}, or \code{link{ts_mutate}}
#' @param ... Keyword arguments to the tskit \code{draw_svg} function.
#'
#' @export
ts_draw <- function(x, width = 1500, height = 500, labels = FALSE,
                    ts = NULL, ...) {
  if (labels) {
    if (inherits(x, "tskit.trees.Tree") & is.null(ts))
      stop("For plotting individual names, please provide the ",
           "original tree sequence object for annotation using ",
           "the `ts = ` argument to `ts_draw()", call. = FALSE)
    else if (inherits(x, "tskit.trees.TreeSequence"))
      ts <- x

    df_labels <- ts_data(ts) %>%
      dplyr::select(node_id, name) %>%
      dplyr::mutate(node_label = sprintf("%s (%s)", name, node_id),
                    node_label = ifelse(is.na(name), node_id, node_label))
    py_labels <- reticulate::py_dict(keys = df_labels$node_id,
                                     values = df_labels$node_label)
  } else
    py_labels <- NULL

  svg <- x$draw_svg(size = c(width, height), node_labels = py_labels, ...)

  # convert from a SVG representation to a PNG image
  raw <- charToRaw(svg)
  tmp_file <- paste0(tempfile(), ".png")
  rsvg::rsvg_png(svg = raw, file = tmp_file, width = width, height = height)

  # set margins to zero, save original settings
  orig_par <- par(mar = c(0, 0, 0, 0))

  # plot the PNG image, filling the entire plotting window
  img <- png::readPNG(tmp_file)
  plot.new()
  plot.window(0:1, 0:1)
  rasterImage(img, 0, 0, 1, 1)

  # restor original settings
  par(orig_par)
}

#' Check that all trees in the tree sequence are fully coalesced
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param return_failed Report back which trees failed the coalescence
#'   check?
#'
#' @return TRUE or FALSE value if \code{return_failed = FALSE}, otherwise a vector of
#'   (tskit Python 0-based) indices of trees which failed the coalescence test
#'
#' @export
ts_coalesced <- function(ts, return_failed = FALSE) {
  num_roots <- reticulate::iterate(ts$trees(), function(t) t$num_roots)
  if (all(num_roots == 1))
    return(TRUE)
  else if (return_failed)
    return(which(num_roots) - 1)
  else
    return(FALSE)
}

# f-statistics ------------------------------------------------------------

fstat <- function(ts, stat, sample_sets, mode, windows, span_normalise) {
  if (!stat %in% c("f2", "f3", "f4"))
    stop("Unknown statistic '", stat, "'", call. = FALSE)

  if (!is.null(windows)) windows <- define_windows(ts, windows)

  node_sets <- purrr::map(sample_sets, ~ get_node_ids(ts, .x))

  result <- ts[[stat]](sample_sets = node_sets, mode = mode,
                       span_normalise = TRUE, windows = windows)

  if (length(result) > 1) result <- list(result)
  result
}

#' @rdname ts_f4ratio
ts_f2 <- function(ts, A, B, mode = c("site", "branch", "node"),
                  span_normalise = TRUE, windows = NULL) {
  mode <- match.arg(mode)
  result <- fstat(ts, "f2", list(A, B), mode, windows, span_normalise)
  dplyr::tibble(A = concat(A), B = concat(B), f2 = result)
}

#' @rdname ts_f4ratio
ts_f3 <- function(ts, A, B, C, mode = c("site", "branch", "node"),
                  span_normalise = TRUE, windows = NULL) {
  mode <- match.arg(mode)
  result <- fstat(ts, "f3", list(A, B, C), mode, windows, span_normalise)
  dplyr::tibble(A = concat(A), B = concat(B), C = concat(C), f3 = result)
}

#' @rdname ts_f4ratio
ts_f4 <- function(ts, W, X, Y, Z, mode = c("site", "branch", "node"),
                  span_normalise = TRUE, windows = NULL) {
  mode <- match.arg(mode)
  result <- fstat(ts, "f4", list(W, X, Y, Z), mode, windows, span_normalise)
  dplyr::tibble(W = concat(W), X = concat(X), Y = concat(Y), Z = concat(Z),
                f4 = result)
}

#' Calculate the f2, f3, f4, and f4-ratio statistics
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param w,x,y,z,a,b,c,o Character vectors of  individual names (following the
#'   nomenclature of Patterson et al. 2021)
#' @param span_normalise Divide the result by the span of the window? Default
#'   TRUE, see the tskit documentation for more detail.
#'
#' @return Data frame with statistics calculated for given sets of individuals
#'
#' @export
ts_f4ratio <- function(ts, X, A, B, C, O, mode = c("site", "branch"), span_normalise = TRUE) {
  mode <- match.arg(mode)

  purrr::map_dfr(
    X, function(.x) {
      alpha <-
        ts_f4(ts, A, O, .x, C, mode = mode)$f4 /
        ts_f4(ts, A, O, B, C, mode = mode)$f4
      dplyr::tibble(X = .x, A = concat(A), B = concat(B),
                    C = concat(C), O = concat(O), alpha)
    }
  )
}

# multiway statistics -----------------------------------------------------

multiway_stat <- function(ts, stat = c("fst", "divergence"),
                          k, sample_sets, mode, windows, span_normalise) {
  stat <- match.arg(stat)
  node_sets <- purrr::map(sample_sets, function(set) {
    get_node_ids(ts, set)
  })

  n_sets <- length(sample_sets)

  # generate all pairwise indexes required by tskit for more than
  # two sample sets
  indexes <- combn(n_sets, m = k, simplify = FALSE,
                   FUN = function(x) as.integer(x - 1))

  fun <- switch(
    stat,
    "fst" = ts[["Fst"]],
    "divergence" = ts[["divergence"]]
  )
  if (is.null(fun))
    stop("Unknown statistic '", stat, "'", call. = FALSE)

  values <- fun(
    sample_sets = unname(node_sets),
    indexes = indexes,
    mode = mode,
    windows = windows,
    span_normalise = span_normalise
  )
  if (is.matrix(values))
    values <- split(values, col(values))

  if (is.null(names(sample_sets)))
    set_names <- paste0("set_", seq_len(n_sets))
  else
    set_names <- names(sample_sets)

  result <- purrr::map_dfr(indexes, ~ {
    set <- set_names[.x + 1]
    as.data.frame(t(matrix(set)), stringsAsFactors = FALSE)
  }) %>%
    dplyr::as_tibble() %>%
    dplyr::mutate(stat = values)

  result
}

#' Calculate pairwise statistics between sets of individuals
#'
#' For a discussion on the difference between "site", "branch", and "node"
#' options of the \code{mode} argument, please see the tskit documentation at
#' <https://tskit.dev/tskit/docs/stable/stats.html#sec-stats-mode>.
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param sample_sets A list (optionally a named list) of character vectors with
#'   individual names (one vector per set)
#' @param mode The mode for the calculation ("sites" or "branch")
#' @param windows Coordinates of breakpoints between windows. The first
#'   coordinate (0) and the last coordinate (equal to \code{ts$sequence_length})
#'   do not have to be specified as they are added automatically.
#' @param span_normalise Divide the result by the span of the window? Default
#'   TRUE, see the tskit documentation for more detail.
#'
#' @return For each pairwise calculation, either a single Fst value or a vector
#'   of Fst values (one for each window)
#'
#' @export
ts_fst <- function(ts, sample_sets, mode = c("site", "branch", "node"),
                   windows = NULL, span_normalise = TRUE) {
  mode <- match.arg(mode)
  if (!is.list(sample_sets)) sample_sets <- list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)
  multiway_stat(ts, "fst", k = 2, sample_sets, mode, windows, span_normalise) %>%
    setNames(c("x", "y", "Fst"))
}

#' Calculate pairwise divergence between sets of individuals
#'
#' @rdname ts_fst
#'
#' @return For each pairwise calculation, either a single divergence value or a
#'   vector of divergence values (one for each window)
#'
#' @export
ts_divergence <- function(ts, sample_sets, mode = c("site", "branch", "node"),
                   windows = NULL, span_normalise = TRUE) {
  mode <- match.arg(mode)
  if (!is.list(sample_sets)) sample_sets <- list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)
  multiway_stat(ts, "divergence", k = 2, sample_sets, mode, windows, span_normalise) %>%
    setNames(c("x", "y", "divergence"))
}

# oneway statistics -------------------------------------------------------

oneway_stat <- function(ts, stat, sample_sets, mode, windows, span_normalise = NULL) {
  node_sets <- purrr::map(sample_sets, function(set) {
    get_node_ids(ts, set)
  })

  n_sets <- length(sample_sets)

  fun <- switch(
    stat,
    "D" = ts[["Tajimas_D"]],
    "diversity" = ts[["diversity"]],
    "segsites" = ts[["segregating_sites"]]
  )
  if (is.null(fun))
    stop("Unknown statistic '", stat, "'", call. = FALSE)

  args <- list(sample_sets = unname(node_sets),
               mode = mode,
               windows = windows)
  if (!is.null(span_normalise)) args[["span_normalise"]] <- span_normalise

  values <- do.call(fun, args)

  if (is.matrix(values))
    values <- split(values, col(values))

  if (is.null(names(sample_sets)))
    set_names <- paste0("set_", seq_len(n_sets))
  else
    set_names <- names(sample_sets)

  result <- dplyr::tibble(set = set_names)
  result[[stat]] <- values
  result
}

#' Calculate the density of segregating sites for the given sets of individuals
#'
#' @inheritParams ts_tajima
#' @param span_normalise Divide the result by the span of the window? Default
#'   TRUE, see the tskit documentation for more detail.
#'
#' @return For each set of individuals either a single diversity value or a
#'   vector of diversity values (one for each window)
#'
#' @export
ts_segregating <- function(ts, sample_sets, mode = c("site", "branch", "node"),
                           windows = NULL, span_normalise = TRUE) {
  mode <- match.arg(mode)
  if (!is.list(sample_sets)) sample_sets <- list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)
  oneway_stat(ts, "segsites", sample_sets, mode, windows, span_normalise)
}

#' Calculate diversity in given sets of individuals
#'
#' @inheritParams ts_tajima
#' @param span_normalise Divide the result by the span of the window? Default
#'   TRUE, see the tskit documentation for more detail.
#'
#' @return For each set of individuals either a single diversity value or a
#'   vector of diversity values (one for each window)
#'
#' @export
ts_diversity <- function(ts, sample_sets, mode = c("site", "branch", "node"),
                         windows = NULL, span_normalise = TRUE) {
  mode <- match.arg(mode)
  if (!is.list(sample_sets)) sample_sets <- list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)
  oneway_stat(ts, "diversity", sample_sets, mode, windows, span_normalise)
}

#' Calculate Tajima's D for given sets of individuals
#'
#' For a discussion on the difference between "site" and "branch" options of the
#' \code{mode} argument, please see the tskit documentation at
#' <https://tskit.dev/tskit/docs/stable/stats.html#sec-stats-mode>
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param sample_sets A list (optionally a named list) of character vectors with
#'   individual names (one vector per set)
#' @param mode The mode for the calculation ("sites" or "branch")
#' @param windows Coordinates of breakpoints between windows. The first
#'   coordinate (0) and the last coordinate (equal to \code{ts$sequence_length})
#'   are added automatically)
#'
#' @return For each set of individuals either a single Tajima's D value or a
#'   vector of Tajima's D values (one for each window)
#'
#' @export
ts_tajima <- function(ts, sample_sets, mode = c("site", "branch", "node"),
                      windows = NULL) {
  mode <- match.arg(mode)
  if (!is.list(sample_sets)) sample_sets <- list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)
  oneway_stat(ts, "D", sample_sets, mode, windows)
}

# other statistics --------------------------------------------------------

#' Compute the allele frequency spectrum (AFS)
#'
#' This function computes the AFS with respect to the given set of individuals
#'
#' For more information on the format of the result and dimensions, in
#' particular the interpretation of the first and the last element of the AFS,
#' please see the tskit manual at
#' <https://tskit.dev/tskit/docs/stable/tutorial.html#sec-tutorial-afs-zeroth-entry>
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param sample_sets A list (optionally a named list) of character vectors with
#'   individual names (one vector per set). If NULL, allele frequency spectrum
#'   for all individuals in the tree sequence will be computed.
#' @param mode The mode for the calculation ("sites" or "branch")
#' @param windows Coordinates of breakpoints between windows. The first
#'   coordinate (0) and the last coordinate (equal to \code{ts$sequence_length})
#'   are added automatically)
#' @param polarised When FALSE (the default) the allele frequency spectrum will
#'   be folded (i.e. the counts will not depend on knowing which allele is
#'   ancestral)
#'
#' @return Either a single Fst value or a vector of Fst values (one for each
#'   window)
#'
#' @export
ts_afs <- function(ts, sample_sets = NULL, mode = c("site", "branch", "node"),
                   windows = NULL, span_normalise = TRUE,
                   polarised = FALSE) {
  mode <- match.arg(mode)
  if (is.null(sample_sets))
    sample_sets <- list(ts_individuals(ts)$name)
  else if (!is.list(sample_sets))
    sample_sets <- list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)

  node_sets <- purrr::map(sample_sets, function(set) {
    get_node_ids(ts, set)
  })

  result <- ts$allele_frequency_spectrum(
    sample_sets = unname(node_sets),
    mode = mode,
    windows = windows,
    span_normalise = span_normalise,
    polarised = polarised
  )

  result
}


# private tree sequence utility functions ---------------------------------

# Function for extracting numerical node IDs for various statistics
get_node_ids <- function(ts, x) {
  if (is.null(x)) {
    ts_data(ts, remembered = TRUE) %>%
      .$node_id %>%
      return()
  } else if (is.numeric(x)) {
    return(x)
  } else if (is.character(x)) {
    ts_data(ts, remembered = TRUE) %>%
      dplyr::filter(name %in% x) %>%
      .$node_id %>%
      return()
  } else
    stop("Unknown data given as individual names or node IDs", call. = FALSE)
}

# Extract information from the nodes table
get_ts_nodes <- function(ts) {
  table <- ts$tables$nodes
  dplyr::tibble(
    node_id = as.integer(seq_len(table$num_rows) - 1),
    time = table$time,
    ind_id = ifelse(table$individual == -1, NA, table$individual),
    pop_id = as.integer(table$population)
  )
}

# Extract information from the table of individual table
get_ts_individuals <- function(ts) {
  table <- ts$tables$individuals

  # pedigree_id is available as binary metadata encoded in the table of
  # individuals but I have no clue at the moment how decode it directly in R --
  # for now I'm parsing it in Python via reticulate is pretty ugly (but
  # reasonably fast)
  tmp_var <- paste0("ts_py_object_", paste(sample(LETTERS, 20, TRUE), collapse = ""))
  # reticulate doesn't seem to be able to expose non-global objects :(
  assign(tmp_var, ts, envir = globalenv())
  pedigree_ids <- reticulate::py_run_string(sprintf("pedigree_ids = [ind.metadata['pedigree_id'] for ind in r.%s.tables.individuals]", tmp_var))$pedigree_ids
  on.exit(rm(list = tmp_var, envir = globalenv()), add = TRUE)

  dplyr::tibble(
    ind_id = seq_len(table$num_rows) - 1,
    pedigree_id = pedigree_ids,
    time = ts$individual_times,
    raster_x = ts$individual_locations[, 1],
    raster_y = ts$individual_locations[, 2],
    pop_id = ts$individual_populations,
    alive = bitwAnd(table[["flags"]], pyslim$INDIVIDUAL_ALIVE) != 0,
    remembered = bitwAnd(table[["flags"]], pyslim$INDIVIDUAL_REMEMBERED) != 0,
    retained = bitwAnd(table[["flags"]], pyslim$INDIVIDUAL_RETAINED) != 0
  )
}

# Extract information from the edges table
get_ts_edges <- function(ts) {
  table <- ts$tables$edges
  dplyr::tibble(
    id = seq_len(table$num_rows) - 1,
    child = as.vector(table[["child"]]),
    parent = as.vector(table[["parent"]]),
    left = as.vector(table[["left"]]),
    right = as.vector(table[["right"]])
  )
}

get_table_data <- function(ts, model, spatial, simplify_to = NULL) {
  # get data from the original individual table
  individuals <- get_ts_individuals(ts) %>%
    dplyr::mutate(time = convert_slim_time(time, model),
                  pop = model$splits$pop[pop_id + 1]) %>%
    dplyr::arrange(-time, pop)

  # load information about samples at times and from populations of remembered
  # individuals
  samples <- get_sampling(ts) %>% dplyr::arrange(-time, pop)
  if (!is.null(simplify_to))
    samples <- samples %>% dplyr::filter(name %in% simplify_to)

  # split individuals into remembered (those explicitly sampled, to which we
  # will add readable names from the sampling schedule table) and not remembered
  # anonymous individuals
  remembered <- dplyr::filter(individuals, remembered) %>%
    dplyr::select(-time, -pop) %>%
    dplyr::bind_cols(samples)

  not_remembered <- dplyr::filter(individuals, !remembered)

  # get data from the original nodes table to get node assignments for each
  # individual but also nodes which are not associated with any individuals
  # (i.e. those added through recapitation by msprime)
  nodes <- get_ts_nodes(ts) %>% dplyr::mutate(time = convert_slim_time(time, model))

  # add numeric node IDs to each individual
  combined <-
    dplyr::bind_rows(remembered, not_remembered) %>%
    dplyr::right_join(nodes, by = "ind_id") %>%
    dplyr::mutate(time = ifelse(is.na(ind_id), time.y, time.x))

  if (spatial) {
    combined <- convert_to_sf(combined, model)
    location_cols <- "location"
  } else
    location_cols <- NULL

  combined <- dplyr::select(
    combined, name, pop, ind_id, node_id, time, !!location_cols,
    remembered, retained, alive, pedigree_id
  )

  combined
}

get_sampling <- function(ts) {
  ts$metadata$SLiM$user_metadata$sampling %>%
    purrr::transpose() %>%
    dplyr::as_tibble() %>%
    tidyr::unnest(cols = c("n", "pop", "time", "time_gen", "time_orig")) %>%
    dplyr::select(-time, -time_gen) %>%
    {
      rbind(
        dplyr::filter(., n == 1),
        dplyr::filter(., n > 1) %>% .[rep(seq_len(nrow(.)), .$n), ]
      )
    } %>%
    dplyr::group_by(pop) %>%
    dplyr::mutate(name = paste0(pop, 1:dplyr::n())) %>%
    dplyr::ungroup() %>%
    dplyr::arrange(-time_orig, pop) %>%
    dplyr::rename(time = time_orig) %>%
    dplyr::select(name, time, pop)
}

check_ts_class <- function(x) {
  if (!inherits(x, "slendr_ts"))
    stop("Not a tree sequence object created by ts_load, ts_simplify, ts_recapitate or ts_mutate", call. = FALSE)
}

# Collect all ancestors of a given node up to the root by traversing the tree
# edges "bottom-up" using a queue
collect_ancestors <- function(node_id, edges) {
  # list for collecting paths (i.e. sets of edges) leading from the focal node
  # to the root
  result <- list()

  # initialize the counter of nodes already processed by the queue
  n_nodes <- length(unique(c(edges$child, edges$parent)))
  processed_nodes <- vector(length = n_nodes + 1)

  # initialize the queue with all edges leading from the focal node
  edge <- edges[edges$child %in% node_id, ] %>% dplyr::mutate(level = 1)
  queue <- split(edge, edge$child)

  # repeat until the queue is empty (this homebrew queue implementation is
  # probably horribly inefficient but it will do for now)
  while (TRUE) {
    # pop out the first element
    item <- queue[[1]]; queue[[1]] <- NULL

    # add it to the final list
    result <- append(result, list(item))

    # iterate over all parents of the current node
    for (parent in split(item, item$parent)) {
      # get edges leading from the current parent to its own parent
      edge <- edges[edges$child == unique(parent$parent), ]

      # if the parent has no parent itself or its node has already been
      # processed, skip it and don't add it to the queue
      if (nrow(edge) == 0) next
      if (processed_nodes[unique(edge$child) + 1]) next

      # mark the node as processed...
      processed_nodes[unique(edge$child) + 1] <- TRUE
      # ... and add it to the queue
      edge$level <- item$level[1] + 1
      queue[[length(queue) + 1]] <- edge
    }

    if (length(queue) == 0) break
  }

  result <- dplyr::bind_rows(result) %>% dplyr::mutate(focal_id = node_id)
  result
}

# Convert a data frame of information extracted from a tree sequence
# table to an sf spatial object
convert_to_sf <- function(df, model) {
  crs <- sf::st_crs(model$world)

  with_locations <- df[complete.cases(df[, c("raster_x", "raster_y")]), ]
  without_locations <- df[!complete.cases(df[, c("raster_x", "raster_y")]), ]

  # reproject coordinates to the original crs
  if (has_crs(model$world)) {
    with_locations <- reproject(
      from = "raster", to = crs, coords = with_locations, model = model,
      input_prefix = "raster_", output_prefix = "", add = TRUE
    )
  } else {
    with_locations$x <- with_locations$raster_x
    with_locations$y <- with_locations$raster_y
  }

  result <- sf::st_as_sf(with_locations,
                         coords = c("x", "y"),
                         crs = crs) %>%
    dplyr::rename(location = geometry)

  # directly binding with without_locations which has no rows lead to an error:
  # 'Error: Assigned data `x[[all_sfc_columns[i]]]` must be compatible with
  # existing data.' (similar issue reported here:
  # https://github.com/mtennekes/tmap/issues/551)
  if (nrow(without_locations))
    result <- dplyr::bind_rows(result, without_locations)

  result
}

define_windows <- function(ts, breakpoints) {
  unique(c(0, breakpoints, ts$sequence_length))
}

concat <- function(x) {
  paste(x, collapse = "+")
}