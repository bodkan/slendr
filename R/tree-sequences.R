# tree sequence processing ------------------------------------------------

#' Load a tree sequence file produced by a given model
#'
#' This function loads a tree sequence file simulated from a given slendr model.
#' Optionally, the tree sequence can be recapitated and simplified.
#'
#' The loading, recapitation and simplification is performed using the Python
#' module pyslim which serves as a link between tree sequences generated by SLiM
#' and the tskit module for manipulation of tree sequence data. All of these
#' steps have been modelled after the official pyslim tutorial and documentation
#' available at: <https://tskit.dev/pyslim/docs/latest/tutorial.html>.
#'
#' The recapitation and simplification steps can also be performed individually
#' using the functions \code{\link{ts_recapitate}} and
#' \code{\link{ts_simplify}}.
#'
#' @param model Compiled \code{slendr_model} model object
#' @param file A path to the tree sequence file generated by the model
#' @param recapitate Should the tree sequence be recapitated?
#' @param simplify Should the tree sequence be simplified down to only
#'   remembered (i.e. "sampled", in \emph{slendr} parlance) individuals?
#' @param mutate Should the tree sequence be mutated?
#' @param spatial Should spatial information encoded in the tree sequence data
#'   be converted to spatial R datastructures? If FALSE, pixel-based
#'   raster-dimensions will not be converted to the coordinate reference system
#'   implied by the model. If TRUE (default), reprojection of coordinates will
#'   be performed. If the model was non-spatial, the value of this parameter is
#'   disregarded.
#' @param recombination_rate,Ne Arguments passed to \code{ts_recapitate}
#' @param mutation_rate Mutation rate passed to \code{ts_mutate}
#' @param random_seed Random seed passed to pyslim's \code{recapitate} method
#' @param simplify_to A character vector of individual names. If NULL, all
#'   remembered individuals will be retained. Only used when \code{simplify =
#'   TRUE}.
#' @param keep_input_roots Should the history ancestral to the MRCA of all
#' samplbee retained in the tree sequence? Default is \code{FALSE}.
#' @param migration_matrix Migration matrix used for coalescence of ancient lineages
#'   (passed to \code{ts_recapitate})
#'
#' @return \code{pyslim.SlimTreeSequence} object of the class \code{slendr_ts}
#'
#' @seealso \code{\link{ts_data}} for extracting useful information about
#'   individuals, nodes, coalescent times and geospatial locations of nodes on a
#'   map
#'
#' @examples
#' \dontrun{
#' # load tree sequence from its default location in a model directory
#' ts <- ts_load(model)
#'
#' # load tree sequence from its default location in a model directory
#' ts <- ts_load(model, file = "/path/to/tree/sequence/output.trees")
#'
#' # load tree sequence and immediately simplify it only to sampled individuals
#' ts <- ts_load(model, simplify = TRUE)
#'
#' # load tree sequence and simplify it to a subset of sampled individuals
#' ts_small <- ts_simplify(ts, simplify_to = c("CH_1", "NEA_1", "NEA_2",
#'                                             "AFR_1", "AFR_2", "EUR_20", "EUR_50"))
#'
#' # load tree sequence, recapitate it and simplify it
#' ts <- ts_load(model, recapitate = TRUE, simplify = TRUE,
#'               recombination_rate = 1e-8, Ne = 10000)
#'
#' # load tree sequence, recapitate it, simplify it and overlay neutral mutations
#' ts <- ts_load(model, recapitate = TRUE, simplify = TRUE, random_seed = 42,
#'               recombination_rate = 1e-8, Ne = 10000, mutation_rate = 1e-8)
#' }
#'
#' @export
ts_load <- function(model, file = NULL,
                    recapitate = FALSE, simplify = FALSE, mutate = FALSE,
                    spatial = TRUE, recombination_rate = NULL, mutation_rate = NULL,
                    Ne = NULL, random_seed = NULL, simplify_to = NULL, keep_input_roots = FALSE,
                    migration_matrix = NULL) {
  if (is.null(model$world)) spatial <- FALSE

  if (recapitate && (is.null(recombination_rate) || is.null(Ne)))
    stop("Recombination rate and Ne must be specified for recapitation", call. = FALSE)

  if (mutate && is.null(mutation_rate))
    stop("Mutation rate must be given in order to be able to mutate the tree sequence",
         call. = FALSE)

  if (!inherits(model, "slendr_model"))
    stop("A compiled slendr model object must be provided", call. = FALSE)

  if (is.null(file)) {
    ts_files <- list.files(model$path, pattern = "_(msprime|slim)\\.trees$", full.names = TRUE)
    if (length(ts_files) == 1)
      file <- ts_files
    else if (length(ts_files) > 1) {
      stop("Multiple tree sequence files found in the model directory:\n",
              paste(ts_files, collapse = "\n"),
              "\n\nPlease use the `file = ` argument of `ts_load()` to specify ",
              "which tree sequence should be loaded.", call. = FALSE)
    }
  }

  # decide which tree sequence (SLiM or msprime) to load
  if (grepl("_slim\\.trees", file)) {
    ts <- pyslim$load(path.expand(file))
    backend <- "slim"
  } else if (grepl("_msprime\\.trees", file)) {
    ts <- tskit$load(path.expand(file))
    backend <- "msprime"
  } else
    stop("Unknown tree sequence slendr output file '", file, "'", call. = FALSE)

  attr(ts, "source") <- backend

  attr(ts, "model") <- model
  attr(ts, "metadata") <- get_metadata(ts)

  attr(ts, "recapitated") <- FALSE
  attr(ts, "simplified") <- FALSE
  attr(ts, "mutated") <- FALSE

  class(ts) <- c("slendr_ts", class(ts))

  # process tree sequence tables only in case recapitation and simplification
  # are not to be performed during loading (this avoids computing data that
  # would be overwritten immediately after)
  if (!recapitate && !simplify) {
    attr(ts, "nodes") <- get_ts_nodes(ts)
    attr(ts, "edges") <- get_ts_edges(ts)
    attr(ts, "individuals") <- get_ts_individuals(ts)

    if (backend == "slim")
      attr(ts, "data") <- get_slim_table_data(ts, model, spatial)
    else
      attr(ts, "data") <- get_msprime_table_data(ts, model)
  }

  if (recapitate)
    ts <- ts_recapitate(ts, recombination_rate = recombination_rate, Ne = Ne,
                        random_seed = random_seed, spatial = spatial,
                        migration_matrix = migration_matrix)

  if (simplify)
    ts <- ts_simplify(ts, simplify_to, spatial = spatial, keep_input_roots = keep_input_roots)

  if (mutate)
    ts <- ts_mutate(ts, mutation_rate = mutation_rate, random_seed = random_seed)

  ts
}

#' Save a tree sequence to a file
#'
#' @param ts \code{pyslim.SlimTreeSequence} object loaded by \code{ts_load}
#' @param file File to which the tree sequence should be saved
#'
#' @export
ts_save <- function(ts, file) {
  check_ts_class(ts)
  ts$dump(file)
}


#' Recapitate the tree sequence
#'
#' @param ts \code{pyslim.SlimTreeSequence} object loaded by \code{ts_load}
#' @param recombination_rate A constant value of the recombination rate
#' @param Ne Effective population size during the recapitation process
#' @param spatial Should spatial information encoded in the tree sequence data
#'   be converted to spatial R data structures? If FALSE, pixel-based
#'   raster-dimensions will not be converted to the coordinate reference system
#'   implied by the model. If TRUE (default), reprojection of coordinates will
#'   be performed. If the model was non-spatial, the value of this parameter is
#'   disregarded.
#' @param migration_matrix Migration matrix used for coalescence of ancient lineages
#'   (passed to \code{ts_recapitate})
#' @param random_seed Random seed passed to pyslim's \code{recapitate} method
#'
#' @return \code{pyslim.SlimTreeSequence} object of the class \code{slendr_ts}
#'
#' @seealso \code{\link{ts_data}} for extracting useful information about
#'   individuals, nodes, coalescent times and geospatial locations of nodes on a
#'   map
#'
#' @examples
#' \dontrun{
#' ts_rec <- ts_recapitate(ts, recombination_rate = 1e-8, Ne = 10000, random_seed = 42)
#' }
#'
#' @export
ts_recapitate <- function(ts, recombination_rate, Ne, spatial = TRUE,
                          migration_matrix = NULL, random_seed = NULL) {
  check_ts_class(ts)

  if (attr(ts, "source") != "slim")
    warning("There is no need to recapitate an already coalesced msprime tree sequence",
            call. = FALSE)

  model <- attr(ts, "model")

  if (is.null(model$world)) spatial <- FALSE

  # suppress pyslim warning until we figure out how to switch to the new
  # pyslim.recapitate(ts, ...) method
  reticulate::py_capture_output(
    ts_new <- ts$recapitate(recombination_rate = recombination_rate, Ne = Ne,
                            random_seed = random_seed, migration_matrix = migration_matrix)
  )

  attr(ts_new, "model") <- model
  attr(ts_new, "metadata") <- attr(ts, "metadata")

  attr(ts_new, "recapitated") <- TRUE
  attr(ts_new, "simplified") <- attr(ts, "simplified")
  attr(ts_new, "mutated") <- attr(ts, "mutated")

  attr(ts_new, "nodes") <- get_ts_nodes(ts_new)
  attr(ts_new, "edges") <- get_ts_edges(ts_new)
  attr(ts_new, "individuals") <- get_ts_individuals(ts_new)

  attr(ts_new, "data") <- get_slim_table_data(ts_new, model, spatial)

  class(ts_new) <- c("slendr_ts", class(ts_new))

  ts_new
}

#' Simplify the tree sequence down to a given set of individuals
#'
#' This function is a convenience wrapper around the \code{simplify} method
#' implemented in tskit, designed to work on tree sequence data simulated by
#' SLiM using the \pkg{slendr} R package.
#'
#' The simplification process is used to remove redundant information from the
#' tree sequence and retains only information necessary to describe the
#' genealogical history of a set of samples.
#'
#' For more information on how simplification works in pyslim and tskit, see the
#' official documentation at
#' <https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.simplify>
#' and
#' <https://tskit.dev/pyslim/docs/latest/tutorial.html#simplification>.
#'
#' A very clear description of the difference between remembering and retaining
#' and how to use these techniques to implement historical individuals (i.e.
#' ancient DNA samples) is in the pyslim documentation at
#' <https://tskit.dev/pyslim/docs/latest/tutorial.html#historical-individuals>.
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param simplify_to A character vector of individual names. If NULL, all
#'   explicitly remembered individuals (i.e. those specified via the
#'   \code{\link{sampling}} function will be left in the tree sequence after the
#'   simplification.
#' @param spatial Should spatial information encoded in the tree sequence data
#'   be converted to spatial R datastructures? If FALSE, pixel-based
#'   raster-dimensions will not be converted to the coordinate reference system
#'   implied by the model. If TRUE (default), reprojection of coordinates will
#'   be performed. If the model was non-spatial, the value of this parameter is
#'   disregarded.
#' @param keep_input_roots Should the history ancestral to the MRCA of all
#' samplbee retained in the tree sequence? Default is \code{FALSE}.
#'
#' @return \code{pyslim.SlimTreeSequence} object of the class \code{slendr_ts}
#'
#' @seealso \code{\link{ts_data}} for extracting useful information about
#'   individuals, nodes, coalescent times and geospatial locations of nodes on a
#'   map
#'
#' @examples
#' \dontrun{ # simplify tree sequence to sampled individuals
#' ts_simplified <- ts_simplify(ts)
#'
#' # simplify to a subset of sampled individuals
#' ts_small <- ts_simplify(
#'   ts,
#'   simplify_to = c("CH_1", "NEA_1", "NEA_2", "AFR_1",
#'                   "AFR_2", "EUR_20", "EUR_50")
#' )
#' }
#'
#' @export
ts_simplify <- function(ts, simplify_to = NULL, spatial = TRUE, keep_input_roots = FALSE) {
  check_ts_class(ts)

  if (!attr(ts, "recapitated") && !keep_input_roots && !ts_coalesced(ts))
    warning("Simplifying a non-recapitated tree sequence. Make sure this is what you really want",
            call. = FALSE)

  model <- attr(ts, "model")
  if (is.null(model$world)) spatial <- FALSE

  data <- attr(ts, "data")
  # table data was not processed yet (i.e. simplification is being performed
  # during loading of the tree sequence data)
  if (is.null(data))
    data <- get_slim_table_data(ts, model, spatial)

  if (is.null(simplify_to))
    samples <- dplyr::filter(data, remembered)$node_id
  else if (!all(simplify_to %in% data$name))
      stop("The following individuals are not present in the tree sequence: ",
           paste0(simplify_to[!simplify_to %in% data$name], collapse = ", "),
           call. = FALSE)
  else
    samples <- dplyr::filter(data, name %in% simplify_to)$node_id

  ts_new <- ts$simplify(as.integer(samples),
                        filter_populations = FALSE,
                        keep_input_roots = keep_input_roots)

  # get the name and location from the original table with the pedigree_id key
  cols <- c("pedigree_id", "pop", "name")
  if (spatial) cols <- c(cols, "location")
  # we need to deduplicate the rows because the table is stored in a long format
  # (but we removed the node_id column which each diploid individual has two
  # values of)
  keep_data <- data[, cols] %>%
    dplyr::filter(!duplicated(pedigree_id))

  # get node IDs of individuals present in the simplified tree sequence
  # (sort by individual ID and time)
  nodes_new <- get_ts_nodes(ts_new) %>%
    dplyr::arrange(ind_id, time) %>%
    dplyr::select(node_id, ind_id) %>%
    .$node_id

  location_col <- if (spatial) "location" else NULL

  attr(ts_new, "model") <- model
  attr(ts_new, "metadata") <- attr(ts, "metadata")

  # get other data about individuals in the simplified tree sequence, sort them
  # also by their IDs and times, and add their node IDs extracted above
  # (this works because we sorted both in the same way)
  data_new <- get_slim_table_data(ts_new, model, spatial, simplify_to) %>%
    as.data.frame() %>%
    dplyr::arrange(ind_id, time) %>%
    dplyr::select(ind_id, pedigree_id, time, alive, remembered, retained) %>%
    dplyr::inner_join(keep_data, by = "pedigree_id") %>%
    dplyr::mutate(node_id = nodes_new) %>%
    dplyr::as_tibble()

  if (spatial)
    data_new <- sf::st_as_sf(data_new, crs = sf::st_crs(data))

  attr(ts_new, "recapitated") <- attr(ts, "recapitated")
  attr(ts_new, "simplified") <- TRUE
  attr(ts_new, "mutated") <- attr(ts, "mutated")

  attr(ts_new, "nodes") <- get_ts_nodes(ts_new)
  attr(ts_new, "edges") <- get_ts_edges(ts_new)
  attr(ts_new, "individuals") <- get_ts_individuals(ts_new)

  attr(ts_new, "data") <- data_new[, c("name", "pop", "ind_id", "node_id",
                                       "time", location_col, "remembered",
                                       "retained", "alive", "pedigree_id")]

  class(ts_new) <- c("slendr_ts", class(ts_new))

  ts_new
}

#' Add mutations to the given tree sequence
#'
#' @param ts Object of the type \code{pyslim.SlimTreeSequence}
#' @param mutation_rate Mutation rate used by msprime to simulate mutations
#' @param random_seed Random seed passed to msprime's \code{mutate} method
#' @param keep_existing Keep existing mutations?
#' @param mut_type Assign SLiM mutation type to neutral mutations? If
#'   \code{NULL} (default), no special mutation type will be used. If an
#'   integer number is given, mutations of the SLiM mutation type with that
#'   integer identifier will be created.
#'
#' @return \code{pyslim.SlimTreeSequence} object of the class \code{slendr_ts}
#'
#' @seealso \code{\link{ts_data}} for extracting useful information about
#'   individuals, nodes, coalescent times and geospatial locations of nodes on a
#'   map
#'
#' @examples
#' \dontrun{
#' ts_mutate <- ts_mutate(ts, mutation_rate = 1e-8, random_seed = 42)
#' }
#'
#' @export
ts_mutate <- function(ts, mutation_rate, random_seed = NULL,
                      keep_existing = TRUE, mut_type = NULL) {
  check_ts_class(ts)
  if (attr(ts, "mutated")) stop("Tree sequence already mutated", call. = FALSE)

  if (is.numeric(mut_type))
    mut_type <- msp$SLiMMutationModel(type = as.integer(mut_type))

  ts_new <-
    msp$sim_mutations(
      ts,
      rate = mutation_rate,
      model = mut_type,
      keep = keep_existing,
      random_seed = random_seed
    ) %>%
    pyslim$SlimTreeSequence()

  attr(ts_new, "model") <- attr(ts, "model")
  attr(ts_new, "metadata") <- attr(ts, "metadata")

  attr(ts_new, "recapitated") <- attr(ts, "recapitated")
  attr(ts_new, "simplified") <- attr(ts, "simplified")
  attr(ts_new, "mutated") <- TRUE

  attr(ts_new, "nodes") <- attr(ts, "nodes")
  attr(ts_new, "edges") <- attr(ts, "edges")
  attr(ts_new, "individuals") <- attr(ts, "individuals")

  attr(ts_new, "data") <- attr(ts, "data")

  class(ts_new) <- c("slendr_ts", class(ts_new))

  ts_new
}

#' Extract list with tree sequence metadata saved by SLiM
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#'
#' @return List of metadata fields extracted from the tree sequence object
#'
#' @export
ts_metadata <- function(ts) {
  check_ts_class(ts)
  attr(ts, "metadata")
}

# genotype conversion -----------------------------------------------------

#' Extract genotype table from the tree sequence
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#'
#' @return Data frame object of the class \code{tibble}
#'
#' @export
ts_genotypes <- function(ts) {
  if (!attr(ts, "mutated"))
    stop("Extracting genotypes from a tree sequence which has not been mutated",
         call. = FALSE)

  data <- ts_data(ts)

  gts <- ts$genotype_matrix()
  positions <- ts$tables$sites$position

  biallelic_pos <- get_biallelic_indices(ts)
  n_multiallelic <- sum(!biallelic_pos)

  if (n_multiallelic > 0) {
    message(sprintf("%i multiallelic sites (%.3f%% out of %i total) detected and removed",
                    n_multiallelic, n_multiallelic / length(positions) * 100,
                    length(positions)))
    gts <- gts[biallelic_pos, ]
    positions <- positions[biallelic_pos]
  }

  chromosomes <- ts_data(ts, remembered = TRUE) %>%
    dplyr::as_tibble() %>%
    dplyr::mutate(chr_name = sprintf("%s_chr%i", name, 1:2)) %>%
    dplyr::select(chr_name, node_id) %>%
    dplyr::arrange(node_id)

  colnames(gts) <- chromosomes$chr_name

  dplyr::as_tibble(gts) %>%
    dplyr::mutate(pos = as.integer(positions)) %>%
    dplyr::select(pos, dplyr::everything())
}

#' Extract genotypes from the tree sequence in the EIGENSTRAT format
#'
#' EIGENSTRAT data produced by this function can be used by the admixr R package
#' (<https://bodkan.net/admixr/>).
#'
#' In case an outgroup was not formally specified in a slendr model which
#' generated the tree sequence data, it is possible to artificially create an
#' outgroup sample with the name specified by the \code{outgroup} argument,
#' which will carry all ancestral alleles (i.e. value "2" in a geno file
#' for each position in a snp file).
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param prefix EIGENSTRAT trio prefix
#' @param chrom The name of the chromosome in the EIGENSTRAT snp file
#'   (default "chr1")
#' @param outgroup Should a formal, artificial outgroup be added? If \code{NULL}
#'   (default), no outgroup is added. A non-NULL character name will serve as
#'   the name of the outgroup in an ind file.
#'
#' @return Object of the class EIGENSTRAT created by the admixr package
#'
#' @examples
#' \dontrun{ # save genotypes as a trio of files eigenprefix.snp, eigenprefix.ind, eigenprefix.geno
#' ts_eigenstrat(ts, prefix = "/path/to/eigenprefix")
#' }
#'
#' @export
ts_eigenstrat <- function(ts, prefix, chrom = "chr1", outgroup = NULL) {
  if (!"admixr" %in% utils::installed.packages()[, 1])
    message("For EIGENSTRAT conversion, please install the R package ",
            "admixr by calling `install.packages(\"admixr\")")

  if (!attr(ts, "recapitated") && !ts_coalesced(ts))
    stop("Tree sequence was not recapitated and some nodes do not ",
         "have parents over some portion of their genome. This is interpreted as ",
         "missing data, which is not currently supported. For more context, take ",
         "a look at <https://github.com/tskit-dev/tskit/issues/301#issuecomment-520990038>.",
         call. = FALSE)

  if (!attr(ts, "mutated"))
    stop("Attempting to extract genotypes from a tree sequence which has not been mutated",
         call. = FALSE)

  chrom_genotypes <- ts_genotypes(ts)
  chr1_genotypes <- dplyr::select(chrom_genotypes, dplyr::ends_with("_chr1"))
  chr2_genotypes <- dplyr::select(chrom_genotypes, dplyr::ends_with("_chr2"))

  # create a geno file table
  geno <- dplyr::as_tibble(2 - (chr1_genotypes + chr2_genotypes))
  individuals <- gsub("_chr.", "", colnames(geno))
  colnames(geno) <- individuals

  # create an ind file table
  ind <- dplyr::tibble(id = individuals, sex = "U", label = individuals)

  # create a snp file table
  positions <- chrom_genotypes$pos
  snp <- dplyr::tibble(
    id = sprintf("%s_%s", chrom, as.character(positions)),
    chrom = chrom,
    gen = 0.0,
    pos = positions,
    ref = "G",
    alt = "T"
  )

  # add an artificial outgroup individual carrying ancestral alleles only
  if (!is.null(outgroup)) {
    geno[[as.character(outgroup)]] <- 2
    ind <- data.frame(
      id = as.character(outgroup),
      sex = "U",
      label = as.character(outgroup)
    ) %>%
        dplyr::bind_rows(ind, .)
  }

  # save the EIGENSTRAT trio
  if (!dir.exists(dirname(prefix))) dir.create(dirname(prefix))
  admixr::write_geno(geno, paste0(prefix, ".geno"))
  admixr::write_snp(snp, paste0(prefix, ".snp"))
  admixr::write_ind(ind, paste0(prefix, ".ind"))

  # return the admixr eigenstrat object
  admixr::eigenstrat(prefix = prefix)
}

#' Save genotypes from the tree sequenceas a VCF file
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param path Path to a VCF file
#' @param chrom Chromosome name to be written in the CHROM column of the VCF
#' @param individuals A character vector of individuals in the tree sequence. If
#'   missing, all individuals present in the tree sequence will be saved.
#'
#' @examples
#' \dontrun{ # save a VCF file from a given tree sequence object ts
#' ts_vcf(ts, path = "/path/to/target/output.vcf.gz")
#' }
#'
#' @export
ts_vcf <- function(ts, path, chrom = NULL, individuals = NULL) {
  if (!attr(ts, "recapitated") && !ts_coalesced(ts))
    stop("Tree sequence was not recapitated and some nodes do not ",
         "have parents over some portion of their genome. This is interpreted as ",
         "missing data, which is not currently supported by tskit. For more context, ",
         "take a look at <https://github.com/tskit-dev/tskit/issues/301#issuecomment-520990038>.",
         call. = FALSE)

  if (!attr(ts, "mutated"))
    warning("Attempting to extract genotypes from a tree sequence which has not been mutated",
            call. = FALSE)

  data <- ts_data(ts, remembered = TRUE) %>%
    dplyr::as_tibble() %>%
    dplyr::distinct(name, ind_id)

  if (is.null(individuals)) individuals <- data$name

  present <- individuals %in% unique(data$name)
  if (!all(present))
    stop("", paste(individuals[!present], collapse = ", "),
         " not present in the tree sequence", call. = FALSE)

  gzip <- reticulate::import("gzip")
  with(reticulate::`%as%`(gzip$open(path.expand(path), "wt"), vcf_file), {
    ts$write_vcf(vcf_file,
                 contig_id = chrom,
                 individuals = as.integer(data$ind_id),
                 individual_names = data$name)
  })
}


# tree sequence tables ----------------------------------------------------

#' Extract combined annotated table of individuals and nodes
#'
#' This function combines information from the table of individuals and table of
#' nodes into a single data frame which can be used in downstream analyses.
#'
#' The source of data (tables of individuals and nodes recorded in the tree
#' sequence generated by SLiM) are combined into a single data frame. If the
#' model which generated the data was spatial, coordinates of nodes (which are
#' pixel-based by default because SLiM spatial simulations occur on a raster),
#' the coordinates are automatically converted to an explicit spatial object of
#' the \code{sf} class unless \code{spatial = FALSE}. See
#' <https://r-spatial.github.io/sf/> for an extensive introduction to the sf
#' package and the ways in which spatial data can be processed, analysed, and
#' visualised.
#'
#' @seealso \code{\link{ts_individuals}} \code{\link{ts_nodes}}
#'   \code{\link{ts_edges}} for accessing raw tree sequence tables without
#'   added metadata annotation. See also \code{\link{ts_ancestors}} to learn
#'   how to extract information about relationship beteween nodes in the tree
#'   sequence, and how to analysed data about distances between nodes in the
#'   spatial context.
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param remembered,retained,alive Only extract information about nodes and
#'   times of individuals with the specific flag
#'
#' @return Data frame with processed information from the tree sequence object.
#'   If the model which generated this data was spatial, result will be returned
#'   as a spatial object of the class \code{sf}. See description for more
#'   information.
#'
#' @export
ts_data <- function(ts, remembered = NULL, retained = NULL, alive = NULL) {
  check_ts_class(ts)

  data <- attr(ts, "data")
  if (!is.null(remembered)) data <- dplyr::filter(data, remembered)
  if (!is.null(retained)) data <- dplyr::filter(data, retained)
  if (!is.null(alive)) data <- dplyr::filter(data, alive)

  attr(data, "model") <- attr(ts, "model")

  class(data) <- set_class(data, "tsdata")

  data
}

#' Get the table of individuals/nodes/edges from the tree sequence
#'
#' This function extract data from a given tree sequence table
#'
#' This function extracts the raw table data. For further processing and
#' analyses, the output of the function \code{\link{ts_data}} might be more
#' useful, as it merges the information in node and individual tables into one
#' table and further annotates it with useful information from the model
#' configuration data.
#'
#' @seealso \code{\link{ts_data}} for accessing processed and annotated treee
#'   sequence table data
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#'
#' @return Data frame with the information from the give tree sequence table
#'
#' @export
ts_individuals <- function(ts) {
  check_ts_class(ts)
  attr(ts, "individuals")
}

#' @rdname ts_individuals
#' @export
ts_edges <- function(ts) {
  check_ts_class(ts)
  attr(ts, "edges")
}

#' @rdname ts_individuals
#' @export
ts_nodes <- function(ts) {
  check_ts_class(ts)
  attr(ts, "nodes")
}

#' Extract names and times of individuals scheduled for sampling
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @export
ts_samples <- function(ts) {
  attr(ts, "metadata")$sampling %>%
    dplyr::filter(name %in% ts_data(ts)$name)
}

#' Infer spatio-temporal ancestral history for given nodes/individuals
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param x Either a character vector with individual names, or an integer
#'   vector of node IDs
#' @param verbose Report on the progress of ancestry path generation?
#'
#' @export
ts_ancestors <- function(ts, x = NULL, verbose = FALSE) {
  check_ts_class(ts)

  model <- attr(ts, "model")

  if (is.null(model$world))
    stop("Cannot process locations of ancestral nodes for non-spatial tree sequence data",
         call. = FALSE)

  edges <- ts_edges(ts)

  data <- ts_data(ts) %>% dplyr::filter(!is.na(ind_id))

  if (is.null(x))
    x <- unique(ts_data(ts)$name)
  else if (is.character(x) && !all(x %in% data$name))
    stop("The following individuals are not present in the tree sequence: ",
         paste0(x[!x %in% data$name], collapse = ", "),
         call. = FALSE)

  # collect child-parent branches starting from the "focal nodes"
  branches <- purrr::map_dfr(x, function(.x) {
    if (verbose) message(sprintf("Collecting ancestors of %s [%d/%d]...",
                                 .x, which(.x == x), length(x)))
    ids <- get_node_ids(ts, .x)
    purrr::map_dfr(ids, function(.y) collect_ancestors(.y, edges) %>%
      dplyr::mutate(name = ifelse(is.character(.x), .x, NA),
                    pop = dplyr::filter(data, node_id == .y)$pop[1],
                    node_id = .y))
  })

  child_data  <- dplyr::select(data, child_pop  = pop, child_id  = node_id, child_time  = time, child_location = location)
  parent_data <- dplyr::select(data, parent_pop = pop, parent_id = node_id, parent_time = time, parent_location = location)
#  ind_data <- dplyr::as_tibble(data) %>% dplyr::select(focal_name = name, focal_pop = pop, focal_ind_id = ind_id)%>% dplyr::distinct()

  combined <- branches %>%
    dplyr::inner_join(child_data, by = "child_id") %>%
    dplyr::inner_join(parent_data, by = "parent_id") %>%
#    dplyr::inner_join(ind_data, by = c("ind_id" = "focal_ind_id")) %>%
    sf::st_as_sf()

  if (verbose) message("\nGenerating data about spatial relationships of nodes...")

  connections <- purrr::map2(
    combined$child_location, combined$parent_location, ~
      sf::st_union(.x, .y) %>%
      sf::st_cast("LINESTRING") %>%
      sf::st_sfc() %>%
      sf::st_sf(connection = ., crs = sf::st_crs(combined))) %>%
    dplyr::bind_rows()

  final <- dplyr::bind_cols(combined, connections) %>%
    sf::st_set_geometry("connection") %>%
    dplyr::select(name, pop, node_id, level,
                  child_id, child_time, parent_id, parent_time,
                  child_pop, parent_pop,
                  child_location, parent_location, connection,
                  left_pos = left, right_pos = right) %>%
    dplyr::mutate(level = as.factor(level),
                  pop = factor(pop, levels = model$splits$pop),
                  child_pop = factor(child_pop, levels = model$splits$pop),
                  parent_pop = factor(parent_pop, levels = model$splits$pop))

  attr(final, "model") <- model

  final
}

# tree operations ---------------------------------------------------------

#' Get a tree from a given tree sequence
#'
#' For more information about optional keyword arguments see tskit documentation:
#' <https://tskit.dev/tskit/docs/stable/python-api.html#the-treesequence-class>
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param i Position of the tree in the tree sequence. If \code{mode = "index"},
#'   an i-th tree will be returned (in one-based indexing), if \code{mode =
#'   "position"}, a tree covering an i-th base of the simulated genome will be
#'   returned.
#' @param mode How should the \code{i} argument be interpreted? Either "index"
#'   as an i-th tree in the sequence of genealogies, or "position" along the
#'   simulated genome.
#' @param ... Additional keyword arguments accepted by
#'   \code{tskit.TreeSequence.at and tskit.TreeSequence.at_index} methods
#'
#' @return Object of the type tskit.trees.Tree
#'
#' @examples
#' \dontrun{ # extract the first tree in the tree sequence
#' tree <- ts_tree(ts, i = 1)
#'
#' # extract the tree at a position 100000bp in the tree sequence
#' tree <- ts_tree(ts, i = 100000, mode = "position")
#' }
#'
#' @export
ts_tree <- function(ts, i, mode = c("index", "position"), ...) {
  mode <- match.arg(mode)
  if (mode == "index")
    tree <- ts$at_index(index = i - 1, ...)
  else
    tree <- ts$at(position = i - 1, ...)
  tree
}

#' Plot a graphical representation of a single tree
#'
#' This function first obtains an SVG representation of the tree by calling the
#' \code{draw_svg} method of tskit and renders it as a bitmap image in R. All of
#' the many optional keyword arguments of the \code{draw_svg} method can be
#' provided and will be automatically passed to the method behind the scenes.
#'
#' @param x A single tree extracted by \code{\link{ts_tree}}
#' @param width,height Pixel dimensions of the rendered bitmap
#' @param labels Label each node with the individual name?
#' @param ts \code{pyslim.SlimTreeSequence} object of the class \code{slendr_ts}
#'   obtained by \code{link{ts_load}}, \code{link{ts_recapitate}},
#'   \code{link{ts_simplify}}, or \code{link{ts_mutate}}
#' @param ... Keyword arguments to the tskit \code{draw_svg} function.
#'
#' @export
ts_draw <- function(x, width = 1500, height = 500, labels = FALSE,
                    ts = NULL, ...) {
  if (labels) {
    if (inherits(x, "tskit.trees.Tree") & is.null(ts))
      stop("For plotting individual names, please provide the ",
           "original tree sequence object for annotation using ",
           "the `ts = ` argument to `ts_draw()", call. = FALSE)
    else if (inherits(x, "tskit.trees.TreeSequence"))
      ts <- x

    df_labels <- ts_data(ts) %>%
      dplyr::select(node_id, name) %>%
      dplyr::mutate(node_label = sprintf("%s (%s)", name, node_id),
                    node_label = ifelse(is.na(name), node_id, node_label))
    py_labels <- reticulate::py_dict(keys = df_labels$node_id,
                                     values = df_labels$node_label)
  } else
    py_labels <- NULL

  svg <- x$draw_svg(size = c(width, height), node_labels = py_labels, ...)

  # convert from a SVG representation to a PNG image
  raw <- charToRaw(svg)
  tmp_file <- paste0(tempfile(), ".png")
  rsvg::rsvg_png(svg = raw, file = tmp_file, width = width, height = height)

  # set margins to zero, save original settings
  orig_par <- graphics::par(mar = c(0, 0, 0, 0))

  # plot the PNG image, filling the entire plotting window
  img <- png::readPNG(tmp_file)
  graphics::plot.new()
  graphics::plot.window(0:1, 0:1)
  graphics::rasterImage(img, 0, 0, 1, 1)

  # restor original settings
  graphics::par(orig_par)
}

#' Check that all trees in the tree sequence are fully coalesced
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param return_failed Report back which trees failed the coalescence
#'   check?
#'
#' @return TRUE or FALSE value if \code{return_failed = FALSE}, otherwise a vector of
#'   (tskit Python 0-based) indices of trees which failed the coalescence test
#'
#' @export
ts_coalesced <- function(ts, return_failed = FALSE) {
  reticulate::py_run_string("def mult_roots(ts): return [not tree.has_multiple_roots for tree in ts.trees()]")
  single_roots <- reticulate::py$mult_roots(ts)

  if (all(single_roots))
    return(TRUE)
  else if (return_failed)
    return(which(!single_roots) - 1)
  else
    return(FALSE)
}

# f-statistics ------------------------------------------------------------

fstat <- function(ts, stat, sample_sets, mode, windows, span_normalise) {
  if (!stat %in% c("f2", "f3", "f4"))
    stop("Unknown statistic '", stat, "'", call. = FALSE)

  if (!is.null(windows)) windows <- define_windows(ts, windows)

  node_sets <- purrr::map(sample_sets, ~ get_node_ids(ts, .x))

  result <- ts[[stat]](sample_sets = node_sets, mode = mode,
                       span_normalise = TRUE, windows = windows)

  if (length(result) > 1) result <- list(result)
  result
}

#' @rdname ts_f4ratio
#'
#' @examples
#' \dontrun{ # calculate f2 for two individuals in a previously loaded tree sequence
#' ts_f2(ts, A = "pop1_1", B = "pop2_1")
#'
#' # calculate f2 for two sets of individuals
#' ts_f2(ts, A = c("pop1_1", "pop1_2", "pop1_3"),
#'           B = c("pop2_1", "pop2_2"))
#' }
#'
#' @export
ts_f2 <- function(ts, A, B, mode = c("site", "branch", "node"),
                  span_normalise = TRUE, windows = NULL) {
  mode <- match.arg(mode)
  result <- fstat(ts, "f2", list(A, B), mode, windows, span_normalise)
  dplyr::tibble(A = concat(A), B = concat(B), f2 = result)
}

#' @rdname ts_f4ratio
#'
#' @examples
#' \dontrun{ # calculate f2 for two individuals in a previously loaded tree sequence
#' ts_f3(ts, A = "pop1_1", B = "pop2_1", C = "outgroup_1")
#'
#' # calculate f2 for two sets of individuals
#' ts_f3(ts, A = c("pop1_1", "pop1_2", "pop1_3"),
#'           B = c("pop2_1", "pop2_2"),
#'           C = "outgroup_1")
#' }
#'
#' @export
ts_f3 <- function(ts, A, B, C, mode = c("site", "branch", "node"),
                  span_normalise = TRUE, windows = NULL) {
  mode <- match.arg(mode)
  result <- fstat(ts, "f3", list(A, B, C), mode, windows, span_normalise)
  dplyr::tibble(A = concat(A), B = concat(B), C = concat(C), f3 = result)
}

#' @rdname ts_f4ratio
#'
#' @examples
#' \dontrun{ # calculate f4 for single individuals
#' ts_f4(ts, W = "pop1_1", X = "pop2_1", Y = "pop3_1", Z = "pop4_1")
#'
#' # calculate f4 for sets of individuals
#' ts_f4(ts, W = c("pop1_1", "pop1_2", "pop1_3"),
#'           X = c("pop2_1", "pop2_2"),
#'           Y = c("pop3_1", "pop3_2"),
#'           Z = c("pop4_1", "pop4_2"))
#' }
#'
#' @export
ts_f4 <- function(ts, W, X, Y, Z, mode = c("site", "branch", "node"),
                  span_normalise = TRUE, windows = NULL) {
  mode <- match.arg(mode)
  result <- fstat(ts, "f4", list(W, X, Y, Z), mode, windows, span_normalise)
  dplyr::tibble(W = concat(W), X = concat(X), Y = concat(Y), Z = concat(Z),
                f4 = result)
}

#' Calculate the f2, f3, f4, and f4-ratio statistics
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param W,X,Y,Z,A,B,C,O Character vectors of individual names (following the
#'   nomenclature of Patterson et al. 2021)
#' @param span_normalise Divide the result by the span of the window? Default
#'   TRUE, see the tskit documentation for more detail.
#' @param windows Coordinates of breakpoints between windows. The first
#'   coordinate (0) and the last coordinate (equal to \code{ts$sequence_length})
#'   do not have to be specified as they are added automatically.
#' @param mode The mode for the calculation ("sites" or "branch")
#'
#' @return Data frame with statistics calculated for given sets of individuals
#'
#' @examples
#' \dontrun{ # calculate f2 for two samples in a previously loaded tree sequence
#' ts_f4ratio(ts, X = "test_1", A = "p1_1", B = "p2_1", B = "p3_1", C = "p4_1", O = "outgroup_1")
#' }
#'
#' @export
ts_f4ratio <- function(ts, X, A, B, C, O, mode = c("site", "branch"), span_normalise = TRUE) {
  mode <- match.arg(mode)

  purrr::map_dfr(
    X, function(.x) {
      alpha <-
        ts_f4(ts, A, O, .x, C, mode = mode)$f4 /
        ts_f4(ts, A, O, B, C, mode = mode)$f4
      dplyr::tibble(X = .x, A = concat(A), B = concat(B),
                    C = concat(C), O = concat(O), alpha)
    }
  )
}

# multiway statistics -----------------------------------------------------

multiway_stat <- function(ts, stat = c("fst", "divergence"),
                          k, sample_sets, mode, windows, span_normalise) {
  stat <- match.arg(stat)
  node_sets <- purrr::map(sample_sets, function(set) {
    get_node_ids(ts, set)
  })

  n_sets <- length(sample_sets)

  # generate all pairwise indexes required by tskit for more than
  # two sample sets
  indexes <- utils::combn(n_sets, m = k, simplify = FALSE,
                   FUN = function(x) as.integer(x - 1))

  fun <- switch(
    stat,
    "fst" = ts[["Fst"]],
    "divergence" = ts[["divergence"]]
  )
  if (is.null(fun))
    stop("Unknown statistic '", stat, "'", call. = FALSE)

  values <- fun(
    sample_sets = unname(node_sets),
    indexes = indexes,
    mode = mode,
    windows = windows,
    span_normalise = span_normalise
  )
  if (is.matrix(values))
    values <- split(values, col(values))

  if (is.null(names(sample_sets)))
    set_names <- paste0("set_", seq_len(n_sets))
  else
    set_names <- names(sample_sets)

  result <- purrr::map_dfr(indexes, ~ {
    set <- set_names[.x + 1]
    as.data.frame(t(matrix(set)), stringsAsFactors = FALSE)
  }) %>%
    dplyr::as_tibble() %>%
    dplyr::mutate(stat = values)

  result
}

#' Calculate pairwise statistics between sets of individuals
#'
#' For a discussion on the difference between "site", "branch", and "node"
#' options of the \code{mode} argument, please see the tskit documentation at
#' <https://tskit.dev/tskit/docs/stable/stats.html#sec-stats-mode>.
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param sample_sets A list (optionally a named list) of character vectors with
#'   individual names (one vector per set)
#' @param mode The mode for the calculation ("sites" or "branch")
#' @param windows Coordinates of breakpoints between windows. The first
#'   coordinate (0) and the last coordinate (equal to \code{ts$sequence_length})
#'   do not have to be specified as they are added automatically.
#' @param span_normalise Divide the result by the span of the window? Default
#'   TRUE, see the tskit documentation for more detail.
#'
#' @return For each pairwise calculation, either a single Fst value or a vector
#'   of Fst values (one for each window)
#'
#' @examples
#' \dontrun{ # compute F_st between two sets of individuals in a given tree sequence ts
#' ts_fst(ts, sample_sets = list(afr = c("AFR_1", "AFR_2", "AFR_3"),
#'                               eur = c("EUR_1", "EUR_2")))
#' }
#' @export
ts_fst <- function(ts, sample_sets, mode = c("site", "branch", "node"),
                   windows = NULL, span_normalise = TRUE) {
  mode <- match.arg(mode)
  if (!is.list(sample_sets)) sample_sets <- list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)
  multiway_stat(ts, "fst", k = 2, sample_sets, mode, windows, span_normalise) %>%
    stats::setNames(c("x", "y", "Fst"))
}

#' Calculate pairwise divergence between sets of individuals
#'
#' @rdname ts_fst
#'
#' @return For each pairwise calculation, either a single divergence value or a
#'   vector of divergence values (one for each window)
#'
#' @examples
#' \dontrun{ #' # collect sampled individuals from all populations in a list
#' sample_sets <- ts_samples(ts) %>%
#'   split(., .$pop) %>%
#'   lapply(function(pop) pop$name)
#'
#' # compute the divergence between individuals from each sample set (list of
#' # individual names generated in the previous step)
#' ts_divergence(ts, sample_sets) %>% dplyr::arrange(divergence)
#' }
#'
#' @export
ts_divergence <- function(ts, sample_sets, mode = c("site", "branch", "node"),
                   windows = NULL, span_normalise = TRUE) {
  mode <- match.arg(mode)
  if (!is.list(sample_sets)) sample_sets <- list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)
  multiway_stat(ts, "divergence", k = 2, sample_sets, mode, windows, span_normalise) %>%
    stats::setNames(c("x", "y", "divergence"))
}

# oneway statistics -------------------------------------------------------

oneway_stat <- function(ts, stat, sample_sets, mode, windows, span_normalise = NULL) {
  node_sets <- purrr::map(sample_sets, function(set) {
    get_node_ids(ts, set)
  })

  n_sets <- length(sample_sets)

  fun <- switch(
    stat,
    "D" = ts[["Tajimas_D"]],
    "diversity" = ts[["diversity"]],
    "segsites" = ts[["segregating_sites"]]
  )
  if (is.null(fun))
    stop("Unknown statistic '", stat, "'", call. = FALSE)

  args <- list(sample_sets = unname(node_sets),
               mode = mode,
               windows = windows)
  if (!is.null(span_normalise)) args[["span_normalise"]] <- span_normalise

  values <- do.call(fun, args)

  if (is.matrix(values))
    values <- split(values, col(values))

  if (is.null(names(sample_sets)))
    set_names <- paste0("set_", seq_len(n_sets))
  else
    set_names <- names(sample_sets)

  result <- dplyr::tibble(set = set_names)
  result[[stat]] <- values
  result
}

#' Calculate the density of segregating sites for the given sets of individuals
#'
#' @inheritParams ts_tajima
#' @param span_normalise Divide the result by the span of the window? Default
#'   TRUE, see the tskit documentation for more detail.
#'
#' @return For each set of individuals either a single diversity value or a
#'   vector of diversity values (one for each window)
#'
#' @export
ts_segregating <- function(ts, sample_sets, mode = c("site", "branch", "node"),
                           windows = NULL, span_normalise = TRUE) {
  mode <- match.arg(mode)
  if (!is.list(sample_sets)) sample_sets <- list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)
  oneway_stat(ts, "segsites", sample_sets, mode, windows, span_normalise)
}

#' Calculate diversity in given sets of individuals
#'
#' @inheritParams ts_tajima
#' @param span_normalise Divide the result by the span of the window? Default
#'   TRUE, see the tskit documentation for more detail.
#'
#' @return For each set of individuals either a single diversity value or a
#'   vector of diversity values (one for each window)
#'
#' @examples
#' \dontrun{ #' # collect sampled individuals from all populations in a list
#' sample_sets <- ts_samples(ts) %>%
#'   split(., .$pop) %>%
#'   lapply(function(pop) pop$name)
#'
#' # compute diversity in each population based on sample sets extracted
#' # in the previous step
#' ts_diversity(ts, sample_sets) %>% dplyr::arrange(diversity)
#' }
#'
#' @export
ts_diversity <- function(ts, sample_sets, mode = c("site", "branch", "node"),
                         windows = NULL, span_normalise = TRUE) {
  mode <- match.arg(mode)
  if (!is.list(sample_sets)) sample_sets <- list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)
  oneway_stat(ts, "diversity", sample_sets, mode, windows, span_normalise)
}

#' Calculate Tajima's D for given sets of individuals
#'
#' For a discussion on the difference between "site" and "branch" options of the
#' \code{mode} argument, please see the tskit documentation at
#' <https://tskit.dev/tskit/docs/stable/stats.html#sec-stats-mode>
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param sample_sets A list (optionally a named list) of character vectors with
#'   individual names (one vector per set)
#' @param mode The mode for the calculation ("sites" or "branch")
#' @param windows Coordinates of breakpoints between windows. The first
#'   coordinate (0) and the last coordinate (equal to \code{ts$sequence_length})
#'   are added automatically)
#'
#' @return For each set of individuals either a single Tajima's D value or a
#'   vector of Tajima's D values (one for each window)
#'
#' @examples
#' \dontrun{ # calculate Tajima's D for given sets of individuals in a tree sequence ts
#' ts_tajima(ts, list(afr = c("AFR_1", "AFR_2", "AFR_3"),
#'                    eur = c("EUR_1", "EUR_2")))
#' }
#'
#' @export
ts_tajima <- function(ts, sample_sets, mode = c("site", "branch", "node"),
                      windows = NULL) {
  mode <- match.arg(mode)
  if (!is.list(sample_sets)) sample_sets <- list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)
  oneway_stat(ts, "D", sample_sets, mode, windows)
}

# other statistics --------------------------------------------------------

#' Compute the allele frequency spectrum (AFS)
#'
#' This function computes the AFS with respect to the given set of individuals
#'
#' For more information on the format of the result and dimensions, in
#' particular the interpretation of the first and the last element of the AFS,
#' please see the tskit manual at
#' <https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.allele_frequency_spectrum>
#'
#' @param ts \code{pyslim.SlimTreeSequence} object
#' @param sample_sets A list (optionally a named list) of character vectors with
#'   individual names (one vector per set). If NULL, allele frequency spectrum
#'   for all individuals in the tree sequence will be computed.
#' @param mode The mode for the calculation ("sites" or "branch")
#' @param windows Coordinates of breakpoints between windows. The first
#'   coordinate (0) and the last coordinate (equal to \code{ts$sequence_length})
#'   are added automatically)
#' @param polarised When FALSE (the default) the allele frequency spectrum will
#'   be folded (i.e. the counts will not depend on knowing which allele is
#'   ancestral)
#' @param span_normalise Argument passed to tskit's \code{allele_frequency_spectrum}
#'   method
#'
#' @return Either a single Fst value or a vector of Fst values (one for each
#'   window)
#'
#' @export
ts_afs <- function(ts, sample_sets = NULL, mode = c("site", "branch", "node"),
                   windows = NULL, span_normalise = TRUE,
                   polarised = FALSE) {
  mode <- match.arg(mode)
  if (is.null(sample_sets))
    sample_sets <- list(ts_samples(ts)$name)
  else if (!is.list(sample_sets))
    sample_sets <- list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)

  node_sets <- purrr::map(sample_sets, function(set) {
    get_node_ids(ts, set)
  })

  result <- ts$allele_frequency_spectrum(
    sample_sets = unname(node_sets),
    mode = mode,
    windows = windows,
    span_normalise = span_normalise,
    polarised = polarised
  )

  result
}


# private tree sequence utility functions ---------------------------------

# Function for extracting numerical node IDs for various statistics
get_node_ids <- function(ts, x) {
  if (is.null(x)) {
    ts_data(ts, remembered = TRUE) %>%
      .$node_id %>%
      return()
  } else if (is.numeric(x)) {
    return(x)
  } else if (is.character(x)) {
    ts_data(ts, remembered = TRUE) %>%
      dplyr::filter(name %in% x) %>%
      .$node_id %>%
      return()
  } else
    stop("Unknown data given as individual names or node IDs", call. = FALSE)
}

# Extract information from the nodes table
get_ts_nodes <- function(ts) {
  table <- ts$tables$nodes
  dplyr::tibble(
    node_id = as.integer(seq_len(table$num_rows) - 1),
    time = table$time,
    ind_id = ifelse(table$individual == -1, NA, table$individual),
    pop_id = as.integer(table$population)
  )
}

# Extract information from the table of individual table
get_ts_individuals <- function(ts) {
  table <- ts$tables$individuals

  ind_table <- dplyr::tibble(
    ind_id = seq_len(ts$num_individuals) - 1
  )

  if (attr(ts, "source") == "slim") {
    reticulate::py_run_string("def get_pedigree_ids(ts): return [ind.metadata['pedigree_id'] for ind in ts.individuals()]")

    ind_table <- dplyr::tibble(
      ind_table,
      pedigree_id = reticulate::py$get_pedigree_ids(ts),
      time = ts$individual_times,
      raster_x = ts$individual_locations[, 1],
      raster_y = ts$individual_locations[, 2],
      pop_id = ts$individual_populations,
      alive = bitwAnd(table[["flags"]], pyslim$INDIVIDUAL_ALIVE) != 0,
      remembered = bitwAnd(table[["flags"]], pyslim$INDIVIDUAL_REMEMBERED) != 0,
      retained = bitwAnd(table[["flags"]], pyslim$INDIVIDUAL_RETAINED) != 0
    )
  } else {
      nodes_table <- dplyr::tibble(
        ind_id = ts$tables$nodes$individual,
        pop_id = ts$tables$nodes$population,
        time = ts$tables$nodes$time
      ) %>% dplyr::distinct()
      ind_table <- dplyr::inner_join(ind_table, nodes_table, by = "ind_id")
  }

  ind_table
}

# Extract information from the edges table
get_ts_edges <- function(ts) {
  table <- ts$tables$edges
  dplyr::tibble(
    id = seq_len(table$num_rows) - 1,
    child = as.vector(table[["child"]]),
    parent = as.vector(table[["parent"]]),
    left = as.vector(table[["left"]]),
    right = as.vector(table[["right"]])
  )
}

get_slim_table_data <- function(ts, model, spatial, simplify_to = NULL) {
  # get data from the original individual table
  individuals <- get_ts_individuals(ts) %>%
    dplyr::mutate(time = convert_slim_time(time, model),
                  pop = model$splits$pop[pop_id + 1]) %>%
    dplyr::arrange(-time, pop)

  # load information about samples at times and from populations of remembered
  # individuals
  samples <- attr(ts, "metadata")$sampling %>% dplyr::arrange(-time, pop)
  if (!is.null(simplify_to))
    samples <- samples %>% dplyr::filter(name %in% simplify_to)

  # split individuals into remembered (those explicitly sampled, to which we
  # will add readable names from the sampling schedule table) and not remembered
  # anonymous individuals
  remembered <- dplyr::filter(individuals, remembered) %>%
    dplyr::select(-time, -pop) %>%
    dplyr::bind_cols(samples)

  not_remembered <- dplyr::filter(individuals, !remembered)

  # get data from the original nodes table to get node assignments for each
  # individual but also nodes which are not associated with any individuals
  # (i.e. those added through recapitation by msprime)
  nodes <- get_ts_nodes(ts) %>% dplyr::mutate(time = convert_slim_time(time, model))

  # add numeric node IDs to each individual
  combined <-
    dplyr::bind_rows(remembered, not_remembered) %>%
    dplyr::right_join(nodes, by = "ind_id") %>%
    dplyr::mutate(time = ifelse(is.na(ind_id), time.y, time.x))

  if (spatial) {
    combined <- convert_to_sf(combined, model)
    location_cols <- "location"
  } else
    location_cols <- NULL

  combined <- dplyr::select(
    combined, name, pop, ind_id, node_id, time, !!location_cols,
    remembered, retained, alive, pedigree_id
  )

  if (spatial)
    combined
  else
    dplyr::as_tibble(combined)
}

get_msprime_table_data <- function(ts, model, simplify_to = NULL) {
  # load information about samples at times and from populations of remembered
  # individuals
  samples <- attr(ts, "metadata")$sampling %>% dplyr::arrange(-time, pop)
  if (!is.null(simplify_to))
    samples <- samples %>% dplyr::filter(name %in% simplify_to)

  # get data from the original individual table
  individuals <- get_ts_individuals(ts) %>%
    dplyr::mutate(time = convert_msprime_time(time, model),
                  pop = model$splits$pop[pop_id + 1]) %>%
    dplyr::arrange(-time, pop) %>%
    dplyr::mutate(name = samples$name)

  # get data from the original nodes table to get node assignments for each
  # individual but also nodes which are not associated with any individuals
  # (i.e. those added through recapitation by msprime)
  nodes <- get_ts_nodes(ts) %>%
    dplyr::mutate(time = convert_msprime_time(time, model))

  # add numeric node IDs to each individual
  combined <- dplyr::select(individuals, -time, -pop_id) %>%
    dplyr::right_join(nodes, by = "ind_id") %>%
    dplyr::mutate(pop = model$splits$pop[pop_id + 1]) %>%
    dplyr::select(name, pop, ind_id, node_id, time)

  combined
}

check_ts_class <- function(x) {
  if (!inherits(x, "slendr_ts"))
    stop("Not a tree sequence object created by ts_load, ts_simplify, ts_recapitate or ts_mutate", call. = FALSE)
}

# Collect all ancestors of a given node up to the root by traversing the tree
# edges "bottom-up" using a queue
collect_ancestors <- function(x, edges) {
  # list for collecting paths (i.e. sets of edges) leading from the focal node
  # to the root
  result <- list()

  # initialize the counter of nodes already processed by the queue
  n_nodes <- length(unique(c(edges$child, edges$parent)))
  processed_nodes <- vector(length = n_nodes + 1)

  # initialize the queue with all edges leading from the focal node
  edge <- edges[edges$child %in% x, ] %>% dplyr::mutate(level = 1)
  queue <- split(edge, edge$child)

  # repeat until the queue is empty (this homebrew queue implementation is
  # probably horribly inefficient but it will do for now)
  i <- 0
  while (TRUE) {
    #cat("queue ", (i <- i + 1), "\n")
    # pop out the first element
    item <- queue[[1]]; queue[[1]] <- NULL

    # add it to the final list
    result[[length(result) + 1]] <- item

    # iterate over all parents of the current node
    p <- 0
    for (parent in split(item, item$parent)) {
      #cat("queue ", i, " parent ", (p <- i + 1), "\n")
      # get edges leading from the current parent to its own parent
      edge <- edges[edges$child == unique(parent$parent), ]

      # if the parent has no parent itself or its node has already been
      # processed, skip it and don't add it to the queue
      if (nrow(edge) == 0) next
      if (processed_nodes[unique(edge$child) + 1]) next

      # mark the node as processed...
      processed_nodes[unique(edge$child) + 1] <- TRUE
      # ... and add it to the queue
      edge$level <- item$level[1] + 1
      queue[[length(queue) + 1]] <- edge
    }

    if (length(queue) == 0) break
  }

  result <- dplyr::bind_rows(result) %>%
    dplyr::select(child_id = child, parent_id = parent, left, right, level)

  result
}

# Convert SLiM's dictionaries with the sampling schedule table to
# a normal R data frame
get_sampling <- function(metadata) {
  # again, because of how SLiM's dictionaries are structured, a bit of
  # data munging needs to be performed in order to get a simple data frame
  if (metadata$backend == "SLiM") {
    sampling <- purrr::transpose(metadata$sampling) %>%
      dplyr::as_tibble() %>%
      tidyr::unnest(cols = c("n", "pop", "time_gen", "time_orig"))
  } else
    sampling <- dplyr::as_tibble(metadata$sampling)

  sampling %>%
    dplyr::select(-time_gen) %>%
    {
      rbind(
        dplyr::filter(., n == 1),
        dplyr::filter(., n > 1) %>% .[rep(seq_len(nrow(.)), .$n), ]
      )
    } %>%
    dplyr::group_by(pop) %>%
    dplyr::mutate(name = paste0(pop, "_", 1:dplyr::n())) %>%
    dplyr::ungroup() %>%
    dplyr::arrange(-time_orig, pop) %>%
    dplyr::rename(time = time_orig) %>%
    dplyr::select(name, time, pop)
}

# Extract list with slendr metadata (created as Eidos Dictionaries by SLiM)
get_metadata <- function(ts) {
  # SLiM forces metadata into a certain structure, so the slendr metadata
  # must be extracted differently for the two backends
  if (attr(ts, "source") == "slim") {
    metadata <- ts$metadata$SLiM$user_metadata$slendr[[1]]
    arguments = metadata$arguments[[1]]
  } else {
    metadata <- ts$metadata$slendr
    arguments = metadata$arguments
  }

  list(
    version = metadata$version,
    description = metadata$description,
    sampling = get_sampling(metadata),
    map = metadata$map[[1]],
    arguments = arguments
  )
}

get_biallelic_indices <- function(ts) {
  gts <- ts$genotype_matrix()
  biallelic_pos <- rowSums(gts == 0 | gts == 1) == ncol(gts)
  biallelic_pos
}

# Convert a data frame of information extracted from a tree sequence
# table to an sf spatial object
convert_to_sf <- function(df, model) {
  crs <- sf::st_crs(model$world)

  with_locations <- df[stats::complete.cases(df[, c("raster_x", "raster_y")]), ]
  without_locations <- df[!stats::complete.cases(df[, c("raster_x", "raster_y")]), ]

  # reproject coordinates to the original crs
  if (has_crs(model$world)) {
    with_locations <- reproject(
      from = "raster", to = crs, coords = with_locations, model = model,
      input_prefix = "raster_", output_prefix = "", add = TRUE
    )
  } else {
    with_locations$x <- with_locations$raster_x
    with_locations$y <- with_locations$raster_y
  }

  result <- sf::st_as_sf(with_locations,
                         coords = c("x", "y"),
                         crs = crs) %>%
    dplyr::rename(location = geometry)

  # directly binding with without_locations which has no rows lead to an error:
  # 'Error: Assigned data `x[[all_sfc_columns[i]]]` must be compatible with
  # existing data.' (similar issue reported here:
  # https://github.com/mtennekes/tmap/issues/551)
  if (nrow(without_locations))
    result <- dplyr::bind_rows(result, without_locations)

  result
}

define_windows <- function(ts, breakpoints) {
  unique(c(0, breakpoints, ts$sequence_length))
}

concat <- function(x) {
  paste(x, collapse = "+")
}
