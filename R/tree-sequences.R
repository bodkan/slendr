# tree sequence processing ------------------------------------------------

#' Load a tree sequence file produced by a given model
#'
#' This function loads a tree sequence file simulated from a given slendr model.
#' Optionally, the tree sequence can be recapitated and simplified.
#'
#' The loading, recapitation and simplification is performed using the Python
#' module pyslim which serves as a link between tree sequences generated by SLiM
#' and the tskit module for manipulation of tree sequence data. All of these
#' steps have been modelled after the official pyslim tutorial and documentation
#' available at: <https://tskit.dev/pyslim/docs/latest/tutorial.html>.
#'
#' The recapitation and simplification steps can also be performed individually
#' using the functions \code{\link{ts_recapitate}} and
#' \code{\link{ts_simplify}}.
#'
#' @param source Either a compiled \code{slendr_model} object encoding the
#'   definition of a slendr model used to produce a tree-sequence file (see the
#'   argument \code{param}), or a path to a tree-sequence file coming from a
#'   non-slendr simulation.
#' @param file A path to the tree sequence file generated by the model
#'   specified by the argument \code{source}. If missing, an attempt will be
#'   made to search for a tree-sequence file in the model directory.
#' @param recapitate Should the tree sequence be recapitated?
#' @param simplify Should the tree sequence be simplified down to only
#'   explicitly sampled individuals?
#' @param mutate Should the tree sequence be mutated?
#' @param spatial Should spatial information encoded in the tree sequence data
#'   be converted to spatial R data structures? If \code{FALSE}, pixel-based
#'   raster-dimensions will not be converted to the coordinate reference system
#'   implied by the model. If \code{TRUE} (default), reprojection of coordinates
#'   will be performed. If the model was non-spatial, the value of this
#'   parameter is disregarded.
#' @param recombination_rate,Ne Arguments passed to \code{ts_recapitate}
#' @param mutation_rate Mutation rate passed to \code{ts_mutate}
#' @param random_seed Random seed passed to pyslim's \code{recapitate} method
#' @param simplify_to A character vector of individual names. If NULL, all
#'   remembered individuals will be retained. Only used when \code{simplify =
#'   TRUE}.
#' @param keep_input_roots Should the history ancestral to the MRCA of all
#'   samplbee retained in the tree sequence? Default is \code{FALSE}.
#' @param migration_matrix Migration matrix used for coalescence of ancient
#'   lineages (passed to \code{ts_recapitate})
#'
#' @return Tree sequence object of the class \code{slendr_ts}
#'
#' @seealso \code{\link{ts_data}} for extracting useful information about
#'   individuals, nodes, coalescent times and geospatial locations of nodes on a
#'   map
#'
#' @examples
#' \dontrun{
#' # load tree sequence from its default location in a model directory
#' ts <- ts_load(model)
#'
#' # load tree sequence from another location
#' ts <- ts_load(model, file = "output.trees")
#'
#' # load tree sequence and immediately simplify it only to sampled individuals
#' ts <- ts_load(model, simplify = TRUE)
#'
#' # load tree sequence and simplify it to a subset of sampled individuals
#' ts_small <- ts_simplify(ts, simplify_to = c("CH_1", "NEA_1", "NEA_2",
#'                                             "AFR_1", "AFR_2", "EUR_20", "EUR_50"))
#'
#' # load tree sequence, recapitate it and simplify it
#' ts <- ts_load(model, recapitate = TRUE, simplify = TRUE,
#'               recombination_rate = 1e-8, Ne = 10000)
#'
#' # load tree sequence, recapitate it, simplify it and overlay neutral mutations
#' ts <- ts_load(model, recapitate = TRUE, simplify = TRUE, random_seed = 42,
#'               recombination_rate = 1e-8, Ne = 10000, mutation_rate = 1e-8)
#' }
#'
#' @export
ts_load <- function(source = NULL, file = NULL,
                    recapitate = FALSE, simplify = FALSE, mutate = FALSE,
                    spatial = TRUE, recombination_rate = NULL, mutation_rate = NULL,
                    Ne = NULL, random_seed = NULL, simplify_to = NULL, keep_input_roots = FALSE,
                    migration_matrix = NULL) {
  # if a model object is missing, this is interpreted as the case in which
  # a tree sequence is loaded without being annotated by slendr model data
  if (is.character(source) && is.null(file)) {
    file <- source
    model <- NULL
  } else if (inherits(source, "slendr_model")) {
    model <- source

    if (is.null(model$world)) spatial <- FALSE

    if (is.null(file)) {
      ts_files <- list.files(model$path, pattern = "_(msprime|slim)\\.trees$", full.names = TRUE)
      if (length(ts_files) == 1)
        file <- ts_files
      else if (length(ts_files) > 1) {
        stop("Multiple tree sequence files found in the model directory:\n",
                paste(ts_files, collapse = "\n"),
                "\n\nPlease use the `file = ` argument of `ts_load()` to specify ",
                "which tree sequence should be loaded.", call. = FALSE)
      } else
        stop("No SLiM or msprime tree sequence file found in the model directory ",
            model$path, call. = FALSE)
    }
  }

  if (recapitate && (is.null(recombination_rate) || is.null(Ne)))
    stop("Recombination rate and Ne must be specified for recapitation", call. = FALSE)

  if (mutate && is.null(mutation_rate))
    stop("Mutation rate must be given in order to be able to mutate the tree sequence",
         call. = FALSE)

  # load the tree sequence, converting it to a SLiM tree sequence if necessary
  ts <- tskit$load(path.expand(file))

  # this is hacky but it doesn't seem worth it parsing the raw provenance
  # string that tskit seems to provide, so just regexing against the software
  # is good enough for now
  provenance <- ts$provenance(0L)$record
  if (grepl("SLiM", provenance)) {
    ts <- pyslim$SlimTreeSequence(ts)
    backend <- "SLiM"
  } else if (grepl("msprime", provenance))
    backend <- "msprime"
  else
    stop("Only tree sequences produced by SLiM or msprime are supported", call. = FALSE)

  # this is an awful workaround around the reticulate/Python bug which prevents
  # import_from_path (see zzz.R) from working properly -- I'm getting nonsensical
  #   Error in py_call_impl(callable, dots$args, dots$keywords) :
  #     TypeError: integer argument expected, got float
  # in places with no integer/float conversion in sight
  #
  # at least it prevents having to do things like:
  # reticulate::py_run_string("def get_pedigree_ids(ts): return [ind.metadata['pedigree_id']
  #                                                              for ind in ts.individuals()]")
  reticulate::source_python(file = system.file("pylib/pylib.py", package = "slendr"))

  attr(ts, "source") <- backend

  attr(ts, "model") <- model
  if (!is.null(model))
    attr(ts, "metadata") <- get_slendr_metadata(ts)

  attr(ts, "recapitated") <- FALSE
  attr(ts, "simplified") <- FALSE
  attr(ts, "mutated") <- FALSE

  class(ts) <- c("slendr_ts", class(ts))

  attr(ts, "nodes") <- get_ts_nodes(ts)
  attr(ts, "edges") <- get_ts_edges(ts)
  attr(ts, "individuals") <- get_ts_individuals(ts)

  if (backend == "SLiM") {
    remembered <- attr(ts, "individuals")$remembered
    if (!any(remembered)) remembered <- attr(ts, "individuals")$alive
    attr(ts, "individuals")$sampled <- remembered
    attr(ts, "data") <- get_slim_table_data(ts, model, spatial)
  } else {
    attr(ts, "individuals")$sampled <- TRUE
    attr(ts, "data") <- get_msprime_table_data(ts, model)
  }

  if (recapitate)
    ts <- ts_recapitate(ts, recombination_rate = recombination_rate, Ne = Ne,
                        random_seed = random_seed, spatial = spatial,
                        migration_matrix = migration_matrix)

  if (simplify)
    ts <- ts_simplify(ts, simplify_to, spatial = spatial, keep_input_roots = keep_input_roots)

  if (mutate)
    ts <- ts_mutate(ts, mutation_rate = mutation_rate, random_seed = random_seed)

  ts
}

#' Save a tree sequence to a file
#'
#' @param ts Tree sequence object loaded by \code{ts_load}
#' @param file File to which the tree sequence should be saved
#'
#' @export
ts_save <- function(ts, file) {
  check_ts_class(ts)
  ts$dump(file)
}


#' Recapitate the tree sequence
#'
#' @param ts Tree sequence object loaded by \code{ts_load}
#' @param recombination_rate A constant value of the recombination rate
#' @param Ne Effective population size during the recapitation process
#' @param spatial Should spatial information encoded in the tree sequence data
#'   be converted to spatial R data structures? If FALSE, pixel-based
#'   raster-dimensions will not be converted to the coordinate reference system
#'   implied by the model. If TRUE (default), reprojection of coordinates will
#'   be performed. If the model was non-spatial, the value of this parameter is
#'   disregarded.
#' @param migration_matrix Migration matrix used for coalescence of ancient lineages
#'   (passed to \code{ts_recapitate})
#' @param random_seed Random seed passed to pyslim's \code{recapitate} method
#'
#' @return Tree sequence object of the class \code{slendr_ts}
#'
#' @seealso \code{\link{ts_data}} for extracting useful information about
#'   individuals, nodes, coalescent times and geospatial locations of nodes on a
#'   map
#'
#' @examples
#' \dontrun{
#' ts_rec <- ts_recapitate(ts, recombination_rate = 1e-8, Ne = 10000, random_seed = 42)
#' }
#'
#' @export
ts_recapitate <- function(ts, recombination_rate, Ne, spatial = TRUE,
                          migration_matrix = NULL, random_seed = NULL) {
  check_ts_class(ts)
  if (!hasArg(recombination_rate) | !hasArg(Ne))
    stop("Recombination rate and Ne must be specified", call. = FALSE)

  model <- attr(ts, "model")
  backend <- attr(ts, "source")

  if (is.null(model$world)) spatial <- FALSE

  if (backend == "SLiM") {
    # suppress pyslim warning until we figure out how to switch to the new
    # pyslim.recapitate(ts, ...) method
    reticulate::py_capture_output(
      ts_new <- ts$recapitate(recombination_rate = recombination_rate, Ne = Ne,
                              random_seed = random_seed, migration_matrix = migration_matrix)
    )
  } else {
    ts_new <- ts
    warning("There is no need to recapitate an already coalesced msprime tree sequence",
            call. = FALSE)
  }

  attr(ts_new, "model") <- model
  attr(ts_new, "metadata") <- attr(ts, "metadata")
  attr(ts_new, "source") <- backend

  attr(ts_new, "recapitated") <- TRUE
  attr(ts_new, "simplified") <- attr(ts, "simplified")
  attr(ts_new, "mutated") <- attr(ts, "mutated")

  attr(ts_new, "nodes") <- get_ts_nodes(ts_new)
  attr(ts_new, "edges") <- get_ts_edges(ts_new)

  attr(ts_new, "individuals") <- get_ts_individuals(ts_new)
  if (backend == "SLiM") {
    # inherit the information about which individuals should be marked as
    # explicitly "sampled" from the previous tree sequence object (if that
    # was specified) -- this is only necessary for a SLiM sequence
    old_individuals <- attr(ts, "individuals")
    sampled_ids <- old_individuals[old_individuals$sampled, ]$pedigree_id
    attr(ts_new, "individuals") <- attr(ts_new, "individuals") %>%
      dplyr::mutate(sampled = pedigree_id %in% sampled_ids)
  }

  attr(ts_new, "mutations") <- get_ts_mutations(ts_new)

  if (attr(ts_new, "source") == "SLiM")
    attr(ts_new, "data") <- get_slim_table_data(ts_new, model, spatial)
  else
    attr(ts_new, "data") <- get_msprime_table_data(ts_new, model)

  class(ts_new) <- c("slendr_ts", class(ts_new))

  ts_new
}

#' Simplify the tree sequence down to a given set of individuals
#'
#' This function is a convenience wrapper around the \code{simplify} method
#' implemented in tskit, designed to work on tree sequence data simulated by
#' SLiM using the \pkg{slendr} R package.
#'
#' The simplification process is used to remove redundant information from the
#' tree sequence and retains only information necessary to describe the
#' genealogical history of a set of samples.
#'
#' For more information on how simplification works in pyslim and tskit, see the
#' official documentation at
#' <https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.simplify>
#' and <https://tskit.dev/pyslim/docs/latest/tutorial.html#simplification>.
#'
#' A very clear description of the difference between remembering and retaining
#' and how to use these techniques to implement historical individuals (i.e.
#' ancient DNA samples) is in the pyslim documentation at
#' <https://tskit.dev/pyslim/docs/latest/tutorial.html#historical-individuals>.
#'
#' @param ts Tree sequence object of the class \code{slendr_ts}
#' @param simplify_to A character vector of individual names. If NULL, all
#'   explicitly remembered individuals (i.e. those specified via the
#'   \code{\link{schedule_sampling}} function will be left in the tree sequence
#'   after the simplification.
#' @param spatial Should spatial information encoded in the tree sequence data
#'   be converted to spatial R datastructures? If FALSE, pixel-based
#'   raster-dimensions will not be converted to the coordinate reference system
#'   implied by the model. If TRUE (default), reprojection of coordinates will
#'   be performed. If the model was non-spatial, the value of this parameter is
#'   disregarded.
#' @param keep_input_roots Should the history ancestral to the MRCA of all
#'   samples be retained in the tree sequence? Default is \code{FALSE}.
#'
#' @return Tree sequence object of the class \code{slendr_ts}
#'
#' @seealso \code{\link{ts_data}} for extracting useful information about
#'   individuals, nodes, coalescent times and geospatial locations of nodes on a
#'   map
#'
#' @examples
#' \dontrun{ # simplify tree sequence to sampled individuals
#' ts_simplified <- ts_simplify(ts)
#'
#' # simplify to a subset of sampled individuals
#' ts_small <- ts_simplify(
#'   ts,
#'   simplify_to = c("CH_1", "NEA_1", "NEA_2", "AFR_1",
#'                   "AFR_2", "EUR_20", "EUR_50")
#' )
#' }
#'
#' @export
ts_simplify <- function(ts, simplify_to = NULL, spatial = TRUE, keep_input_roots = FALSE) {
  check_ts_class(ts)
  backend <- attr(ts, "source")

  if (!attr(ts, "recapitated") && !keep_input_roots && !ts_coalesced(ts))
    warning("Simplifying a non-recapitated tree sequence. Make sure this is what you really want",
            call. = FALSE)

  model <- attr(ts, "model")
  if (is.null(model$world)) spatial <- FALSE

  data <- attr(ts, "data")

  if (is.null(simplify_to) && backend == "msprime") {
    warning("If you want to simplify an msprime tree sequence, you must specify\n",
            "the names of individuals to simplify to via the `simplify_to = `\n",
            "function argument.", call. = FALSE)
    return(ts)
  }

  if (is.null(simplify_to)) {
    samples <- dplyr::filter(data, sampled)$node_id
  } else {
    if (is.character(simplify_to)) {
      if (!is.null(model))
        stop("Symbolic character names can only be provided for slendr-generated\n",
             "tree sequences", call. = FALSE)
      if (!all(simplify_to %in% data$name))
        stop("The following individuals are not present in the tree sequence: ",
            paste0(simplify_to[!simplify_to %in% data$name], collapse = ", "),
            call. = FALSE)
      samples <- dplyr::filter(data, name %in% simplify_to)$node_id
    } else if (is.numeric(simplify_to)) {
      if (!all(simplify_to %in% data[data$sampled, ]$node_id))
        stop("The following nodes are not among sampled nodes: ",
            paste0(simplify_to[!simplify_to %in% data[data$sampled, ]$node_id], collapse = ", "),
            call. = FALSE)
      samples <- simplify_to
    }
  }

  ts_new <- ts$simplify(as.integer(samples),
                        filter_populations = FALSE,
                        keep_input_roots = keep_input_roots)

  attr(ts_new, "model") <- model
  attr(ts_new, "metadata") <- attr(ts, "metadata")
  attr(ts_new, "source") <- attr(ts, "source")

  attr(ts_new, "recapitated") <- attr(ts, "recapitated")
  attr(ts_new, "simplified") <- TRUE
  attr(ts_new, "mutated") <- attr(ts, "mutated")

  attr(ts_new, "nodes") <- get_ts_nodes(ts_new)
  attr(ts_new, "edges") <- get_ts_edges(ts_new)
  attr(ts_new, "individuals") <- get_ts_individuals(ts_new)
  attr(ts_new, "mutations") <- get_ts_mutations(ts_new)

  # use pedigree IDs to cross-check the original data with simplified table
  if (backend == "SLiM") {
    # mark only explicitly simplified individuals as "sampled"
    sampled_ids <- data[data$node_id %in% samples, ]$pedigree_id
    attr(ts_new, "individuals")$sampled <- attr(ts_new, "individuals")$pedigree_id %in% sampled_ids

    # get the name and location from the original table with the pedigree_id key
    cols <- c("pedigree_id", "pop")
    if (!is.null(model)) cols <- c(cols, "name")
    if (spatial) cols <- c(cols, "location")
    # we need to deduplicate the rows because the table is stored in a long format
    # (but we removed the node_id column which each diploid individual has two
    # values of)
    keep_data <- data[, cols] %>% dplyr::filter(!duplicated(pedigree_id))

    # get node IDs of individuals present in the simplified tree sequence
    # (sort by individual ID and time)
    nodes_new <- get_ts_nodes(ts_new) %>%
      dplyr::arrange(ind_id, time) %>%
      dplyr::select(node_id, ind_id) %>%
      .$node_id

    location_col <- if (spatial) "location" else NULL

    # get other data about individuals in the simplified tree sequence, sort them
    # also by their IDs and times, and add their node IDs extracted above
    # (this works because we sorted both in the same way)
    data_new <- get_slim_table_data(ts_new, model, spatial, simplify_to) %>%
      as.data.frame() %>%
      dplyr::arrange(ind_id, time) %>%
      dplyr::select(ind_id, pedigree_id, time, sampled, remembered, retained, alive) %>%
      dplyr::inner_join(keep_data, by = "pedigree_id") %>%
      dplyr::mutate(node_id = nodes_new) %>%
      dplyr::as_tibble()

    if (spatial)
      data_new <- sf::st_as_sf(data_new, crs = sf::st_crs(data))

    name_col <- if (is.null(model)) NULL else "name"
    attr(ts_new, "data") <- data_new[, c(name_col, "pop", "ind_id", "node_id",
                                         "time", location_col, "sampled", "remembered",
                                         "retained", "alive", "pedigree_id")]
  } else {
    attr(ts_new, "individuals")$sampled <- TRUE
    attr(ts_new, "data") <- get_msprime_table_data(ts_new, model, simplify_to)
  }

  class(ts_new) <- c("slendr_ts", class(ts_new))

  ts_new
}

#' Add mutations to the given tree sequence
#'
#' @param ts Tree sequence object of the class \code{slendr_ts}
#' @param mutation_rate Mutation rate used by msprime to simulate mutations
#' @param random_seed Random seed passed to msprime's \code{mutate} method
#' @param keep_existing Keep existing mutations?
#' @param mut_type Assign SLiM mutation type to neutral mutations? If
#'   \code{NULL} (default), no special mutation type will be used. If an
#'   integer number is given, mutations of the SLiM mutation type with that
#'   integer identifier will be created.
#'
#' @return Tree sequence object of the class \code{slendr_ts}
#'
#' @seealso \code{\link{ts_data}} for extracting useful information about
#'   individuals, nodes, coalescent times and geospatial locations of nodes on a
#'   map
#'
#' @examples
#' \dontrun{
#' ts_mutate <- ts_mutate(ts, mutation_rate = 1e-8, random_seed = 42)
#' }
#'
#' @export
ts_mutate <- function(ts, mutation_rate, random_seed = NULL,
                      keep_existing = TRUE, mut_type = NULL) {
  check_ts_class(ts)
  if (attr(ts, "mutated")) stop("Tree sequence already mutated", call. = FALSE)

  if (is.numeric(mut_type) && attr(ts, "source") == "SLiM")
    mut_type <- msp$SLiMMutationModel(type = as.integer(mut_type))

  ts_new <-
    msp$sim_mutations(
      ts,
      rate = mutation_rate,
      model = mut_type,
      keep = keep_existing,
      random_seed = random_seed
    )

  if (attr(ts, "source") == "SLiM") ts_new <- pyslim$SlimTreeSequence(ts_new)

  attr(ts_new, "model") <- attr(ts, "model")
  attr(ts_new, "metadata") <- attr(ts, "metadata")
  attr(ts_new, "source") <- attr(ts, "source")

  attr(ts_new, "recapitated") <- attr(ts, "recapitated")
  attr(ts_new, "simplified") <- attr(ts, "simplified")
  attr(ts_new, "mutated") <- TRUE

  attr(ts_new, "nodes") <- attr(ts, "nodes")
  attr(ts_new, "edges") <- attr(ts, "edges")
  attr(ts_new, "individuals") <- attr(ts, "individuals")
  attr(ts_new, "mutations") <- get_ts_mutations(ts_new)

  attr(ts_new, "data") <- attr(ts, "data")

  class(ts_new) <- c("slendr_ts", class(ts_new))

  ts_new
}

#' Extract list with tree sequence metadata saved by SLiM
#'
#' @param ts Tree sequence object of the class \code{slendr_ts}
#'
#' @return List of metadata fields extracted from the tree sequence object
#'
#' @export
ts_metadata <- function(ts) {
  check_ts_class(ts)
  attr(ts, "metadata")
}

# output formats ----------------------------------------------------------

#' Extract genotype table from the tree sequence
#'
#' @param ts Tree sequence object of the class \code{slendr_ts}
#'
#' @return Data frame object of the class \code{tibble}
#'
#' @export
ts_genotypes <- function(ts) {
  if (!attr(ts, "mutated"))
    stop("Extracting genotypes from a tree sequence which has not been mutated",
         call. = FALSE)

  backend <- attr(ts, "source")

  data <- ts_data(ts)

  gts <- ts$genotype_matrix()
  positions <- ts$tables$sites$position

  biallelic_pos <- get_biallelic_indices(ts)
  n_multiallelic <- sum(!biallelic_pos)

  if (n_multiallelic > 0) {
    message(sprintf("%i multiallelic sites (%.3f%% out of %i total) detected and removed",
                    n_multiallelic, n_multiallelic / length(positions) * 100,
                    length(positions)))
    gts <- gts[biallelic_pos, ]
    positions <- positions[biallelic_pos]
  }

  chromosomes <- ts_data(ts) %>%
    dplyr::filter(!is.na(name)) %>%
    dplyr::as_tibble() %>%
    dplyr::mutate(chr_name = sprintf("%s_chr%i", name, 1:2)) %>%
    dplyr::select(chr_name, node_id) %>%
    dplyr::arrange(node_id)

  colnames(gts) <- chromosomes$chr_name

  dplyr::as_tibble(gts) %>%
    dplyr::mutate(pos = as.integer(positions)) %>%
    dplyr::select(pos, dplyr::everything())
}

#' Extract genotypes from the tree sequence in the EIGENSTRAT format
#'
#' EIGENSTRAT data produced by this function can be used by the admixr R package
#' (<https://bodkan.net/admixr/>).
#'
#' In case an outgroup was not formally specified in a slendr model which
#' generated the tree sequence data, it is possible to artificially create an
#' outgroup sample with the name specified by the \code{outgroup} argument,
#' which will carry all ancestral alleles (i.e. value "2" in a geno file
#' for each position in a snp file).
#'
#' @param ts Tree sequence object of the class \code{slendr_ts}
#' @param prefix EIGENSTRAT trio prefix
#' @param chrom The name of the chromosome in the EIGENSTRAT snp file
#'   (default "chr1")
#' @param outgroup Should a formal, artificial outgroup be added? If \code{NULL}
#'   (default), no outgroup is added. A non-NULL character name will serve as
#'   the name of the outgroup in an ind file.
#'
#' @return Object of the class EIGENSTRAT created by the admixr package
#'
#' @examples
#' \dontrun{ # save genotypes as a trio of files eigenprefix.snp, eigenprefix.ind, eigenprefix.geno
#' ts_eigenstrat(ts, prefix = "/path/to/eigenprefix")
#' }
#'
#' @export
ts_eigenstrat <- function(ts, prefix, chrom = "chr1", outgroup = NULL) {
  if (!"admixr" %in% utils::installed.packages()[, 1])
    message("For EIGENSTRAT conversion, please install the R package ",
            "admixr by calling `install.packages(\"admixr\")")

  if (!attr(ts, "recapitated") && !ts_coalesced(ts))
    stop("Tree sequence was not recapitated and some nodes do not ",
         "have parents over some portion of their genome. This is interpreted as ",
         "missing data, which is not currently supported. For more context, take ",
         "a look at <https://github.com/tskit-dev/tskit/issues/301#issuecomment-520990038>.",
         call. = FALSE)

  if (!attr(ts, "mutated"))
    stop("Attempting to extract genotypes from a tree sequence which has not been mutated",
         call. = FALSE)

  chrom_genotypes <- ts_genotypes(ts)
  chr1_genotypes <- dplyr::select(chrom_genotypes, dplyr::ends_with("_chr1"))
  chr2_genotypes <- dplyr::select(chrom_genotypes, dplyr::ends_with("_chr2"))

  # create a geno file table
  geno <- dplyr::as_tibble(2 - (chr1_genotypes + chr2_genotypes))
  individuals <- gsub("_chr.", "", colnames(geno))
  colnames(geno) <- individuals

  # create an ind file table
  ind <- dplyr::tibble(id = individuals, sex = "U", label = individuals)

  # create a snp file table
  positions <- chrom_genotypes$pos
  snp <- dplyr::tibble(
    id = sprintf("%s_%s", chrom, as.character(positions)),
    chrom = chrom,
    gen = 0.0,
    pos = positions,
    ref = "G",
    alt = "T"
  )

  # add an artificial outgroup individual carrying ancestral alleles only
  if (!is.null(outgroup)) {
    geno[[as.character(outgroup)]] <- 2
    ind <- data.frame(
      id = as.character(outgroup),
      sex = "U",
      label = as.character(outgroup)
    ) %>%
        dplyr::bind_rows(ind, .)
  }

  # save the EIGENSTRAT trio
  if (!dir.exists(dirname(prefix))) dir.create(dirname(prefix))
  admixr::write_geno(geno, paste0(prefix, ".geno"))
  admixr::write_snp(snp, paste0(prefix, ".snp"))
  admixr::write_ind(ind, paste0(prefix, ".ind"))

  # return the admixr eigenstrat object
  admixr::eigenstrat(prefix = prefix)
}

#' Save genotypes from the tree sequenceas a VCF file
#'
#' @param ts Tree sequence object of the class \code{slendr_ts}
#' @param path Path to a VCF file
#' @param chrom Chromosome name to be written in the CHROM column of the VCF
#' @param individuals A character vector of individuals in the tree sequence. If
#'   missing, all individuals present in the tree sequence will be saved.
#'
#' @examples
#' \dontrun{ # save a VCF file from a given tree sequence object ts
#' ts_vcf(ts, path = "/path/to/target/output.vcf.gz")
#' }
#'
#' @export
ts_vcf <- function(ts, path, chrom = NULL, individuals = NULL) {
  if (!attr(ts, "recapitated") && !ts_coalesced(ts))
    stop("Tree sequence was not recapitated and some nodes do not ",
         "have parents over some portion of their genome. This is interpreted as ",
         "missing data, which is not currently supported by tskit. For more context, ",
         "take a look at <https://github.com/tskit-dev/tskit/issues/301#issuecomment-520990038>.",
         call. = FALSE)

  if (!attr(ts, "mutated"))
    stop("Attempting to extract genotypes from a tree sequence which has not been mutated",
         call. = FALSE)

  data <- ts_data(ts) %>%
    dplyr::filter(!is.na(name)) %>%
    dplyr::as_tibble() %>%
    dplyr::distinct(name, ind_id)

  if (is.null(individuals)) individuals <- data$name

  present <- individuals %in% unique(data$name)
  if (!all(present))
    stop("", paste(individuals[!present], collapse = ", "),
         " not present in the tree sequence", call. = FALSE)

  gzip <- reticulate::import("gzip")
  with(reticulate::`%as%`(gzip$open(path.expand(path), "wt"), vcf_file), {
    ts$write_vcf(vcf_file,
                 contig_id = chrom,
                 individuals = as.integer(data$ind_id),
                 individual_names = data$name)
  })
}

#' Convert a tree in the tree sequence to an object of the class \code{phylo}
#'
#' @inheritParams ts_tree
#' @param labels What should be stored as node labels in the final \code{phylo}
#'   object? Options are either a population name or a tskit integer node ID
#'   (which is a different thing from a \code{phylo} class node integer index).
#' @param quiet Should ape's internal phylo validity test be printed out?
#'
#' @export
ts_phylo <- function(ts, i, mode = c("index", "position"),
                     labels = c("tskit", "pop"), quiet = FALSE) {
  labels <- match.arg(labels)

  tree <- ts_tree(ts, i, mode)

  if (tree$num_roots > 1)
    stop("A tree sequence tree which is not fully coalesced or recapitated\n",
         "cannot be converted to an R phylo tree representation (see the help\n",
         "page of ?ts_recapitate for more details)", call. = FALSE)

  if (!attr(ts, "simplified") && attr(ts, "source") != "msprime")
    stop("Please simplify your tree sequence down to sampled individuals\nfirst ",
         "before converting a tree to an R phylo tree object format (see the\n",
         "help page of ?ts_simplify for more details)", call. = FALSE)

  # get tree sequence nodes which are present in the tskit tree object
  # (tree$preorder() just get the numerical node IDs, nothing else)
  data <- ts_data(ts) %>%
    dplyr::as_tibble() %>%
    dplyr::filter(node_id %in% tree$preorder())

  model <- attr(ts, "model")
  source <- attr(ts, "source")

  if (!is.null(model))
    direction <- model$direction
  else
    direction <- "backward"

  if (direction == "forward")
    data <- dplyr::arrange(data, sampled, time)
  else
    data <- dplyr::arrange(data, sampled, -time)

  # convert the edge table to a proper ape phylo object
  # see http://ape-package.ird.fr/misc/FormatTreeR.pdf for more details
  n_tips <- sum(data$sampled, na.rm = TRUE)
  n_internal <- nrow(data) - n_tips
  n_all <- n_internal + n_tips; stopifnot(n_all == nrow(data))

  present_ids <- data$node_id
  # design a lookup table of consecutive integer numbers (reversing it because
  # in the ordered tree sequence table of nodes `data`, the sampled nodes which
  # will become the tips of the tree are at the end)
  lookup_ids <- rev(seq_along(present_ids))

  tip_labels <- dplyr::filter(data, sampled) %>%
    { if (is.null(model)) .$node_id else sprintf("%s (%s)", .$node_id, .$name) } %>%
    as.character() %>%
    rev()

  # flip the index of the root in the lookup table
  lookup_ids[length(lookup_ids) - n_tips] <- lookup_ids[1]
  lookup_ids[1] <- n_tips + 1

  child_ids <- present_ids[present_ids != tree$root]
  parent_ids <- sapply(child_ids, function(i) tree$parent(i))

  children <- sapply(child_ids, function(n) lookup_ids[present_ids == n])
  parents <- sapply(parent_ids, function(n) lookup_ids[present_ids == n])

  # find which sampled nodes are not leaves:
  # - first look for those nodes in the tree sequence node IDs
  internal_ts_samples <- intersect(parent_ids, data[data$sampled, ]$node_id)
  # - then convert them to the phylo numbering
  internal_phylo_samples <- sapply(internal_ts_samples, function(n) lookup_ids[present_ids == n])

  # and then link them to dummy internal nodes, effectively turning them into
  # proper leaves
  dummies <- vector(mode = "integer", length(internal_ts_samples))
  for (d in seq_along(dummies)) {
    ts_node <- as.integer(internal_ts_samples[d])
    phylo_node <- as.integer(internal_phylo_samples[d])
    dummy <- n_all + d
    node_parent <- lookup_ids[present_ids == tree$parent(ts_node)]
    node_children <- sapply(unlist(tree$children(ts_node)), function(n) lookup_ids[present_ids == n])

    # replace the sampled node with a dummy node, linking to its parent and
    # children (all done in the phylo index space)
    parents[children %in% node_children] <- dummy
    children[children == phylo_node] <- dummy

    # add a new link from the dummy node to the real sample
    children <- c(children, phylo_node)
    parents <- c(parents, dummy)

    dummies[d] <- dummy
  }

  # bind the two columns back into an edge matrix
  edge <- cbind(as.integer(parents), as.integer(children))

  # create vector of edge lengths (adding zero-length branches linking the dummy
  # nodes)
  children_times <- sapply(child_ids, function(n) data[data$node_id == n, ]$time)
  parent_times <- sapply(parent_ids, function(n) data[data$node_id == n, ]$time)
  edge_lengths <- c(abs(parent_times - children_times), rep(0, length(dummies)))

  data$phylo_id <- sapply(data$node_id, function(n) lookup_ids[present_ids == n])
  columns <- c()
  if (source == "SLiM" && !is.null(model$world))
    columns <- c(columns, "location")
  if (source == "SLiM")
    columns <- c(columns, c("remembered", "retained", "alive", "pedigree_id"))
  name_col <- if (is.null(model)) NULL else "name"
  data <- dplyr::select(
    data, !!name_col, pop, node_id, phylo_id, time, sampled, !!columns, ind_id
  )
  # add fake dummy information to the processed tree sequence table so that
  # the user knows what is real and what is not straight from the ts_phylo()
  # output
  if (length(dummies)) {
    data <- dplyr::bind_rows(
      data,
      data.frame(
        name = NA,
        pop = sapply(internal_ts_samples,
                     function(n) data[data$node_id == n, ]$pop),
        node_id = NA, phylo_id = dummies,
        time = sapply(internal_ts_samples,
                      function(n) data[data$node_id == n, ]$time)
      )
    )
  }
  if (source == "SLiM" && !is.null(model$world))
    data <- sf::st_as_sf(data)

  class(data) <- set_class(data, "table")

  # generate appropriate internal node labels based on the user's choice
  elem <- if (labels == "pop") "pop" else "node_id"
  node_labels <- purrr::map_chr(unique(sort(parents)),
                                ~ data[data$phylo_id == .x, ][[elem]])

  tree <- list(
    edge = edge,
    edge.length = edge_lengths,
    node.label = node_labels,
    tip.label = tip_labels,
    Nnode = n_internal + length(dummies)
  )
  class(tree) <- c("slendr_phylo", "phylo")

  check_log <- utils::capture.output(ape::checkValidPhylo(tree))

  # if there are fatal issues, report them and signal an error
  if (any(grepl("FATAL", check_log)))
    stop(paste(check_log, collapse = "\n"), call. = FALSE)

  if (!quiet) cat(check_log, sep = "\n")

  # subset ts_data result to only those nodes that are present in the phylo
  # object, adding another column with the rearranged node IDs
  attr(tree, "model") <- attr(ts, "model")
  attr(tree, "data") <- data
  attr(tree, "branches") <- get_sf_branches(tree)
  attr(tree, "source") <- attr(ts, "source")

  tree
}

# tree sequence tables ----------------------------------------------------

#' Extract combined annotated table of individuals and nodes
#'
#' This function combines information from the table of individuals and table of
#' nodes into a single data frame which can be used in downstream analyses.
#'
#' The source of data (tables of individuals and nodes recorded in the tree
#' sequence generated by SLiM) are combined into a single data frame. If the
#' model which generated the data was spatial, coordinates of nodes (which are
#' pixel-based by default because SLiM spatial simulations occur on a raster),
#' the coordinates are automatically converted to an explicit spatial object of
#' the \code{sf} class unless \code{spatial = FALSE}. See
#' <https://r-spatial.github.io/sf/> for an extensive introduction to the sf
#' package and the ways in which spatial data can be processed, analysed, and
#' visualised.
#'
#' @seealso \code{\link{ts_individuals}} \code{\link{ts_nodes}}
#'   \code{\link{ts_edges}} for accessing raw tree sequence tables without added
#'   metadata annotation. See also \code{\link{ts_ancestors}} to learn how to
#'   extract information about relationship beteween nodes in the tree sequence,
#'   and how to analysed data about distances between nodes in the spatial
#'   context.
#'
#' @param x Tree sequence object of the class \code{slendr_ts} or a \code{phylo}
#'   object extracted by \code{ts_phylo}
#'
#' @return Data frame with processed information from the tree sequence object.
#'   If the model which generated this data was spatial, result will be returned
#'   as a spatial object of the class \code{sf}.
#'
#' @export
ts_data <- function(x) {
  if (!inherits(x, "slendr_ts") && !(inherits(x, "slendr_phylo")))
    stop("Annotation data table can be only extracted for a slendr tree sequence\n",
         "object or a phylo object created by the ts_phylo function", call. = FALSE)

  data <- attr(x, "data")

  attr(data, "model") <- attr(x, "model")
  attr(data, "source") <- attr(x, "source")

  class(data) <- set_class(data, "table")

  data
}

#' Get the table of individuals/nodes/edges/mutations from the tree sequence
#'
#' This function extracts data from a given tree sequence table. All times are
#' converted to model-specific time units from tskit's "generations backwards"
#' time direction.
#'
#' For further processing and analyses, the output of the function
#' \code{\link{ts_data}} might be more useful, as it merges the information in
#' node and individual tables into one table and further annotates it with
#' useful information from the model configuration data.
#'
#' @seealso \code{\link{ts_data}} for accessing processed and annotated treee
#'   sequence table data
#'
#' @param ts Tree sequence object of the class \code{slendr_ts}
#'
#' @return Data frame with the information from the give tree sequence table
#'
#' @export
ts_individuals <- function(ts) {
  check_ts_class(ts)
  attr(ts, "individuals")
}

#' @rdname ts_individuals
#' @export
ts_edges <- function(ts) {
  check_ts_class(ts)
  attr(ts, "edges")
}

#' @rdname ts_individuals
#' @export
ts_nodes <- function(ts) {
  check_ts_class(ts)
  attr(ts, "nodes")
}

#' @rdname ts_individuals
#' @export
ts_mutations <- function(ts) {
  check_ts_class(ts)
  table <- attr(ts, "mutations")
  if (is.null(table))
    return(dplyr::tibble())
  else
    return(table)
}

#' Extract table of spatio-temporal node annotation from a given tree
#'
#' @param tree Tree object generated by \code{ts_phylo}
#'
#' @return Data frame of the \code{sf} type containing the times of nodes and
#'   start-end coordinates of branches across space
#'
#' @export
ts_branches <- function(tree) {
  if (!inherits(tree, "slendr_phylo"))
    stop("Not a tree object created by the function `ts_phylo()`", call. = FALSE)
  attr(tree, "branches")
}

#' Extract names and times of individuals scheduled for sampling
#' @param ts Tree sequence object of the class \code{slendr_ts}
#' @export
ts_samples <- function(ts) {
  if (is.null(attr(ts, "model")))
    stop("Sampling schedule can only be extracted for tree sequences\ngenerated ",
         "from a slendr model. To access information about times and\nlocations ",
         "of nodes and individuals from non-slendr tree sequences,\nuse the ",
         "function ts_data().\n", call. = FALSE)
  data <- ts_data(ts) %>% dplyr::filter(!is.na(name))
  attr(ts, "metadata")$sampling %>%
    dplyr::filter(name %in% data$name)
}

#' Extract spatio-temporal ancestral history for given nodes/individuals
#'
#' @param ts Tree sequence object of the class \code{slendr_ts}
#' @param x Either a character vector with individual names, or an integer
#'   vector of node IDs
#' @param verbose Report on the progress of ancestry path generation?
#'
#' @export
ts_ancestors <- function(ts, x = NULL, verbose = FALSE) {
  check_ts_class(ts)

  model <- attr(ts, "model")

  if (is.null(model$world))
    stop("Cannot process locations of ancestral nodes for non-spatial tree sequence data",
         call. = FALSE)

  edges <- ts_edges(ts)

  data <- ts_data(ts) %>% dplyr::filter(!is.na(ind_id))

  if (is.null(x))
    x <- unique(ts_data(ts)$name)
  else if (is.character(x) && !all(x %in% data$name))
    stop("The following individuals are not present in the tree sequence: ",
         paste0(x[!x %in% data$name], collapse = ", "),
         call. = FALSE)

  # collect child-parent branches starting from the "focal nodes"
  branches <- purrr::map_dfr(x, function(.x) {
    if (verbose) message(sprintf("Collecting ancestors of %s [%d/%d]...",
                                 .x, which(.x == x), length(x)))
    ids <- get_node_ids(ts, .x)

    purrr::map_dfr(ids, function(.y) {
      if (!nrow(edges[edges$child == .y, ]))
        stop("The node specified does not have any ancestors of its own", call. = FALSE)

      collect_ancestors(.y, edges) %>%
      dplyr::mutate(name = ifelse(is.character(.x), .x, NA),
                    pop = dplyr::filter(data, node_id == .y)$pop[1],
                    node_id = .y)
    })
  })

  child_data  <- dplyr::select(data, child_pop  = pop, child_id  = node_id, child_time  = time, child_location = location)
  parent_data <- dplyr::select(data, parent_pop = pop, parent_id = node_id, parent_time = time, parent_location = location)
#  ind_data <- dplyr::as_tibble(data) %>% dplyr::select(focal_name = name, focal_pop = pop, focal_ind_id = ind_id)%>% dplyr::distinct()

  combined <- branches %>%
    dplyr::inner_join(child_data, by = "child_id") %>%
    dplyr::inner_join(parent_data, by = "parent_id") %>%
#    dplyr::inner_join(ind_data, by = c("ind_id" = "focal_ind_id")) %>%
    sf::st_as_sf()

  if (verbose) message("\nGenerating data about spatial relationships of nodes...")

  connections <- purrr::map2(
    combined$child_location, combined$parent_location, ~
      sf::st_union(.x, .y) %>%
      sf::st_cast("LINESTRING") %>%
      sf::st_sfc() %>%
      sf::st_sf(connection = ., crs = sf::st_crs(combined))) %>%
    dplyr::bind_rows()

  # order population names by their split time
  pop_names <- order_pops(model$populations, model$direction)

  final <- dplyr::bind_cols(combined, connections) %>%
    sf::st_set_geometry("connection") %>%
    dplyr::select(name, pop, node_id, level,
                  child_id, child_time, parent_id, parent_time,
                  child_pop, parent_pop,
                  child_location, parent_location, connection,
                  left_pos = left, right_pos = right) %>%
    dplyr::mutate(level = as.factor(level),
                  pop = factor(pop, levels = pop_names),
                  child_pop = factor(child_pop, levels = pop_names),
                  parent_pop = factor(parent_pop, levels = pop_names))

  attr(final, "model") <- model

  final
}

#' Extract all descendants of a given tree-sequence node
#'
#' @param ts Tree sequence object of the class \code{slendr_ts}
#' @param x An integer node ID of the ancestral node
#' @param verbose Report on the progress of ancestry path generation?
#'
#' @export
ts_descendants <- function(ts, x, verbose = FALSE) {
  check_ts_class(ts)

  model <- attr(ts, "model")

  if (is.null(model$world))
    stop("Cannot process locations of ancestral nodes for non-spatial tree sequence data",
         call. = FALSE)

  edges <- ts_edges(ts)

  if (!nrow(edges[edges$parent == x, ]))
    stop("The 'ancestral' node specified does not have any children", call. = FALSE)

  data <- ts_data(ts) %>% dplyr::filter(!is.na(ind_id))

  # collect child-parent branches starting from the "focal nodes"
  branches <- collect_descendants(x, edges) %>%
   dplyr::mutate(pop = dplyr::filter(data, node_id == x)$pop[1],
                 node_id = x)

  child_data  <- dplyr::select(data, child_pop  = pop, child_id  = node_id, child_time  = time, child_location = location)
  parent_data <- dplyr::select(data, parent_pop = pop, parent_id = node_id, parent_time = time, parent_location = location)
  #  ind_data <- dplyr::as_tibble(data) %>% dplyr::select(focal_name = name, focal_pop = pop, focal_ind_id = ind_id)%>% dplyr::distinct()

  combined <- branches %>%
    dplyr::inner_join(child_data, by = "child_id") %>%
    dplyr::inner_join(parent_data, by = "parent_id") %>%
    #    dplyr::inner_join(ind_data, by = c("ind_id" = "focal_ind_id")) %>%
    dplyr::mutate(name = sapply(child_id, function(i) data[data$node_id == i, ]$name[1])) %>%
    sf::st_as_sf()

  if (verbose) message("\nGenerating data about spatial relationships of nodes...")

  connections <- purrr::map2(
    combined$child_location, combined$parent_location, ~
      sf::st_union(.x, .y) %>%
      sf::st_cast("LINESTRING") %>%
      sf::st_sfc() %>%
      sf::st_sf(connection = ., crs = sf::st_crs(combined))) %>%
    dplyr::bind_rows()

  # order population names by their split time
  pop_names <- order_pops(model$populations, model$direction)

  final <- dplyr::bind_cols(combined, connections) %>%
    sf::st_set_geometry("connection") %>%
    dplyr::select(name, pop, node_id, #level,
                  child_id, child_time, parent_id, parent_time,
                  child_pop, parent_pop,
                  child_location, parent_location, connection,
                  left_pos = left, right_pos = right) %>%
    dplyr::mutate(#level = as.factor(level),
      pop = factor(pop, levels = pop_names),
      child_pop = factor(child_pop, levels = pop_names),
      parent_pop = factor(parent_pop, levels = pop_names))

  attr(final, "model") <- model

  final
}

# tree operations ---------------------------------------------------------

#' Get a tree from a given tree sequence
#'
#' For more information about optional keyword arguments see tskit documentation:
#' <https://tskit.dev/tskit/docs/stable/python-api.html#the-treesequence-class>
#'
#' @param ts Tree sequence object of the class \code{slendr_ts}
#' @param i Position of the tree in the tree sequence. If \code{mode = "index"},
#'   an i-th tree will be returned (in one-based indexing), if \code{mode =
#'   "position"}, a tree covering an i-th base of the simulated genome will be
#'   returned.
#' @param mode How should the \code{i} argument be interpreted? Either "index"
#'   as an i-th tree in the sequence of genealogies, or "position" along the
#'   simulated genome.
#' @param ... Additional keyword arguments accepted by
#'   \code{tskit.TreeSequence.at and tskit.TreeSequence.at_index} methods
#'
#' @return Object of the type tskit.trees.Tree
#'
#' @examples
#' \dontrun{ # extract the first tree in the tree sequence
#' tree <- ts_tree(ts, i = 1)
#'
#' # extract the tree at a position 100000bp in the tree sequence
#' tree <- ts_tree(ts, i = 100000, mode = "position")
#' }
#'
#' @export
ts_tree <- function(ts, i, mode = c("index", "position"), ...) {
  check_ts_class(ts)
  mode <- match.arg(mode)
  if (mode == "index")
    tree <- ts$at_index(index = i - 1, ...)
  else
    tree <- ts$at(position = i - 1, ...)
  attr(tree, "tree_sequence") <- ts
  tree
}

#' Plot a graphical representation of a single tree
#'
#' This function first obtains an SVG representation of the tree by calling the
#' \code{draw_svg} method of tskit and renders it as a bitmap image in R. All of
#' the many optional keyword arguments of the \code{draw_svg} method can be
#' provided and will be automatically passed to the method behind the scenes.
#'
#' @param x A single tree extracted by \code{\link{ts_tree}}
#' @param width,height Pixel dimensions of the rendered bitmap
#' @param labels Label each node with the individual name?
#' @param sampled_only Should only individuals explicitly sampled through
#'   simplification be labeled? This is relevant in situations in which sampled
#'   individuals can themselves be among the ancestral nodes.
#' @param ... Keyword arguments to the tskit \code{draw_svg} function.
#'
#' @export
ts_draw <- function(x, width = 1500, height = 500, labels = FALSE,
                    sampled_only = TRUE, ...) {
  if (!"rsvg" %in% utils::installed.packages()[, 1])
    stop("For plotting trees using the native SVG tskit capabilities, please\n",
         "install the R package rsvg by calling `install.packages(\"rsvg\")")

  if (labels) {
    ts <- attr(x, "tree_sequence")
    df_labels <- ts_data(ts) %>%
      dplyr::select(node_id, name, sampled) %>%
      dplyr::mutate(node_label = ifelse(!is.na(name), sprintf("%s (%s)", name, node_id), node_id))
    if (sampled_only)
      df_labels$node_label <- ifelse(!df_labels$sampled, df_labels$node_id, df_labels$node_label)

    py_labels <- reticulate::py_dict(keys = df_labels$node_id,
                                     values = df_labels$node_label)
  } else
    py_labels <- NULL

  svg <- x$draw_svg(size = c(width, height), node_labels = py_labels, ...)

  # convert from a SVG representation to a PNG image
  raw <- charToRaw(svg)
  tmp_file <- paste0(tempfile(), ".png")
  rsvg::rsvg_png(svg = raw, file = tmp_file, width = width, height = height)

  # set margins to zero, save original settings
  orig_par <- graphics::par(mar = c(0, 0, 0, 0))

  # plot the PNG image, filling the entire plotting window
  img <- png::readPNG(tmp_file)
  graphics::plot.new()
  graphics::plot.window(0:1, 0:1)
  graphics::rasterImage(img, 0, 0, 1, 1)

  # restor original settings
  graphics::par(orig_par)
}

#' Check that all trees in the tree sequence are fully coalesced
#'
#' @param ts Tree sequence object of the class \code{slendr_ts}
#' @param return_failed Report back which trees failed the coalescence
#'   check?
#'
#' @return TRUE or FALSE value if \code{return_failed = FALSE}, otherwise a vector of
#'   (tskit Python 0-based) indices of trees which failed the coalescence test
#'
#' @export
ts_coalesced <- function(ts, return_failed = FALSE) {
  # reticulate::py_run_string("def mult_roots(ts): return [not tree.has_multiple_roots for tree in ts.trees()]")

  # single_roots <- pylib$mult_roots(ts)

  single_roots <- reticulate::py$mult_roots(ts)

  if (all(single_roots))
    return(TRUE)
  else if (return_failed)
    return(which(!single_roots) - 1)
  else
    return(FALSE)
}

# f-statistics ------------------------------------------------------------

fstat <- function(ts, stat, sample_sets, mode, windows, span_normalise) {
  if (!stat %in% c("f2", "f3", "f4"))
    stop("Unknown statistic '", stat, "'", call. = FALSE)

  if (!is.null(windows)) windows <- define_windows(ts, windows)

  node_sets <- purrr::map(sample_sets, ~ get_node_ids(ts, .x))

  result <- ts[[stat]](sample_sets = node_sets, mode = mode,
                       span_normalise = TRUE, windows = windows)

  if (length(result) > 1) result <- list(result)
  result
}

#' @rdname ts_f4ratio
#'
#' @examples
#' \dontrun{ # calculate f2 for two individuals in a previously loaded tree sequence
#' ts_f2(ts, A = "pop1_1", B = "pop2_1")
#'
#' # calculate f2 for two sets of individuals
#' ts_f2(ts, A = c("pop1_1", "pop1_2", "pop1_3"),
#'           B = c("pop2_1", "pop2_2"))
#' }
#'
#' @export
ts_f2 <- function(ts, A, B, mode = c("site", "branch", "node"),
                  span_normalise = TRUE, windows = NULL) {
  mode <- match.arg(mode)
  result <- fstat(ts, "f2", list(A, B), mode, windows, span_normalise)
  dplyr::tibble(A = concat(A), B = concat(B), f2 = result)
}

#' @rdname ts_f4ratio
#'
#' @examples
#' \dontrun{ # calculate f2 for two individuals in a previously loaded tree sequence
#' ts_f3(ts, A = "pop1_1", B = "pop2_1", C = "outgroup_1")
#'
#' # calculate f2 for two sets of individuals
#' ts_f3(ts, A = c("pop1_1", "pop1_2", "pop1_3"),
#'           B = c("pop2_1", "pop2_2"),
#'           C = "outgroup_1")
#' }
#'
#' @export
ts_f3 <- function(ts, A, B, C, mode = c("site", "branch", "node"),
                  span_normalise = TRUE, windows = NULL) {
  mode <- match.arg(mode)
  result <- fstat(ts, "f3", list(A, B, C), mode, windows, span_normalise)
  dplyr::tibble(A = concat(A), B = concat(B), C = concat(C), f3 = result)
}

#' @rdname ts_f4ratio
#'
#' @examples
#' \dontrun{ # calculate f4 for single individuals
#' ts_f4(ts, W = "pop1_1", X = "pop2_1", Y = "pop3_1", Z = "pop4_1")
#'
#' # calculate f4 for sets of individuals
#' ts_f4(ts, W = c("pop1_1", "pop1_2", "pop1_3"),
#'           X = c("pop2_1", "pop2_2"),
#'           Y = c("pop3_1", "pop3_2"),
#'           Z = c("pop4_1", "pop4_2"))
#' }
#'
#' @export
ts_f4 <- function(ts, W, X, Y, Z, mode = c("site", "branch", "node"),
                  span_normalise = TRUE, windows = NULL) {
  mode <- match.arg(mode)
  result <- fstat(ts, "f4", list(W, X, Y, Z), mode, windows, span_normalise)
  dplyr::tibble(W = concat(W), X = concat(X), Y = concat(Y), Z = concat(Z),
                f4 = result)
}

#' Calculate the f2, f3, f4, and f4-ratio statistics
#'
#' @param ts Tree sequence object of the class \code{slendr_ts}
#' @param W,X,Y,Z,A,B,C,O Character vectors of individual names (following the
#'   nomenclature of Patterson et al. 2021)
#' @param span_normalise Divide the result by the span of the window? Default
#'   TRUE, see the tskit documentation for more detail.
#' @param windows Coordinates of breakpoints between windows. The first
#'   coordinate (0) and the last coordinate (equal to \code{ts$sequence_length})
#'   do not have to be specified as they are added automatically.
#' @param mode The mode for the calculation ("sites" or "branch")
#'
#' @return Data frame with statistics calculated for given sets of individuals
#'
#' @examples
#' \dontrun{ # calculate f2 for two samples in a previously loaded tree sequence
#' ts_f4ratio(ts, X = "test_1", A = "p1_1", B = "p2_1", B = "p3_1", C = "p4_1", O = "outgroup_1")
#' }
#'
#' @export
ts_f4ratio <- function(ts, X, A, B, C, O, mode = c("site", "branch"), span_normalise = TRUE) {
  mode <- match.arg(mode)

  purrr::map_dfr(
    X, function(.x) {
      alpha <-
        ts_f4(ts, A, O, .x, C, mode = mode)$f4 /
        ts_f4(ts, A, O, B, C, mode = mode)$f4
      dplyr::tibble(X = .x, A = concat(A), B = concat(B),
                    C = concat(C), O = concat(O), alpha)
    }
  )
}

# multiway statistics -----------------------------------------------------

multiway_stat <- function(ts, stat = c("fst", "divergence"),
                          k, sample_sets, mode, windows, span_normalise) {
  stat <- match.arg(stat)
  node_sets <- purrr::map(sample_sets, function(set) {
    get_node_ids(ts, set)
  })

  n_sets <- length(sample_sets)

  # generate all pairwise indexes required by tskit for more than
  # two sample sets
  indexes <- utils::combn(n_sets, m = k, simplify = FALSE,
                   FUN = function(x) as.integer(x - 1))

  fun <- switch(
    stat,
    "fst" = ts[["Fst"]],
    "divergence" = ts[["divergence"]]
  )
  if (is.null(fun))
    stop("Unknown statistic '", stat, "'", call. = FALSE)

  values <- fun(
    sample_sets = unname(node_sets),
    indexes = indexes,
    mode = mode,
    windows = windows,
    span_normalise = span_normalise
  )
  if (is.matrix(values))
    values <- split(values, col(values))

  if (is.null(names(sample_sets)))
    set_names <- paste0("set_", seq_len(n_sets))
  else
    set_names <- names(sample_sets)

  result <- purrr::map_dfr(indexes, ~ {
    set <- set_names[.x + 1]
    as.data.frame(t(matrix(set)), stringsAsFactors = FALSE)
  }) %>%
    dplyr::as_tibble() %>%
    dplyr::mutate(stat = values)

  result
}

#' Calculate pairwise statistics between sets of individuals
#'
#' For a discussion on the difference between "site", "branch", and "node"
#' options of the \code{mode} argument, please see the tskit documentation at
#' <https://tskit.dev/tskit/docs/stable/stats.html#sec-stats-mode>.
#'
#' @param ts Tree sequence object of the class \code{slendr_ts}
#' @param sample_sets A list (optionally a named list) of character vectors with
#'   individual names (one vector per set)
#' @param mode The mode for the calculation ("sites" or "branch")
#' @param windows Coordinates of breakpoints between windows. The first
#'   coordinate (0) and the last coordinate (equal to \code{ts$sequence_length})
#'   do not have to be specified as they are added automatically.
#' @param span_normalise Divide the result by the span of the window? Default
#'   TRUE, see the tskit documentation for more detail.
#'
#' @return For each pairwise calculation, either a single Fst value or a vector
#'   of Fst values (one for each window)
#'
#' @examples
#' \dontrun{ # compute F_st between two sets of individuals in a given tree sequence ts
#' ts_fst(ts, sample_sets = list(afr = c("AFR_1", "AFR_2", "AFR_3"),
#'                               eur = c("EUR_1", "EUR_2")))
#' }
#' @export
ts_fst <- function(ts, sample_sets, mode = c("site", "branch", "node"),
                   windows = NULL, span_normalise = TRUE) {
  mode <- match.arg(mode)
  if (!is.list(sample_sets)) sample_sets <- as.list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)
  multiway_stat(ts, "fst", k = 2, sample_sets, mode, windows, span_normalise) %>%
    stats::setNames(c("x", "y", "Fst"))
}

#' Calculate pairwise divergence between sets of individuals
#'
#' @rdname ts_fst
#'
#' @return For each pairwise calculation, either a single divergence value or a
#'   vector of divergence values (one for each window)
#'
#' @examples
#' \dontrun{ #' # collect sampled individuals from all populations in a list
#' sample_sets <- ts_samples(ts) %>%
#'   split(., .$pop) %>%
#'   lapply(function(pop) pop$name)
#'
#' # compute the divergence between individuals from each sample set (list of
#' # individual names generated in the previous step)
#' ts_divergence(ts, sample_sets) %>% dplyr::arrange(divergence)
#' }
#'
#' @export
ts_divergence <- function(ts, sample_sets, mode = c("site", "branch", "node"),
                   windows = NULL, span_normalise = TRUE) {
  mode <- match.arg(mode)
  if (!is.list(sample_sets)) sample_sets <- as.list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)
  multiway_stat(ts, "divergence", k = 2, sample_sets, mode, windows, span_normalise) %>%
    stats::setNames(c("x", "y", "divergence"))
}

# oneway statistics -------------------------------------------------------

oneway_stat <- function(ts, stat, sample_sets, mode, windows, span_normalise = NULL) {
  node_sets <- purrr::map(sample_sets, function(set) {
    get_node_ids(ts, set)
  })

  n_sets <- length(sample_sets)

  fun <- switch(
    stat,
    "D" = ts[["Tajimas_D"]],
    "diversity" = ts[["diversity"]],
    "segsites" = ts[["segregating_sites"]]
  )
  if (is.null(fun))
    stop("Unknown statistic '", stat, "'", call. = FALSE)

  args <- list(sample_sets = unname(node_sets),
               mode = mode,
               windows = windows)
  if (!is.null(span_normalise)) args[["span_normalise"]] <- span_normalise

  values <- do.call(fun, args)

  if (is.matrix(values))
    values <- split(values, col(values))

  if (all(sapply(sample_sets, length) == 1))
    set_names <- unlist(sample_sets)
  else if (is.null(names(sample_sets)))
    set_names <- paste0("set_", seq_len(n_sets))
  else
    set_names <- names(sample_sets)

  result <- dplyr::tibble(set = set_names)
  result[[stat]] <- values
  result
}

#' Calculate the density of segregating sites for the given sets of individuals
#'
#' @inheritParams ts_tajima
#' @param span_normalise Divide the result by the span of the window? Default
#'   TRUE, see the tskit documentation for more detail.
#'
#' @return For each set of individuals either a single diversity value or a
#'   vector of diversity values (one for each window)
#'
#' @export
ts_segregating <- function(ts, sample_sets, mode = c("site", "branch", "node"),
                           windows = NULL, span_normalise = TRUE) {
  mode <- match.arg(mode)
  if (!is.list(sample_sets)) sample_sets <- as.list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)
  oneway_stat(ts, "segsites", sample_sets, mode, windows, span_normalise)
}

#' Calculate diversity in given sets of individuals
#'
#' @inheritParams ts_tajima
#' @param span_normalise Divide the result by the span of the window? Default
#'   TRUE, see the tskit documentation for more detail.
#'
#' @return For each set of individuals either a single diversity value or a
#'   vector of diversity values (one for each window)
#'
#' @examples
#' \dontrun{ #' # collect sampled individuals from all populations in a list
#' sample_sets <- ts_samples(ts) %>%
#'   split(., .$pop) %>%
#'   lapply(function(pop) pop$name)
#'
#' # compute diversity in each population based on sample sets extracted
#' # in the previous step
#' ts_diversity(ts, sample_sets) %>% dplyr::arrange(diversity)
#' }
#'
#' @export
ts_diversity <- function(ts, sample_sets, mode = c("site", "branch", "node"),
                         windows = NULL, span_normalise = TRUE) {
  mode <- match.arg(mode)
  if (!is.list(sample_sets)) sample_sets <- as.list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)
  oneway_stat(ts, "diversity", sample_sets, mode, windows, span_normalise)
}

#' Calculate Tajima's D for given sets of individuals
#'
#' For a discussion on the difference between "site" and "branch" options of the
#' \code{mode} argument, please see the tskit documentation at
#' <https://tskit.dev/tskit/docs/stable/stats.html#sec-stats-mode>
#'
#' @param ts Tree sequence object of the class \code{slendr_ts}
#' @param sample_sets A list (optionally a named list) of character vectors with
#'   individual names (one vector per set). If a simple vector is provided, it
#'   will be interpreted as \code{as.list(sample_sets)}, meaning that a given
#'   statistic will be calculated for each individual separately.
#' @param mode The mode for the calculation ("sites" or "branch")
#' @param windows Coordinates of breakpoints between windows. The first
#'   coordinate (0) and the last coordinate (equal to \code{ts$sequence_length})
#'   are added automatically)
#'
#' @return For each set of individuals either a single Tajima's D value or a
#'   vector of Tajima's D values (one for each window)
#'
#' @examples
#' \dontrun{ # calculate Tajima's D for given sets of individuals in a tree sequence ts
#' ts_tajima(ts, list(afr = c("AFR_1", "AFR_2", "AFR_3"),
#'                    eur = c("EUR_1", "EUR_2")))
#' }
#'
#' @export
ts_tajima <- function(ts, sample_sets, mode = c("site", "branch", "node"),
                      windows = NULL) {
  mode <- match.arg(mode)
  if (!is.list(sample_sets)) sample_sets <- as.list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)
  oneway_stat(ts, "D", sample_sets, mode, windows)
}

# other statistics --------------------------------------------------------

#' Compute the allele frequency spectrum (AFS)
#'
#' This function computes the AFS with respect to the given set of individuals
#'
#' For more information on the format of the result and dimensions, in
#' particular the interpretation of the first and the last element of the AFS,
#' please see the tskit manual at
#' <https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.allele_frequency_spectrum>
#'
#' @param ts Tree sequence object of the class \code{slendr_ts}
#' @param sample_sets A list (optionally a named list) of character vectors with
#'   individual names (one vector per set). If NULL, allele frequency spectrum
#'   for all individuals in the tree sequence will be computed.
#' @param mode The mode for the calculation ("sites" or "branch")
#' @param windows Coordinates of breakpoints between windows. The first
#'   coordinate (0) and the last coordinate (equal to \code{ts$sequence_length})
#'   are added automatically)
#' @param polarised When FALSE (the default) the allele frequency spectrum will
#'   be folded (i.e. the counts will not depend on knowing which allele is
#'   ancestral)
#' @param span_normalise Argument passed to tskit's \code{allele_frequency_spectrum}
#'   method
#'
#' @return Either a single Fst value or a vector of Fst values (one for each
#'   window)
#'
#' @export
ts_afs <- function(ts, sample_sets = NULL, mode = c("site", "branch", "node"),
                   windows = NULL, span_normalise = FALSE,
                   polarised = FALSE) {
  mode <- match.arg(mode)
  if (is.null(sample_sets))
    sample_sets <- list(ts_samples(ts)$name)
  else if (!is.list(sample_sets))
    sample_sets <- as.list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)

  node_sets <- purrr::map(sample_sets, function(set) {
    get_node_ids(ts, set)
  })

  result <- ts$allele_frequency_spectrum(
    sample_sets = unname(node_sets),
    mode = mode,
    windows = windows,
    span_normalise = span_normalise,
    polarised = polarised
  )

  # drop the useless 0-th element when there's no windowing
  if (is.null(windows)) result <- result[-1]

  result
}


# private tree sequence utility functions ---------------------------------

# Function for extracting numerical node IDs for various statistics
get_node_ids <- function(ts, x) {
  if (is.null(x)) {
    ts_data(ts) %>%
      dplyr::filter(!is.na(name)) %>%
      .$node_id %>%
      return()
  } else if (is.numeric(x)) {
    return(as.integer(x))
  } else if (is.character(x)) {
    ts_data(ts) %>%
      dplyr::filter(name %in% x) %>%
      .$node_id %>%
      return()
  } else
    stop("Unknown data given as individual names or node IDs", call. = FALSE)
}

# Extract information from the nodes table
get_ts_nodes <- function(ts) {
  table <- ts$tables$nodes

  node_table <- dplyr::tibble(
    node_id = as.integer(seq_len(table$num_rows) - 1),
    ind_id = ifelse(table$individual == -1, NA, table$individual),
    pop_id = as.integer(table$population)
  )

  # in case of slendr tree sequences, convert times to the model time units
  model <- attr(ts, "model")
  if (!is.null(model)) {
    node_table$time <- time_fun(ts)(table$time, model)
    node_table$time_tskit <- table$time
  } else
    node_table$time <- table$time

  node_table
}

# Extract information from the table of individual table
get_ts_individuals <- function(ts) {
  model <- attr(ts, "model")

  table <- ts$tables$individuals

  ind_table <- dplyr::tibble(
    ind_id = seq_len(ts$num_individuals) - 1
  )

  if (attr(ts, "source") == "SLiM") {
    # reticulate::py_run_string("def get_pedigree_ids(ts): return [ind.metadata['pedigree_id'] for ind in ts.individuals()]")

    ind_table <- dplyr::tibble(
      ind_table,
      # pedigree_id = pylib$get_pedigree_ids(ts),
      pedigree_id = reticulate::py$get_pedigree_ids(ts),
      raster_x = ts$individual_locations[, 1],
      raster_y = ts$individual_locations[, 2],
      pop_id = ts$individual_populations,
      alive = bitwAnd(table[["flags"]], pyslim$INDIVIDUAL_ALIVE) != 0,
      remembered = bitwAnd(table[["flags"]], pyslim$INDIVIDUAL_REMEMBERED) != 0,
      retained = bitwAnd(table[["flags"]], pyslim$INDIVIDUAL_RETAINED) != 0
    )

  if (!is.null(model)) {
    ind_table$time <- time_fun(ts)(ts$individual_times, model)
    ind_table$time_tskit <- ts$individual_times
  } else
    ind_table$time <- ts$individual_times

  } else {
      nodes_table <- dplyr::tibble(
        ind_id = ts$tables$nodes$individual,
        pop_id = ts$tables$nodes$population
      )

      if (!is.null(model)) {
        nodes_table$time <- time_fun(ts)(ts$tables$nodes$time, model)
        nodes_table$time_tskit <- ts$tables$nodes$time
      } else
        nodes_table$time <- ts$tables$nodes$time

      nodes_table <- dplyr::distinct(nodes_table)

      ind_table <- dplyr::inner_join(ind_table, nodes_table, by = "ind_id")
  }

  ind_table %>% dplyr::select(ind_id, time, dplyr::everything())
}

# Extract information from the edges table
get_ts_edges <- function(ts) {
  table <- ts$tables$edges
  dplyr::tibble(
    id = seq_len(table$num_rows) - 1,
    child = as.vector(table[["child"]]),
    parent = as.vector(table[["parent"]]),
    left = as.vector(table[["left"]]),
    right = as.vector(table[["right"]])
  )
}

# Extract information from the muations table
get_ts_mutations <- function(ts) {
  model <- attr(ts, "model")
  table <- ts$tables$mutations
  if (is.null(model))
    time <- table[["time"]]
  else
    time <- time_fun(ts)(as.vector(table[["time"]]), model)
  dplyr::tibble(
    id = seq_len(table$num_rows) - 1,
    site = as.vector(table[["site"]]),
    node = as.vector(table[["node"]]),
    time = time
  )
}

time_fun <- function(ts) {
  if (attr(ts, "source") == "SLiM")
    convert_slim_time
  else
    convert_msprime_time
}

get_slim_table_data <- function(ts, model, spatial, simplify_to = NULL) {
  # get data from the original individual table
  individuals <- attr(ts, "individuals")

  if (!is.null(model))
    individuals$pop <- model$splits$pop[individuals$pop_id + 1]
  else
    individuals$pop <- individuals$pop_id

  individuals <- dplyr::arrange(individuals, -time, pop)

  # load information about samples at times and from populations of remembered
  # individuals
  if (!is.null(model)) {
    samples <- attr(ts, "metadata")$sampling %>% dplyr::arrange(-time, pop)
    if (!is.null(simplify_to))
      samples <- samples %>% dplyr::filter(name %in% simplify_to)
  } else
    samples <- dplyr::filter(individuals, sampled) %>% dplyr::select(time, pop)

  # split individuals into sampled (those explicitly sampled, to which we
  # will add readable names from the sampling schedule table) and not sampled
  # (either "anonymous" individuals or also remembered individuals which should
  # not be regarded for simplification)
  sampled <- dplyr::filter(individuals, sampled) %>%
    dplyr::select(-time, -pop) %>%
    dplyr::bind_cols(samples)

  not_sampled <- dplyr::filter(individuals, !sampled)

  # get data from the original nodes table to get node assignments for each
  # individual but also nodes which are not associated with any individuals
  # (i.e. those added through recapitation by msprime)
  nodes <- get_ts_nodes(ts)

  # add numeric node IDs to each individual
  combined <-
    dplyr::bind_rows(sampled, not_sampled) %>%
    dplyr::right_join(nodes, by = "ind_id") %>%
    dplyr::mutate(time = ifelse(is.na(ind_id), time.y, time.x),
                  sampled = ifelse(is.na(ind_id), FALSE, sampled))

  if (spatial) {
    combined <- convert_to_sf(combined, model)
    location_cols <- "location"
  } else
    location_cols <- NULL

  if (!is.null(model)) {
    combined$pop <- factor(combined$pop, levels = order_pops(model$populations, model$direction))
    slendr_cols <- c("name", "pop")
  } else
    slendr_cols <- "pop"

  combined <- dplyr::select(
    combined, !!slendr_cols, ind_id, node_id, time, !!location_cols,
    sampled, remembered, retained, alive, pedigree_id
  )

  if (spatial)
    combined
  else
    dplyr::as_tibble(combined)
}

get_msprime_table_data <- function(ts, model, simplify_to = NULL) {
  # load information about samples at times and from populations of remembered
  # individuals
  samples <- attr(ts, "metadata")$sampling
  if (!is.null(samples)) {
    if (!is.null(simplify_to))
      samples <- dplyr::filter(samples, name %in% simplify_to)
    samples <- dplyr::arrange(samples, -time, pop)
  }

  # get data from the original individual table
  individuals <- attr(ts, "individuals")

  if (!is.null(model)) {
    individuals <- individuals %>%
      dplyr::mutate(pop = model$splits$pop[pop_id + 1]) %>%
      dplyr::arrange(-time, pop) %>%
      dplyr::mutate(name = samples$name, sampled = TRUE)
  }

  # get data from the original nodes table to get node assignments for each
  # individual but also nodes which are not associated with any individuals
  # (i.e. those added through recapitation by msprime)
  nodes <- get_ts_nodes(ts)

  # add numeric node IDs to each individual
  combined <- dplyr::select(individuals, -time, -pop_id) %>%
    dplyr::right_join(nodes, by = "ind_id")

  if (is.null(model)) {
    combined <- dplyr::rename(combined, pop = pop_id)
    name_col <- NULL
  } else {
    combined <- combined %>%
      dplyr::mutate(pop = model$splits$pop[pop_id + 1])
    combined$pop <- factor(combined$pop, levels = order_pops(model$populations, model$direction))
    name_col <- "name"
  }
  combined %>%
    dplyr::select(!!name_col, pop, ind_id, node_id, time, sampled) %>%
    dplyr::mutate(sampled = !is.na(sampled))
}

get_sf_branches <- function(tree) {
  data <- attr(tree, "data")

  # only generate the sf branches object if the tree is spatial
  if (!inherits(data, "sf")) return(NULL)

  if (any(sf::st_is_empty(data$location))) {
    warning("Not all nodes have a known spatial location. Maybe you ran a neutral\n",
            "non-spatial coalescent recapitation after a spatial SLiM simulation?\n",
            "The returned phylogenetic tree will not have spatial information\n",
            "associated with it. If this is a problem, run a longer spatial\n",
            "simulation, perhaps by adding a burnin phase.", call. = FALSE)
    return(NULL)
  }

  # prepare a table of spatial branch start-end locations and times which will
  # be saved in the ts_phylo result metadata (below)
  edges <- dplyr::tibble(parent = tree$edge[, 1], child = tree$edge[, 2])

  # create a new table of node times/locations by running a join operation
  # against the `edges` table above
  parent_nodes <- data %>%
    dplyr::as_tibble() %>%
    dplyr::filter(phylo_id %in% edges$parent) %>%
    dplyr::select(parent_pop = pop,
                  parent_phylo_id = phylo_id, parent_node_id = node_id,
                  parent_time = time, parent_location = location) %>%
    dplyr::left_join(edges, by = c("parent_phylo_id" = "parent")) %>%
    dplyr::arrange(parent_phylo_id)

  # take the `parent_nodes` able above and do another join operation, this time
  # with the table of child nodes' times/locations
  branch_nodes <- data %>%
    dplyr::as_tibble() %>%
    dplyr::filter(phylo_id %in% edges$child) %>%
    dplyr::select(child_pop  = pop,
                  child_phylo_id = phylo_id, child_node_id = node_id,
                  child_time = time, child_location = location) %>%
    dplyr::inner_join(parent_nodes, by = c("child_phylo_id" = "child")) %>%
    dplyr::arrange(child_phylo_id)

  # transforming individual child/parent location columns (type POINT) into a
  # line (type LINESTRING)
  connections <- purrr::map2(
    branch_nodes$child_location, branch_nodes$parent_location, ~
      sf::st_union(.x, .y) %>%
      sf::st_cast("LINESTRING") %>%
      sf::st_sfc() %>%
      sf::st_sf(connection = ., crs = sf::st_crs(branch_nodes))) %>%
    dplyr::bind_rows()

  # create an sf table with all the locations in columns (child_location,
  # parent_location, connect)
  branches <-
    dplyr::bind_cols(branch_nodes, connections) %>%
    sf::st_set_geometry("connection") %>%
    dplyr::select(parent_phylo_id, child_phylo_id,
                  connection,
                  parent_time, child_time,
                  parent_pop, child_pop,
                  parent_node_id, child_node_id,
                  parent_location, child_location) %>%
    sf::st_set_crs(sf::st_crs(data))

  model <- attr(tree, "model")
  pop_names <- order_pops(model$populations, model$direction)

  branches$child_pop <- factor(branches$child_pop, levels = pop_names)
  branches$parent_pop <- factor(branches$parent_pop, levels = pop_names)

  branches
}

#' Convert an annotated \code{slendr_phylo} object to a \code{phylo} object
#'
#' This function servers as a workaround around a ggtree error:
#'   \code{Error in UseMethod("as.phylo") :
#'     no applicable method for 'as.phylo' applied to an object of class
#'     "c('phylo', 'slendr_phylo')"}
#'
#' @param x Tree object of the class \code{slendr_phylo}
#'
#' @importFrom ape as.phylo
#' @export as.phylo.slendr_phylo
#' @export
as.phylo.slendr_phylo <- function(x) { class(x) <- "phylo"; x }

check_ts_class <- function(x) {
  if (!inherits(x, "slendr_ts"))
    stop("Not a tree sequence object created by ts_load, ts_simplify, ts_recapitate or ts_mutate", call. = FALSE)
}

# Collect all ancestors of a given node up to the root by traversing the tree
# edges "bottom-up" using a queue
collect_ancestors <- function(x, edges) {
  # list for collecting paths (i.e. sets of edges) leading from the focal node
  # to the root
  result <- list()

  # initialize the counter of nodes already processed by the queue
  n_nodes <- length(unique(c(edges$child, edges$parent)))
  processed_nodes <- vector(length = n_nodes + 1)

  # initialize the queue with all edges leading from the focal node
  edge <- edges[edges$child %in% x, ] %>% dplyr::mutate(level = 1)
  queue <- split(edge, edge$child)

  # repeat until the queue is empty (this homebrew queue implementation is
  # probably horribly inefficient but it will do for now)
  i <- 0
  while (TRUE) {
    #cat("queue ", (i <- i + 1), "\n")
    # pop out the first element
    item <- queue[[1]]; queue[[1]] <- NULL

    # add it to the final list
    result[[length(result) + 1]] <- item

    # iterate over all parents of the current node
    p <- 0
    for (parent in split(item, item$parent)) {
      #cat("queue ", i, " parent ", (p <- i + 1), "\n")
      # get edges leading from the current parent to its own parent
      edge <- edges[edges$child == unique(parent$parent), ]

      # if the parent has no parent itself or its node has already been
      # processed, skip it and don't add it to the queue
      if (nrow(edge) == 0) next
      if (processed_nodes[unique(edge$child) + 1]) next

      # mark the node as processed...
      processed_nodes[unique(edge$child) + 1] <- TRUE
      # ... and add it to the queue
      edge$level <- item$level[1] + 1
      queue[[length(queue) + 1]] <- edge
    }

    if (length(queue) == 0) break
  }

  result <- dplyr::bind_rows(result) %>%
    dplyr::select(child_id = child, parent_id = parent, left, right, level)

  result
}

# Collect all descendants of a given node down to the leaves of he tree by
# traversing the tree edges "top-down" using a queue
collect_descendants <- function(x, edges) {
  # list for collecting paths (i.e. sets of edges) leading from the focal node
  # to the root
  result <- list()

  # initialize the counter of nodes already processed by the queue
  n_nodes <- length(unique(c(edges$child, edges$parent)))
  processed_nodes <- vector(length = n_nodes + 1)

  # initialize the queue with all edges leading from the focal ancestor
  edge <- edges[edges$parent == x, ] %>% dplyr::mutate(level = 1)
  queue <- split(edge, edge$child)

  # repeat until the queue is empty (this homebrew queue implementation is
  # probably horribly inefficient but it will do for now)
  i <- 0
  while (TRUE) {
    cat("queue ", (i <- i + 1), "\n")
    # pop out the first element
    item <- queue[[1]]; queue[[1]] <- NULL

    # add it to the final list
    result[[length(result) + 1]] <- item

    for (child in split(item, item$child)) {
      # browser()
      #cat("queue ", i, " parent ", (p <- i + 1), "\n")
      # get edges leading from the current child to its own children
      edge <- edges[edges$parent == child$child, ]

      # if the child has no children itself or its node has already been
      # processed, skip it and don't add it to the queue
      already_processed <- processed_nodes[unique(edge$child) + 1]
      edge <- edge[!already_processed, ]
      if (nrow(edge) == 0) next

      # mark the node as processed...
      processed_nodes[unique(edge$child) + 1] <- TRUE
      # ... and add it to the queue
      edge$level <- item$level[1] + 1
      queue[[length(queue) + 1]] <- edge
    }

    if (length(queue) == 0) break
  }

  result <- dplyr::bind_rows(result) %>%
    dplyr::select(child_id = child, parent_id = parent, left, right, level)

  result
}

# Convert SLiM's dictionaries with the sampling schedule table to
# a normal R data frame
get_sampling <- function(metadata) {
  # again, because of how SLiM's dictionaries are structured, a bit of
  # data munging needs to be performed in order to get a simple data frame
  if (metadata$backend == "SLiM") {
    sampling <- purrr::transpose(metadata$sampling) %>%
      dplyr::as_tibble() %>%
      tidyr::unnest(cols = c("n", "pop", "time_gen", "time_orig"))
  } else
    sampling <- dplyr::as_tibble(metadata$sampling)

  sampling %>%
    dplyr::select(-time_gen) %>%
    {
      rbind(
        dplyr::filter(., n == 1),
        dplyr::filter(., n > 1) %>% .[rep(seq_len(nrow(.)), .$n), ]
      )
    } %>%
    dplyr::group_by(pop) %>%
    dplyr::mutate(name = paste0(pop, "_", 1:dplyr::n())) %>%
    dplyr::ungroup() %>%
    dplyr::arrange(-time_orig, pop) %>%
    dplyr::rename(time = time_orig) %>%
    dplyr::select(name, time, pop)
}

# Extract list with slendr metadata (created as Eidos Dictionaries by SLiM)
get_slendr_metadata <- function(ts) {
  # SLiM forces metadata into a certain structure, so the slendr metadata
  # must be extracted differently for the two backends
  if (attr(ts, "source") == "SLiM") {
    metadata <- ts$metadata$SLiM$user_metadata$slendr[[1]]
    arguments <- metadata$arguments[[1]]
  } else {
    metadata <- ts$metadata$slendr
    arguments <- metadata$arguments
  }

  list(
    version = metadata$version,
    description = metadata$description,
    sampling = get_sampling(metadata),
    map = metadata$map[[1]],
    arguments = arguments
  )
}

get_biallelic_indices <- function(ts) {
  gts <- ts$genotype_matrix()
  biallelic_pos <- rowSums(gts == 0 | gts == 1) == ncol(gts)
  biallelic_pos
}

# Convert a data frame of information extracted from a tree sequence
# table to an sf spatial object
convert_to_sf <- function(df, model) {
  crs <- if (is.null(model)) NA else sf::st_crs(model$world)

  with_locations <- df[stats::complete.cases(df[, c("raster_x", "raster_y")]), ]
  without_locations <- df[!stats::complete.cases(df[, c("raster_x", "raster_y")]), ]

  if (is.null(model)) {
    with_locations <- dplyr::rename(with_locations, x = raster_x, y = raster_y)
  } else {
    # reproject coordinates to the original crs
    with_locations <- reproject(
      from = "raster", to = crs, coords = with_locations, model = model,
      input_prefix = "raster_", output_prefix = "", add = TRUE
    )
  }

  result <- sf::st_as_sf(with_locations,
                         coords = c("x", "y"),
                         crs = crs) %>%
    dplyr::rename(location = geometry)

  # directly binding with without_locations which has no rows lead to an error:
  # 'Error: Assigned data `x[[all_sfc_columns[i]]]` must be compatible with
  # existing data.' (similar issue reported here:
  # https://github.com/mtennekes/tmap/issues/551)
  if (nrow(without_locations))
    result <- dplyr::bind_rows(result, without_locations)

  result
}

define_windows <- function(ts, breakpoints) {
  unique(c(0, breakpoints, ts$sequence_length))
}

concat <- function(x) {
  paste(x, collapse = "+")
}
