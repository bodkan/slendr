# tree-sequence processing ------------------------------------------------
#
# #' Load a tree-sequence file produced by a given model (optionally simplifying
#' only to remembered individuals)
#'
#' @param file Path to a tree-sequence file generated by SLiM
#' @param model Object of the class \code{slendr_model}
#' @param simplify Should the tree-sequence be simplified down to only
#'   remembered (i.e. "sampled", in \textit{slendr} parlance) individuals?
#'
#' @return SlimTreeSequence object
#'
#' @export
ts_load <- function(file, model, simplify = FALSE) {
  ts <- pyslim$load(normalizePath(file))

  # decorate the SlimTreeSequence object with a table of individuals
  attr(ts, "info") <- get_individuals(ts, model)
  class(ts) <- c("slendr_ts", class(ts))

  if (simplify)
    return(ts_simplify(ts))
  else
    return(ts)
}

#' Add mutations to the given tree-sequence
#'
#' @param ts Object of the type SlimTreeSequence
#' @param mutation_rate Mutation rate used by msprime to simulate mutations
#'
#' @return SlimTreeSequence object
#'
#' @export
ts_mutate <- function(ts, mutation_rate) {
  if (!inherits(ts, "slendr_ts")) stop("Not a tree sequence object created by ts_load, ts_simplify or ts_muate", call. = FALSE)

  ts_mutated <-
    msprime$mutate(ts, rate = mutation_rate, keep = TRUE) %>%
    pyslim$SlimTreeSequence()

    # decorate the SlimTreeSequence object with a table of individuals
  attr(ts_mutated, "info") <- attr(ts, "info")
  class(ts_mutated) <- c("slendr_ts", class(ts_mutated))

  ts_mutated
}

#' Extract table of individuals from pyslim's tree-sequence object
#'
#' @param ts SlimTreeSequence object
#' @param model \code{slendr_model} object of a model that generated the data
#'
#' @return Data frame with individual information from the input tree-sequence
#'   object
#'
#' @export
ts_individuals <- function(ts) {
  if (!inherits(ts, "slendr_ts")) stop("Not a tree sequence object created by ts_load, ts_simplify or ts_muate", call. = FALSE)
  attr(ts, "info")
}

#' Simplify tree-sequence object down to only remembered (i.e. "sampled", in
#' \textit{slendr} parlance) individuals
#'
#' @param ts SlimTreeSequence object
#'
#' @return @return SlimTreeSequence object accessed via the reticulate package
#'
#' @export
ts_simplify <- function(ts) {
  if (!inherits(ts, "slendr_ts")) stop("Not a tree sequence object created by ts_load, ts_simplify or ts_muate", call. = FALSE)

  individuals <- attr(ts, "info")

  node_ids <- dplyr::filter(individuals, remembered) %>%
    dplyr::select(chr1_id, chr2_id) %>%
    unlist() %>%
    as.integer()

  new_ts <- ts$simplify(node_ids)

  # decorate the SlimTreeSequence object with a table of individuals
  attr(new_ts, "info") <- get_individuals(new_ts, model)

  class(new_ts) <- c("slendr_ts", class(new_ts))
  new_ts
}

#' Extract genotype table from the tree-sequence
#'
#' @param ts SlimTreeSequence object
#'
#' @return Data frame object of the class \code{tibble}
#'
#' @export
ts_genotypes <- function(ts) {
  genotypes <- ts$genotype_matrix()
  colnames(genotypes) <-
    ts_individuals(ts) %>%
    dplyr::select(chr1, chr2) %>%
    unlist() %>%
    as.character()
  dplyr::as_tibble(genotypes) %>%
    dplyr::mutate(pos = ts$tables$sites$position) %>%
    dplyr::select(pos, dplyr::everything())
}

#' Extract genotypes from the tree-sequence in the EIGENSTRAT format
#'
#' @param ts SlimTreeSequence object
#' @param prefix EIGENSTRAT trio prefix
#'
#' @return Object of the class EIGENSTRAT created by the admixr package
#'
#' @export
ts_eigenstrat <- function(ts, prefix, chrom = "chr1", quiet = FALSE) {
  chrom_genotypes <- ts_genotypes(ts)
  chr1_genotypes <- dplyr::select(chrom_genotypes, dplyr::ends_with("_chr1"))
  chr2_genotypes <- dplyr::select(chrom_genotypes, dplyr::ends_with("_chr2"))

  # create a geno file table
  geno <- dplyr::as_tibble(2 - chr1_genotypes + chr2_genotypes)
  colnames(geno) <- ts_individuals(ts)$name

  # create an ind file table
  ind <- ts_individuals(ts) %>%
    dplyr::mutate(sex = "U") %>%
    dplyr::select(id = name, sex, label = name)

  # create a snp file table
  positions <- round(ts$tables$sites$position)
  snp <- dplyr::tibble(
    id = sprintf("%s_%s", chrom, as.character(positions)),
    chrom = chrom,
    gen = 0.0,
    pos = positions,
    ref = "G",
    alt = "T"
  )

  dup_muts <- duplicated(positions)
  if (any(dup_muts)) {
    message(sum(dup_muts), " mutations (out of ", nrow(snp), ") have been ",
            "removed because they appeared on a position already occupied by ",
            "another mutation")
    snp <- snp[!dup_muts, ]
    geno <- geno[!dup_muts, ]
  }

  # save the EIGENSTRAT trio
  if (!dir.exists(dirname(prefix))) dir.create(dirname(prefix))
  admixr::write_geno(geno, paste0(prefix, ".geno"))
  admixr::write_snp(snp, paste0(prefix, ".snp"))
  admixr::write_ind(ind, paste0(prefix, ".ind"))

  # return the admixr eigenstrat object
  admixr::eigenstrat(prefix = prefix)
}

# tree-sequence statistics ------------------------------------------------

#' @rdname ts_f4ratio
ts_f2 <- function(ts, A, B, mode = c("site", "branch"), ...) {
  mode <- match.arg(mode)

  nodes_a <- ts_nodes(ts, A)
  nodes_b <- ts_nodes(ts, B)

  dplyr::tibble(
    A = concat(A),
    B = concat(B),
    f2 = ts$f2(sample_sets = list(nodes_a, nodes_b), mode = mode, ...)
  )
}

#' @rdname ts_f4ratio
ts_f3 <- function(ts, A, B, C, mode = c("site", "branch"), ...) {
  mode <- match.arg(mode)

  nodes_a <- ts_nodes(ts, A)
  nodes_b <- ts_nodes(ts, B)
  nodes_c <- ts_nodes(ts, C)

  dplyr::tibble(
    A = concat(A),
    B = concat(B),
    C = concat(C),
    f3 = ts$f3(sample_sets = list(nodes_a, nodes_b, nodes_c), mode = mode, ...)
  )
}

#' @rdname ts_f4ratio
ts_f4 <- function(ts, W, X, Y, Z, mode = c("site", "branch"), ...) {
  mode <- match.arg(mode)

  nodes_w <- ts_nodes(ts, W)
  nodes_x <- ts_nodes(ts, X)
  nodes_y <- ts_nodes(ts, Y)
  nodes_z <- ts_nodes(ts, Z)

  dplyr::tibble(
    W = concat(W),
    X = concat(X),
    Y = concat(Y),
    Z = concat(Z),
    f4 = ts$f4(sample_sets = list(nodes_w, nodes_x, nodes_y, nodes_z), mode = mode, ...)
  )
}

#' Calculate the f2, f3, f4, and f4-ratio statistics
#'
#' @param ts SlimTreeSequence object
#' @param w,x,y,z,a,b,c,o Character vectors of  individual names (following the
#'   nomenclature of Patterson \textit{et al.} 2021)
#'
#' @return Numeric estimate of ancestry proportion
#'
#' @export
ts_f4ratio <- function(ts, X, A, B, C, O, mode = c("site", "branch")) {
  mode <- match.arg(mode)

  purrr::map_dfr(
    X, function(.x) {
      alpha <- ts_f4(ts, A, O, .x, C, mode = mode)$f4 / ts_f4(ts, A, O, B, C, mode = mode)$f4
      dplyr::tibble(X = .x, A = concat(A), B = concat(B), C = concat(C), O = concat(O), alpha)
    }
  )
}

#' Extract the nodes belonging to the given individuals
#'
#' @param ts SlimTreeSequence object
#' @param ind A character vector of individual names
#'
#' @return An integer vector with node numbers
#'
#' @export
ts_nodes <- function(ts, ind) {
  if (!inherits(ts, "slendr_ts")) stop("Not a tree sequence object created by ts_load, ts_simplify or ts_muate", call. = FALSE)

  attr(ts, "info") %>%
    dplyr::filter(name == ind) %>%
    dplyr::select(chr1_id, chr2_id) %>%
    unlist() %>%
    as.integer()
}


# tree-sequence utility functions -----------------------------------------

concat <- function(x) paste(x, sep = "+")


get_individuals <- function(ts, model) {
  # extract information about individuals from the tree-sequence
  individuals <-
    purrr::map_dfr(seq(0, ts$num_individuals - 1), function(i) {
      ind <- ts$individual(i)
      list(
        id = ind["id"],
        pedigree_id = ind["metadata"]["pedigree_id"],
        chr1_id = ind["nodes"][1],
        chr2_id = ind["nodes"][2],
        time = ind["time"],
        loc_x = ind["location"][1],
        loc_y = ind["location"][2],
        pop_id = ind["metadata"]["subpopulation"],
        flag = ind["flags"],
        alive = bitwAnd(ind["flags"], pyslim$INDIVIDUAL_ALIVE) != 0,
        remembered = bitwAnd(ind["flags"], pyslim$INDIVIDUAL_REMEMBERED) != 0,
        retained = bitwAnd(ind["flags"], pyslim$INDIVIDUAL_RETAINED) != 0
      )
    }) %>%
    dplyr::mutate(pop = model$splits$pop[pop_id + 1]) %>%
    dplyr::arrange(-time, pop) %>%
    dplyr::select(-pop, -time)

  # load sampling times table (expand multiple samplings at a single time point
  # into one record per each individual to matche the number of rows in the
  # table extract from the tree-sequence above)
  samples <- file.path(model$path, "script_samples.tsv") %>%
    readr::read_tsv(col_types = "ciii") %>%
    {
      rbind(
        dplyr::filter(., n == 1),
        dplyr::filter(., n > 1) %>% .[rep(seq_len(nrow(.)), .$n), ]
      )
    } %>%
    dplyr::group_by(pop) %>%
    dplyr::mutate(name = paste0(pop, 1:dplyr::n()),
                  chr1 = paste0(pop, 1:dplyr::n(), "_chr1"),
                  chr2 = paste0(pop, 1:dplyr::n(), "_chr2")) %>%
    dplyr::ungroup() %>%
    dplyr::arrange(-time_orig, pop) %>%
    dplyr::rename(time = time_orig) %>%
    dplyr::select(pop, name, time, chr1, chr2)

  # splits individuals extracted from the tree-sequence into those remembered
  # (i.e. individuals present in the sampling table) and those that are not
  remembered <- dplyr::filter(individuals, remembered)
  not_remembered <- dplyr::filter(individuals, !remembered)

  # combine everything together - first merge sampling information for
  # remembered individuals, then concatenate this with everyone else
  combined <-
    cbind(remembered, samples) %>%
    dplyr::bind_rows(not_remembered) %>%
    dplyr::select(name, id, pop, time, chr1_id, chr2_id,
                  chr1, chr2, loc_x, loc_y, pedigree_id,
                  dplyr::everything()) %>%
    dplyr::as_tibble()

  combined
}

# get_individuals <- function(ts, model) {
#   # extract information about individuals from the tree-sequence
#   individuals <-
#     purrr::map_dfr(seq(0, ts$num_individuals - 1), function(i) {
#       ind <- ts$individual(i)
#       list(
#         id = ind["id"],
#         pedigree_id = ind["metadata"]["pedigree_id"],
#         chr1_id = ind["nodes"][1],
#         chr2_id = ind["nodes"][2],
#         loc_x = ind["location"][1],
#         loc_y = ind["location"][2],
#         pop_id = ind["metadata"]["subpopulation"],
#         flag = ind["flags"],
#         alive = bitwAnd(ind["flags"], pyslim$INDIVIDUAL_ALIVE) != 0,
#         remembered = bitwAnd(ind["flags"], pyslim$INDIVIDUAL_REMEMBERED) != 0,
#         retained = bitwAnd(ind["flags"], pyslim$INDIVIDUAL_RETAINED) != 0
#       )
#     })
#
#   # load sampling times table
#   samples <- file.path(model$path, "script_samples.tsv") %>%
#     readr::read_tsv(col_types = "ciii") %>%
#     {
#       rbind(
#         dplyr::filter(., n == 1),
#         dplyr::filter(., n > 1) %>% .[rep(seq_len(nrow(.)), .$n), ]
#       )
#     } %>%
#     dplyr::group_by(pop) %>%
#     dplyr::mutate(name = paste0(pop, 1:dplyr::n()),
#                   chr1 = paste0(pop, 1:dplyr::n(), "_chr1"),
#                   chr2 = paste0(pop, 1:dplyr::n(), "_chr2")) %>%
#     dplyr::ungroup() %>%
#     dplyr::rename(time = time_orig) %>%
#     dplyr::arrange(-time) %>%
#     dplyr::select(pop, name, time, chr1, chr2)
#
#   remembered <- dplyr::filter(individuals, remembered)
#   not_remembered <- dplyr::filter(individuals, !remembered)
#
#   combined <-
#     cbind(remembered, samples) %>%
#     dplyr::bind_rows(not_remembered) %>%
#     dplyr::select(name, id, pop, time, chr1_id, chr2_id,
#                   chr1, chr2, loc_x, loc_y, pedigree_id,
#                   dplyr::everything()) %>%
#     dplyr::as_tibble()
#
#   combined
# }
