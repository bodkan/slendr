[{"path":"https://bodkan.net/slendr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 Martin Petr Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-00-installation.html","id":"quick-installation","dir":"Articles","previous_headings":"","what":"Quick installation","title":"Installation instructions","text":"slendr available CRAN R package repository. , can install simply executing install.packages(\"slendr\") R console. want (need) get development version, can install directly GitHub executing devtools::install_github(\"bodkan/slendr\") via R package devtools (can gen devtools running install.packages(\"devtools\")). fact, decide try slendr, please make sure update regularly keep eye changelog regular basis! can find information latest bugfixes potential breaking changes. install slendr, calling library(slendr) check software dependencies available. , R package provide brief helpful guide resolve potential issues. rest vignette talks necessary software dependencies bit detail. Please note slendr extensively tested macOS Linux moment. However, experimental support runnig SLiM msprime simulations Windows analyzing tree-sequence outputs using tskit interface platform well. Feedback issues using slendr Windows highly appreciated.","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-00-installation.html","id":"software-dependencies","dir":"Articles","previous_headings":"","what":"Software dependencies","title":"Installation instructions","text":"slendr relies three main software dependencies: geospatial data analysis R package sf (encoding spatial slendr models analysing spatial tree-sequence data), forward population genetic simulator SLiM (forward simulations), Python modules tskit, msprime, pyslim (coalescent simulations tree-sequence analysis), also pandas used internally simulation back ends. three widely used respective fields , , easily obtainable major operating systems (see information troubleshoot potential problems). Note depending use case, three sets dependencies necessarily needed. ’re going running forward spatial simulations, don’t need SLiM geospatial R packages sf, stars, rnaturalearth. applies also animation spatial models using gganimate R package. slendr install dependencies. need functionality, install respective R packages manually. vignette, briefly explain get slendr’s software dependencies installed. said, note normal circumstances (exception SLiM), manual installation individual dependencies required.","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-00-installation.html","id":"sf-stars-rnaturalearth","dir":"Articles","previous_headings":"Software dependencies","what":"sf, stars, rnaturalearth","title":"Installation instructions","text":"R package sf heart geospatial data analysis R. available CRAN can installed major platforms executing install.packages(\"sf\") R session. applies stars rnaturalearth. first load slendr via library(slendr), ’re missing three geospatial R packages, notified instructed can easily obtain CRAN using single call install.packages(). said, sf depends number geospatial libraries depending exact setup Linux macOS machine, libraries missing. Luckily, easy install via Homebrew (macOS) via appropriate package manager Linux distribution (Ubuntu, Fedora, etc.). Detailed instructions operating system can found . ’re problems installation three packages, look help .","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-00-installation.html","id":"macos","dir":"Articles","previous_headings":"Software dependencies > sf, stars, rnaturalearth","what":"macOS","title":"Installation instructions","text":"One user recently installed slendr fresh macOS system reported needed install libgit2 order able install package devtools devtools::install_github(\"bodkan/slendr\") step described top page. Additionally, install couple C/C++ libraries well (dependencies sf package). end, able successfully install slendr running: Note assumes Homebrew package manager already setup Mac. ’re beginning computational scientist using Mac, strongly encourage install Homebrew. Sooner later need specific Linux/unix program anyway, Homebrew way get (Mac unix machine, without Homebrew poor one default).","code":"brew install libgit2 udunits gdal proj"},{"path":"https://bodkan.net/slendr/articles/vignette-00-installation.html","id":"linux","dir":"Articles","previous_headings":"Software dependencies > sf, stars, rnaturalearth","what":"Linux","title":"Installation instructions","text":"Testing slendr installation fresh, pristine Debian installation dependencies previously installed, run following: ’s unlikely need (might need packages non-Debian distributions), got slendr dependencies running completely clean system. Might good start case trouble Linux machine. Windows special treatment necessary get slendr running. install slendr via install.packages(\"slendr\"), get binary version package dependencies without need compiling sources.","code":"sudo apt-get install libudunits2-dev libssl-dev libgdal-dev libgsl-dev libgit2-dev libfontconfig1-dev libharfbuzz-dev libfribidi-dev"},{"path":"https://bodkan.net/slendr/articles/vignette-00-installation.html","id":"slim","dir":"Articles","previous_headings":"Software dependencies","what":"SLiM","title":"Installation instructions","text":"forward population genetic software SLiM available major software platforms. complete installation instructions can found . Mac, recommend installing SLiM via pkg installer available direct download website. Linux, can either install SLiM via appropriate package manager Linux distribution (see SLiM manual information), can easily compile . install SLiM Windows, please follow instructions section 2.3.1 SLiM manual. Note although SLiM also available conda, comes without SLiMgui! Note slendr requires SLiM 4.0 work earlier version. , running library(slendr) inform potential issues SLiM installation.","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-00-installation.html","id":"adding-slim-to-the-path","dir":"Articles","previous_headings":"Software dependencies > SLiM","what":"Adding SLiM to the $PATH","title":"Installation instructions","text":"order slendr able find SLiM installation, R must able find slim binary (slim.exe case Windows) called $PATH variable. easiest way verify true call Sys.(\"slim\") (Sys.(\"slim.exe\") Windows) R session. instance, Mac, get : Windows, get (followed section 2.3.1 SLiM manual describing “official” way install SLiM recommend follow well): , hand, might get something like — empty string: means $PATH R configured properly R (slendr) won’t able find SLiM $PATH. add SLiM $PATH ? Probably convenient way editing .Renviron file. precise location file depends operation system can automatically get open text editor using command (might install.packages(\"usethis\") first): , can either add following (note ’s $ line!): Alternatively, already $PATH contents specified R session, can get calling Sys.getenv(\"PATH\") R console, grab entire string get way, append path installed SLiM using appropriate delimiter (: Linux/macOS, ; Windows) string. case, edit might look something like : instance, Mac, .Renviron file contains line (note last item /usr/local/bin matches path slim showed ): testing Windows machine, .Renviron file (, look path C:/msys64/mingw64/bin;$PATH\" matches slim.exe binary shown ): important check R can find SLiM using Sys.() command described . gives positive result, won’t able use slendr’s spatial SLiM simulations. ’re struggling , search advice related .Renviron $PATH online.","code":"> Sys.which(\"slim\")                  slim  \"/usr/local/bin/slim\" > Sys.which(\"slim.exe\")                             slim.exe  \"C:\\\\msys64\\\\mingw64\\\\bin\\\\slim.exe\" > Sys.which(\"slim\") slim    \"\" usethis::edit_r_environ() PATH=\"<path to directory with SLiM binaries>\" PATH=\"<original Sys.getenv(\"PATH\") content><delimiter><path to directory with SLiM binaries>\" PATH=\"/opt/homebrew/bin:/opt/homebrew/sbin:/Users/mp/.my_local/bin:/Users/mp/.my_local/AdmixTools/bin:/Library/TeX/texbin:/opt/homebrew/opt/gnu-sed/libexec/gnubin:/opt/homebrew/opt/coreutils/libexec/gnubin:/usr/local/bin\" PATH=\"C:\\\\msys64\\\\usr\\\\bin;C:\\\\rtools43\\\\x86_64-w64-mingw32.static.posix\\\\bin;C:\\\\rtools43\\\\usr\\\\bin;C:\\\\Program Files (x86)\\\\R\\\\R-4.3.2\\\\bin\\\\x64;C:/msys64/mingw64/bin\""},{"path":"https://bodkan.net/slendr/articles/vignette-00-installation.html","id":"fallback-options","dir":"Articles","previous_headings":"Software dependencies > SLiM > Adding SLiM to the $PATH","what":"Fallback options","title":"Installation instructions","text":"don’t want deal editing .Renviron file, able set path SLiM using command Sys.setenv(PATH = \"<path directory SLiM binaries>\"). beginning slendr R scripts though. Alternatively, slim() function argument slim_path= can specify full path slim slim.exe binaries directly (directory ’s case $PATH! full path slim/slim.exe binary ).","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-00-installation.html","id":"python","dir":"Articles","previous_headings":"Software dependencies","what":"Python","title":"Installation instructions","text":"order able run coalescent simulations process tree-sequence files, slendr needs Python modules tskit, msprime, pyslim (also needs pandas library). Setting isolated Python environment specific version Python packages (important avoid clashes among different Python programs needed system) can bit hassle users. especially true R users might use Python daily work. order make sure R package appropriate version Python available, correct versions Python module dependencies, slendr provides dedicated function setup_env() automatically downloads completely separate Python distribution installs required versions tskit, msprime, pyslim modules dedicated virtual environment. Moreover, Python installation virtual environment entirely isolated Python configurations already present user’s system, avoiding potential conflicts versions Python Python modules required slendr. Next time call library(slendr), need activate environment automatically calling init_env(). ’re comfortable Python don’t need worry beyond calling setup_env() init_env(), interaction Python necessary working slendr R.","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-00-installation.html","id":"failing-conda","dir":"Articles","previous_headings":"Software dependencies > Python","what":"Failing conda?","title":"Installation instructions","text":"order support Windows, slendr uses conda download Python interpreter explained . Given fact, run setup_env(), slendr tries leverage conda present install Python dependencies (msprime, tskit, pyslim, pandas) via conda . Unfortunately, conda can break frustratingly many random reasons completely trips setup_env(). run issue, fallback option install Python dependencies msprime, tskit, pyslim, pandas via pip , unlike conda, works practically every time. setup_env() fails conda-related reason, first clear broken environment calling clear_env(), restart R session, call setup_env(pip = TRUE) instead default setup_env(). Note might require install GSL numerical library, ’s trivial issue macOS (brew install gsl) Linux (Ubuntu, instance, sudo apt-get install libgsl-dev).","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-00-installation.html","id":"information-for-python-experts","dir":"Articles","previous_headings":"Software dependencies > Python","what":"Information for Python experts","title":"Installation instructions","text":"case wondering slendr accomplish : slendr’s Python interface implemented using R package reticulate. embeds Python interpreter inside R session, enabling high-performance interoperability languages without need user intervention.","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-00-installation.html","id":"modulenotfounderror-no-module-named-tskit-error","dir":"Articles","previous_headings":"Software dependencies > Python","what":"ModuleNotFoundError: No module named 'tskit' error","title":"Installation instructions","text":"’re running error, means slendr prevented activating internal Python virtual environment. likely either didn’t run setup_env() described , forgot run init_env() attempting simulate tree sequence data, Python environment got somehow corrupted. cause slendr’s internal machinery fail pick ’s Python dependencies tree-sequence simulation analysis, leading module named 'tskit' error. reporting error GitHub, please carefully read writeup put together user reported error. contains required information slendr’s Python environment activation works , ’re running error. issue almost always caused problem outside slendr’s influence, ’s important understand ’s going reporting often assumed slendr bug reality isn’t.","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-01-tutorial.html","id":"motivation","dir":"Articles","previous_headings":"","what":"Motivation","title":"Introduction and basic tutorial","text":"motivation starting project create programmable simulation framework add explicit spatial dimension population genetics models. Specifically, original idea able take models one —  representing simplified view history anatomically modern humans (AMH) West Eurasia last ~50 thousand years (comprehensive overview can found review Lazaridis)—design tool makes possible simulate models explicit geographical context capture processes similar following figure (taken study Haak et al. 2015):  reason probably clear. lot studying history humans species focused reconstructing population movements, expansions gene flow events, happen geographic context. fact, geographic component often interested (.e., “ancestors population come ?”, “route fast migrate?”, etc.). However, goes beyond just simulating demographic history. instance, selection pressure driving adaptation can often spatially heterogeneous: members population occupying one part continent exposed different environmental pressure individuals elsewhere, allele frequency distributions shaped adaptation process reflect spatial heterogeneity accordingly. framework enables simulation explicitly spatial genomic data situations allow us build realistic models test specific hypotheses, goals simply possible using non-spatial simulation methods. R package slendr introduced vignette presents framework. Internally, package two independent tightly interconnected units: R interface provides set functional primitives (“mini-language” sorts) encoding various features spatio-temporal models: population migrations, expansions gene flow, happening real geographic landscape defined freely available cartographic data. Populations represented simple R objects easily visualized spatial boundaries, making possible build complex models interactively set small simple building blocks. SLiM simulation back end represented built-generic SLiM script designed read spatio-temporal model configuration parameters objects established step 1. , tailor simulation run user-defined model. Alternatively, slendr also supports executing standard population genetics models random-mating setting. means models need explicit geographic map can simulated either built-SLiM back end script, efficient msprime back end also provided package. important design objective make integration parts 1. 2. appear completely seamless. Even extremely complex models, model building execution (.e., simulation) can performed without leaving convenience R interface RStudio. simulation complexities happen automatically hood knowledge SLiM required. fact, motto slendr package “Write complex spatiotemporal population genetics models simple R script.”","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-01-tutorial.html","id":"geospatial-data","dir":"Articles","previous_headings":"","what":"Geospatial data","title":"Introduction and basic tutorial","text":"Geospatial analysis deep complex topic, dozens libraries programs designed deal fact Earth three-dimensional object forced plot geographical objects (, case, simulate data) two-dimensional plane. Luckily, technical issues Coordinate Reference Systems, transformations manipulation geometric objects (shifting population boundaries, expansions, etc.) pretty much solved now. Unfortunately, dealing issues practice quite challenging requires non-trivial degree domain expertise. Programming even simple task geospatial data analysis also often requires lot code. R package designed provide collection primitives (“mini-language” sorts) programming population dynamics (splits, movement, gene flow, expansion spatial boundaries) across space time without explicitly deal challenges inherent geospatial analyses.","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-01-tutorial.html","id":"installation-and-setup","dir":"Articles","previous_headings":"","what":"Installation and setup","title":"Introduction and basic tutorial","text":"slendr R package available CRAN can installed simply running install.packages(\"slendr\"). need run latest development version (instance, need latest bugfixes), can get via R package devtools executing devtools::install_github(\"bodkan/slendr\") R terminal. can find detailed installation instructions vignette. get slendr installed, just need load : dependencies (SLiM necessary Python modules) missing, get informative message proceed.","code":"library(slendr)  # activate the internal Python environment needed for simulation and # tree-sequence processing init_env() #> The interface to all required Python modules has been activated."},{"path":"https://bodkan.net/slendr/articles/vignette-01-tutorial.html","id":"defining-the-overall-world-map","dir":"Articles","previous_headings":"","what":"Defining the overall world map","title":"Introduction and basic tutorial","text":"anything else, need define section map world provide context downstream spatio-temporal manipulation population ranges. principle, source geospatial data can manipulated using simple features (sf) infrastructure used. now slendr package implicitly uses Natural Earth project data (vectorized form!), internally loads using rnaturalearth interface. first slendr function look map(). function load map entire world vectorized format zoom specified section world. Note call , specify coordinates zoom geographical Coordinate Reference System (CRS), longitude/latitude, also specified want perform downstream manipulation spatial population maps projected CRS (Lambert Azimuthal Equal-Area projection) appropriate representing wider European continent used tutorial. course, different CRS projections used based part world want simulate. Describing intricacies coordinate reference systems beyond scope tutorial, ’re interested learning encourage read freely available textbook dedicated topic. approach slendr: let user specify everything easy--understand longitude/latitude geographical CRS (can read map, making easy define spatial boundaries trajectories movement), internal data structures final exported spatial maps internally handled projected CRS, important make sure distances proportions distorted. Internally, map object currently normal sf class object without additional components. unlike slendr objects described , also sf objects carry additional internal components. Note summary object says “projected CRS: ETRS89-extended / LAEA Europe”. means world map indeed transformed projected CRS specified .","code":"map <- world(   xrange = c(-13, 70), # min-max longitude   yrange = c(18, 65),  # min-max latitude   crs = \"EPSG:3035\"    # coordinate reference system (CRS) for West Eurasia ) map #> slendr 'map' object  #> -------------------  #> map: internal coordinate reference system EPSG 3035  #> spatial limits (in degrees longitude and latitude): #>   - vertical -13 ... 70 #>   - horizontal 18 ... 65"},{"path":"https://bodkan.net/slendr/articles/vignette-01-tutorial.html","id":"plotting-geographic-features-and-population-ranges","dir":"Articles","previous_headings":"","what":"Plotting geographic features and population ranges","title":"Introduction and basic tutorial","text":"slendr package implements plotting function called plot_map(). order make easier convenient iteratively build complex models. function can intelligently decide (based given input arguments) right way present data user, helps define models quickly without relying lower-level mechanisms sf package. see examples plot_map() action .","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-01-tutorial.html","id":"defining-smaller-geographic-regions","dir":"Articles","previous_headings":"","what":"Defining smaller geographic regions","title":"Introduction and basic tutorial","text":"addition overall spatial map context, can also define smaller geographic boundaries. mostly useful whenever want restrict population’s movement (spatial population expansion) smaller region map intuitive geographic meaning (.e., Anatolia, West Eurasia, etc.). Note objects created population boundaries (yet anyway)! simply labels generic geographic boundaries can used later. attached population point. , object returned region() function actually sf object, carries additional annotation name region (“Anatolia”): However, object also carries additional class annotations purpose internal slendr machinery: Furthermore, note region() calls specified map object defined beginning. object added hidden attribute slendr object represents context geospatial transformations, expansions, plots. can use generic plot_map() function plot geographic regions context defined section world map:  Note map object longer explicitly specified. needed, class objects provided plot_map() function must carry “map” attribute. fact, object must carry map context — slendr complains whenever case. can check component really , although hidden, using built-attr function verify map object created beginning:","code":"africa <- region(   \"Africa\", map,   polygon = list(c(-18, 20), c(38, 20), c(30, 33),                  c(20, 33), c(10, 38), c(-6, 35)) ) europe <- region(   \"Europe\", map,   polygon = list(     c(-8, 35), c(-5, 36), c(10, 38), c(20, 35), c(25, 35),     c(33, 45), c(20, 58), c(-5, 60), c(-15, 50)   ) ) anatolia <- region(   \"Anatolia\", map,   polygon = list(c(28, 35), c(40, 35), c(42, 40),                  c(30, 43), c(27, 40), c(25, 38)) ) anatolia #> slendr 'region' object  #> ----------------------  #> name: Anatolia  #>  #> map: internal coordinate reference system EPSG 3035 class(anatolia) #> [1] \"slendr\"        \"slendr_region\" \"sf\"            \"data.frame\" plot_map(africa, europe, anatolia, title = \"Geographic regions\") all(attr(europe, \"map\") == map) #> [1] TRUE all(attr(anatolia, \"map\") == map) #> [1] TRUE"},{"path":"https://bodkan.net/slendr/articles/vignette-01-tutorial.html","id":"defining-spatial-population-boundaries","dir":"Articles","previous_headings":"","what":"Defining spatial population boundaries","title":"Introduction and basic tutorial","text":"One aims slendr package formalize specification spatial population boundaries changes time. core function population(), takes population name, time want enforce population’s boundary, effective population size population time, map object described . also specify existing population specified population split (explicitly say ’s ancestral population). specifying actual spatial boundaries, several options.","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-01-tutorial.html","id":"polygon-population-ranges","dir":"Articles","previous_headings":"Defining spatial population boundaries","what":"Polygon population ranges","title":"Introduction and basic tutorial","text":"can define detailed population boundaries using polygon geometry object region object created region() function , using polygon = argument population(). , reminder, note coordinates described context geographic CRS. First, let’s create African ancestors modern humans. restrict spatial boundary African population africa region defined :","code":"afr <- population(\"AFR\", time = 52000, N = 3000, map = map, polygon = africa)  plot_map(afr)"},{"path":"https://bodkan.net/slendr/articles/vignette-01-tutorial.html","id":"circular-population-ranges","dir":"Articles","previous_headings":"Defining spatial population boundaries","what":"Circular population ranges","title":"Introduction and basic tutorial","text":"want simulate abstract simple population boundary, can specify circular range center radius arguments instead polygon. distance units slendr package specified coordinate system given “world creation”. instance, EPSG 3035 (’re using ) specifies distances meters. define location population non-Africans right split African ancestors: call plot_map() function returned object, option either plot population range “raw” form “intersected” form, case raw boundary intersected “background” landscape (removing large bodies water, etc.). intersected form ultimately exported serialized format (see ) loaded spatial map SLiM. plot_map() function renders intersected population ranges default.","code":"ooa <- population(   \"OOA\", parent = afr, time = 51000, N = 500, remove = 25000,   center = c(33, 30), radius = 400e3 ) plot_map(ooa, intersect = TRUE, title = \"'Intersected' population range\")"},{"path":"https://bodkan.net/slendr/articles/vignette-01-tutorial.html","id":"population-movement-across-a-landscape","dir":"Articles","previous_headings":"","what":"Population movement across a landscape","title":"Introduction and basic tutorial","text":"describe directional population movement, can use function move(). accepts coordinates destination points along way (trajectory) duration migration, automatically generates number intermediate spatial maps along trajectory movement produce reasonable degree spatial continuity (number can also specified manually). can inspect object returned move() function see now contains just first YAM population range 7000 years ago, also ranges intermediate locations: Checking result visually , see:  Let’s create population Eastern Hunter Gatherers (EHG), split first non-Africans 28000 years ago: ’re , let’s also create population Western Hunter Gatherers (WHG). people living region eventually became present day Europeans receiving gene flow groups time (see ), call “EUR” simplify modeling code little bit:","code":"ooa <- ooa %>% move(   trajectory = list(c(40, 30), c(50, 30), c(60, 40)),   start = 50000, end = 40000 ) ooa #> slendr 'population' object  #> --------------------------  #> name: OOA  #> habitat: terrestrial #>  #> number of spatial maps: 28  #> map: internal coordinate reference system EPSG 3035  #> scheduled removal at time  25000  #>  #> population history overview: #>   - time 51000: split from AFR (N = 500) #>   - time 50000-40000: movement across a landscape plot_map(ooa, title = \"Intermediate migration maps\") ehg <- population(   \"EHG\", parent = ooa, time = 28000, N = 1000, remove = 6000,   polygon = list(     c(26, 55), c(38, 53), c(48, 53), c(60, 53),     c(60, 60), c(48, 63), c(38, 63), c(26, 60)) ) eur <- population( # European population   name = \"EUR\", parent = ehg, time = 25000, N = 2000,   polygon = europe )"},{"path":"https://bodkan.net/slendr/articles/vignette-01-tutorial.html","id":"spatial-population-expansion","dir":"Articles","previous_headings":"","what":"Spatial population expansion","title":"Introduction and basic tutorial","text":"can simulate expanding range population using function expand_range(), accepts parameters specifying many kilometers boundary expand (argument), long expansion take (duration argument) many intermediate spatial map snapshots exported representing expansion (snapshots argument). instance, let’s represent expansion Anatolian farmers, also split OOA population 28000 years ago time split EHG population. Note use optional parameter, polygon, restricts expansion Europe, instead around Anatolia: Note , principle, specify entire spatio-temporal history population single pipeline using pipe operator %>%. , can inspect object returned expand_range() function see contains spatial maps (“snapshots”) expansion process across time: can () check results visually:  visually see really going behind scenes, can also plot raw, non-intersected form expansion : can see population Anatolian farmers point invades spatial boundary EUR population. , doesn’t imply gene flow. section gene flow , see slendr implements gene flow overlapping (non-overlapping) populations. Let’s add couple populations migrations move implementing gene flow . Yamnaya steppe herders:","code":"ana <- population( # Anatolian farmers   name = \"ANA\", time = 28000, N = 3000, parent = ooa, remove = 4000,   center = c(34, 38), radius = 500e3, polygon = anatolia ) %>%   expand_range( # expand the range by 2.500 km     by = 2500e3, start = 10000, end = 7000,     polygon = join(europe, anatolia)   ) ana #> slendr 'population' object  #> --------------------------  #> name: ANA  #> habitat: terrestrial #>  #> number of spatial maps: 16  #> map: internal coordinate reference system EPSG 3035  #> scheduled removal at time  4000  #>  #> population history overview: #>   - time 28000: split from OOA (N = 3000) #>   - time 10000-7000: range expansion plot_map(ana, title = \"Anatolian expansion into Europe\") plot_map(ana, title = \"Anatolian expansion into Europe (not intersected)\", intersect = FALSE) yam <- population( # Yamnaya steppe population   name = \"YAM\", time = 7000, N = 500, parent = ehg, remove = 2500,   polygon = list(c(26, 50), c(38, 49), c(48, 50),                  c(48, 56), c(38, 59), c(26, 56)) ) %>%   move(     trajectory = c(15, 50),     start = 5000, end = 3000, snapshots = 8   )  plot_map(yam)"},{"path":"https://bodkan.net/slendr/articles/vignette-01-tutorial.html","id":"plotting-multiple-slendr-objects","dir":"Articles","previous_headings":"","what":"Plotting multiple slendr objects","title":"Introduction and basic tutorial","text":"addition plotting individual population ranges, generic function plot_map() can handle combination population ranges, can also partition individual facets. useful visual inspection specified model, looking potential issues export individual spatio-temporal maps. Obviously, lot multi-dimensional information:  see better way explore slendr model interactively.","code":"plot_map(afr, ooa, ehg, eur, ana, yam)"},{"path":"https://bodkan.net/slendr/articles/vignette-01-tutorial.html","id":"defining-gene-flow-events","dir":"Articles","previous_headings":"","what":"Defining gene flow events","title":"Introduction and basic tutorial","text":"way slendr implements gene flow events calling gene_flow() function. function straightforward interface, shown . One thing note default, populations gene flow events must overlapping spatial ranges order simulate gene flow. probably rather obvious, populations can’t mix space-time don’t overlap given point space-time. example, look spatial boundaries plotted , ’ll see European African populations don’t overlap population ranges. try instruct slendr simulate geneflow , get error: error message instructs us visually verify case, can done slendr’s plot_map() function optional parameter pop_facets = F (set TRUE default). Many models include multiple gene flow events, can collect simple R list: gene_flow() function simply returns data frame collecting geneflow parameters compile_model() step :","code":"gf <- gene_flow(from = eur, to = afr, proportion = 0.1, start = 20000, end = 15000) Error: No overlap between population ranges of EUR and AFR at time 20000.    Please check the spatial maps of both populations by running   `plot_map(eur, afr)` and adjust them accordingly. Alternatively, in case   this makes sense for your model, you can add `overlap = F` which   will instruct slendr to simulate gene flow without spatial overlap   between populations. gf <- list(   gene_flow(from = ana, to = yam, proportion = 0.5, start = 6500, end = 6400, overlap = FALSE),   gene_flow(from = ana, to = eur, proportion = 0.5, start = 8000, end = 6000),   gene_flow(from = yam, to = eur, proportion = 0.75, start = 4000, end = 3000) ) gf #> [[1]] #>   from_name to_name tstart tend proportion overlap #> 1       ANA     YAM   6500 6400        0.5   FALSE #>  #> [[2]] #>   from_name to_name tstart tend proportion overlap #> 1       ANA     EUR   8000 6000        0.5    TRUE #>  #> [[3]] #>   from_name to_name tstart tend proportion overlap #> 1       YAM     EUR   4000 3000       0.75    TRUE"},{"path":"https://bodkan.net/slendr/articles/vignette-01-tutorial.html","id":"compile-the-whole-model-and-load-it-in-slim","dir":"Articles","previous_headings":"","what":"Compile the whole model and load it in SLiM","title":"Introduction and basic tutorial","text":"crucial function slendr compile_model(). takes population ranges defined across space time, together list gene flow events (optional, since models won’t include gene flow), proceeds converting vectorized spatial ranges raster bitmaps. Furthermore, compiles information split times, NeN_e values, gene flow directions, times, rates series tables. saved automatically dedicated directory format understood back end SLiM script provided slendr (). files model directory look like? Ideally, user never worry ; fact, whole purpose slendr let work much higher level abstraction without worrying low-level details. said, might find useful see things look like behind curtain… First , can inspect contents directory see , indeed, contain defined spatial maps (now PNG files, SLiM requires). also contains series tab-delimited configuration tables. tables contain summaries model parameters defined graphically , namely: table population splits: table geneflow events: finally, table populations whose spatial maps updated throughout simulation, well times updates (table rather large, ’re showing ). object returned compile_model() function (called model ) binds information together. fact, easier debugging sanity checking, carries locations tables (well important information) inside , elements list: model$splits, model$geneflows, etc. case ’d want separate model specification running different scripts, slendr includes function read_model() just purpose:","code":"model_dir <- paste0(tempfile(), \"_tutorial-model\")  model <- compile_model(   populations = list(afr, ooa, ehg, eur, ana, yam), # populations defined above   gene_flow = gf, # gene-flow events defined above   generation_time = 30,   resolution = 10e3, # resolution in meters per pixel   competition = 130e3, mating = 100e3, # spatial interaction in SLiM   dispersal = 70e3, # how far will offspring end up from their parents   path = model_dir ) list.files(model_dir, pattern = \"*.png\") #>  [1] \"1.png\"  \"10.png\" \"11.png\" \"12.png\" \"13.png\" \"14.png\" \"15.png\" \"16.png\" #>  [9] \"17.png\" \"18.png\" \"19.png\" \"2.png\"  \"20.png\" \"21.png\" \"22.png\" \"23.png\" #> [17] \"24.png\" \"25.png\" \"26.png\" \"27.png\" \"28.png\" \"29.png\" \"3.png\"  \"30.png\" #> [25] \"31.png\" \"32.png\" \"33.png\" \"34.png\" \"35.png\" \"36.png\" \"37.png\" \"38.png\" #> [33] \"39.png\" \"4.png\"  \"40.png\" \"41.png\" \"42.png\" \"43.png\" \"44.png\" \"45.png\" #> [41] \"46.png\" \"47.png\" \"48.png\" \"49.png\" \"5.png\"  \"50.png\" \"51.png\" \"52.png\" #> [49] \"53.png\" \"54.png\" \"55.png\" \"56.png\" \"57.png\" \"6.png\"  \"7.png\"  \"8.png\"  #> [57] \"9.png\" read.table(file.path(model_dir, \"populations.tsv\"), header = TRUE) #>   pop            parent    N tsplit_gen tsplit_orig tremove_gen tremove_orig #> 1 AFR __pop_is_ancestor 3000          1       52000          -1           -1 #> 2 OOA               AFR  500         34       51000         901        25000 #> 3 EHG               OOA 1000        801       28000        1534         6000 #> 4 ANA               OOA 3000        801       28000        1601         4000 #> 5 EUR               EHG 2000        901       25000          -1           -1 #> 6 YAM               EHG  500       1501        7000        1651         2500 #>   pop_id parent_id #> 1      0        -1 #> 2      1         0 #> 3      2         1 #> 4      3         1 #> 5      4         2 #> 6      5         2 read.table(file.path(model_dir, \"geneflow.tsv\"), header = TRUE) #>   from  to proportion overlap tstart_gen tstart_orig tend_gen tend_orig from_id #> 1  ANA YAM       0.50       0       1518        6500     1521      6400       3 #> 2  ANA EUR       0.50       1       1468        8000     1534      6000       3 #> 3  YAM EUR       0.75       1       1601        4000     1634      3000       5 #>   to_id #> 1     5 #> 2     4 #> 3     4 loaded_model <- read_model(model_dir)"},{"path":"https://bodkan.net/slendr/articles/vignette-01-tutorial.html","id":"visualize-the-entire-history-of-splits-and-gene-flow","dir":"Articles","previous_headings":"","what":"Visualize the entire history of splits and gene flow","title":"Introduction and basic tutorial","text":"code snippets , defined simple history European populations last 50000 years. history includes population splits gene flow events, well demographic changes. slendr tries make formal specification spatio-temporal population dynamics concise possible, hard really visualize everything happen SLiM side simulation starts just code alone. purpose, package includes function named plot_model() takes information relationships populations (.e., population gene flow objects defined ) plots form -called admixture graph (see discussion admixture graph concept). One important thing note unlike traditional admixture graphs node/population present , full slendr graph single population can participate many gene flow events course history. visualized assigning color population, different nodes color represent snapshots time demographic event affecting population happens.","code":"plot_model(model, proportions = TRUE)"},{"path":"https://bodkan.net/slendr/articles/vignette-01-tutorial.html","id":"interactive-exploration-of-spatio-temporal-models","dir":"Articles","previous_headings":"","what":"Interactive exploration of spatio-temporal models","title":"Introduction and basic tutorial","text":"slightly fancier way visualize models implemented function explore_model(). function accepts compiled model parameter spawns R shiny-based browser app makes possible click time snapshots interactively visualize spatial maps time point.","code":"explore_model(model)"},{"path":"https://bodkan.net/slendr/articles/vignette-01-tutorial.html","id":"running-the-simulation","dir":"Articles","previous_headings":"","what":"Running the simulation","title":"Introduction and basic tutorial","text":"way feed entire serialized model SLiM slim() function, understands format model directory created compile_model() function generates SLiM script (using back end skeleton script part package can found calling system.file(\"scripts/script.slim\", package = \"slendr\"), case ’d like peek internals). output slendr simulation tree-sequence file (produced SLiM simulation behind scenes). tree sequence automatically loaded R returned user: lots slendr allows , terms simulation , also terms analyzing tree-sequence data. list provides list additional resources might want look .","code":"ts <- slim(model, sequence_length = 100000, recombination_rate = 1e-8) ts #> ╔═══════════════════════╗ #> ║TreeSequence           ║ #> ╠═══════════════╤═══════╣ #> ║Trees          │    116║ #> ╟───────────────┼───────╢ #> ║Sequence Length│100,000║ #> ╟───────────────┼───────╢ #> ║Time Units     │  ticks║ #> ╟───────────────┼───────╢ #> ║Sample Nodes   │ 10,000║ #> ╟───────────────┼───────╢ #> ║Total Size     │2.7 MiB║ #> ╚═══════════════╧═══════╝ #> ╔═══════════╤══════╤═════════╤════════════╗ #> ║Table      │Rows  │Size     │Has Metadata║ #> ╠═══════════╪══════╪═════════╪════════════╣ #> ║Edges      │18,665│583.3 KiB│          No║ #> ╟───────────┼──────┼─────────┼────────────╢ #> ║Individuals│12,810│  1.2 MiB│         Yes║ #> ╟───────────┼──────┼─────────┼────────────╢ #> ║Migrations │     0│  8 Bytes│          No║ #> ╟───────────┼──────┼─────────┼────────────╢ #> ║Mutations  │     0│  1.2 KiB│          No║ #> ╟───────────┼──────┼─────────┼────────────╢ #> ║Nodes      │18,345│664.5 KiB│         Yes║ #> ╟───────────┼──────┼─────────┼────────────╢ #> ║Populations│     6│  2.6 KiB│         Yes║ #> ╟───────────┼──────┼─────────┼────────────╢ #> ║Provenances│     1│ 43.6 KiB│          No║ #> ╟───────────┼──────┼─────────┼────────────╢ #> ║Sites      │     0│ 16 Bytes│          No║ #> ╚═══════════╧══════╧═════════╧════════════╝"},{"path":"https://bodkan.net/slendr/articles/vignette-01-tutorial.html","id":"more-information","dir":"Articles","previous_headings":"","what":"More information","title":"Introduction and basic tutorial","text":"vignette described basic features slendr package already quite long. much slendr demonstrated . instance: can tweak parameters influencing dispersal dynamics (“clumpy” populations , far offspring can migrate parents, etc.) change dynamics evolve time. See vignette information. can use slendr program non-spatial models, means standard, Wright-Fisher demographic model can simulated lines R code , instance, plugged Approximate Bayesian Computation pipeline analyses leveraging readily available R packages. can find vignette much detailed example vignette SLiM msprime back ends. can build complex spatial models still abstract (assuming real geographic location), including traditional simulations demes lattice structure. complete example shown vignette. SLiM saves data .trees tree-sequence file format, thanks R package reticulate interfacing Python code incredible power tskit pyslim process simulated data massive scale right fingertips, within convenient environment R. See much detailed example vignette vignette extensive tutorial feature.","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-02-grid-model.html","id":"simple-two-dimensional-grid-model","dir":"Articles","previous_headings":"","what":"Simple two-dimensional grid model","title":"Demes on a regular spatial grid","text":"First, let’s load slendr R package create two-dimensional abstract world map: Next, define helper function ) create single slendr population object, b) place population appropriate coordinate lattice world map based numeric identifier population (runs 1 n×nn \\times n , n total number demes along one side regular grid): defined population construction function, let’s build model. Let’s say want create regular grid n × n populations, N individuals population: Let’s plot whole spatial population configuration, make sure set things correctly:  far, way model specified, population stuck circular “island”. can change programming gene flow events using slendr function gene_flow(). , let’s first program simple helper function generate gene flow events according neighborhood relationships two-dimensional grid, allowing population exchange migrants neighbors (making sure coordinates population stay within grid using simple modulo arithmetic population index ). Let’s test function. gene flow events population lower left corner grid (, first population series)? everything works, population allowed exchange migrants neighbor right (population number 2) neighbor . Looks right! Let’s generate entire set continuous gene flow events: total number individual gene flow events : Finally, can compile whole model: familiar SLiM manual recognize model described section 5.3.3. Finally, can run simulation using slim() function.","code":"library(slendr)  init_env() #> The interface to all required Python modules has been activated. map <- world(   xrange = c(0, 1000),   yrange = c(0, 1000),   landscape = \"blank\" ) create_pop <- function(i, n_side, map, N, radius) {   # get dimensions of the world map   dim <- c(diff(attr(map, \"xrange\")), diff(attr(map, \"yrange\")))    # position of the i-th population on the two-dimensional lattice grid   coords <- c((i - 1) %% n_side, (i - 1) %/% n_side)   center <- coords / n_side * dim + dim / (2 * n_side)    pop <- tryCatch({     population(       name = sprintf(\"pop%d\", i),       N = N,       time = 1,       map = map,       center = center + c(attr(map, \"xrange\")[1], attr(map, \"yrange\")[1]),       radius = radius     )   }, error = function(e) NULL)    pop } n <- 5  populations <-   seq(1, n * n) %>%   lapply(create_pop, n_side = n, map = map, N = 100, radius = 40) do.call(plot_map, populations) + ggplot2::theme(legend.position = \"none\") set_geneflow <- function(i, n_side, proportion, start, end, populations) {   pop <- populations[[i]]    # get the position of the i-th population on the n*n grid   coords <- c((i - 1) %% n_side, (i - 1) %/% n_side)     # get coordinates of the i-th population's neighbors on the grid   neighbor_pos <- list(     c(coords[1] - 1, coords[2]), c(coords[1] + 1, coords[2]),     c(coords[1], coords[2] + 1), c(coords[1], coords[2] - 1)   )    # generate geneflow events for population coordinates inside the grid   geneflows <- lapply(neighbor_pos, function(pos) {     if (any(pos < 0 | pos >= n_side)) return(NULL)     neighbor <- populations[[pos[2] * n_side + pos[1] + 1]]     if (is.null(neighbor)) return(NULL)      rbind(       gene_flow(from = pop, to = neighbor, proportion = proportion, start = start, end = end, overlap = FALSE),       gene_flow(from = neighbor, to = pop, proportion = proportion, start = start, end = end, overlap = FALSE)     )   }) %>%     do.call(rbind, .)    geneflows } set_geneflow(1, n, proportion = 0.1, start = 2, end = 1000, populations) #>   from_name to_name tstart tend proportion overlap #> 1      pop1    pop2      2 1000        0.1   FALSE #> 2      pop2    pop1      2 1000        0.1   FALSE #> 3      pop1    pop6      2 1000        0.1   FALSE #> 4      pop6    pop1      2 1000        0.1   FALSE geneflows <-   seq(1, n * n) %>%   lapply(set_geneflow, n, proportion = 0.05, start = 2, end = 1000, populations) %>%   do.call(rbind, .) %>%   unique # filter out duplicate events due to symmetries nrow(geneflows) #> [1] 80 model <- compile_model(   populations = populations, gene_flow = geneflows,   generation_time = 1, resolution = 10,   competition = 10, mating = 10, dispersal = 10,   simulation_length = 1000 ) ts <- slim(model, sequence_length = 10000, recombination_rate = 0) # simulate a single 10kb locus ts #> ╔═══════════════════════╗ #> ║TreeSequence           ║ #> ╠═══════════════╤═══════╣ #> ║Trees          │      1║ #> ╟───────────────┼───────╢ #> ║Sequence Length│ 10,000║ #> ╟───────────────┼───────╢ #> ║Time Units     │  ticks║ #> ╟───────────────┼───────╢ #> ║Sample Nodes   │  5,000║ #> ╟───────────────┼───────╢ #> ║Total Size     │1.3 MiB║ #> ╚═══════════════╧═══════╝ #> ╔═══════════╤═════╤═════════╤════════════╗ #> ║Table      │Rows │Size     │Has Metadata║ #> ╠═══════════╪═════╪═════════╪════════════╣ #> ║Edges      │9,038│282.4 KiB│          No║ #> ╟───────────┼─────┼─────────┼────────────╢ #> ║Individuals│6,250│612.0 KiB│         Yes║ #> ╟───────────┼─────┼─────────┼────────────╢ #> ║Migrations │    0│  8 Bytes│          No║ #> ╟───────────┼─────┼─────────┼────────────╢ #> ║Mutations  │    0│  1.2 KiB│          No║ #> ╟───────────┼─────┼─────────┼────────────╢ #> ║Nodes      │9,063│329.1 KiB│         Yes║ #> ╟───────────┼─────┼─────────┼────────────╢ #> ║Populations│   25│  5.7 KiB│         Yes║ #> ╟───────────┼─────┼─────────┼────────────╢ #> ║Provenances│    1│ 43.6 KiB│          No║ #> ╟───────────┼─────┼─────────┼────────────╢ #> ║Sites      │    0│ 16 Bytes│          No║ #> ╚═══════════╧═════╧═════════╧════════════╝"},{"path":"https://bodkan.net/slendr/articles/vignette-02-grid-model.html","id":"population-grid-on-a-real-geographic-landscape","dir":"Articles","previous_headings":"","what":"Population grid on a real geographic landscape","title":"Demes on a regular spatial grid","text":"can take things one step . wanted similar thing (.e. simulate regularly spaced demes) real geographic context? Let’s zoom interesting part world create grid demes using helper function create_pop defined (population boundary 300 km diameter): course, lay regular grid across map world, population boundaries fall outside African continent. solve issue, go list populations filter least 50% area land, using another helper function: Let’s plot layout population grid real geographic background:  Next, probably set scenario gene flow subpopulations; perhaps interested studying selected allele spreads continent based factors interest. , simulate data spatial model, first compile_model() run SLiM via slim() function. Given process described example , won’t repeating .","code":"map <- world(   xrange = c(-25, 55),   yrange = c(-32, 35),   crs = 4326 )  n <- 20  populations <-   seq(1, n * n) %>%   lapply(create_pop, n_side = n, map = map, N = 100, radius = 1.5) continent <- region(   map = map, polygon = list(     c(-10, 35), c(-20, 20), c(-15, 8), c(-10, 5), c(0, 2),     c(20, -40), c(35, -32), c(50, -25), c(55, -10), c(50, 0),     c(53, 13), c(45, 10), c(37, 20), c(32, 30), c(16, 38), c(0, 38)   ) )  check_area <- function(pop, map, continent) {   if (is.null(pop)) return(NULL)    # total population area   pop_area <- area(pop)$area   # population area overlapping a map   map_area <- area(overlap(pop, map))   # population area overlapping African continent   continent_area <- area(overlap(pop, continent))    # at least 50% of population's boundary be on land, and it must fall   # on to the African continent itself   if (continent_area == 0 || (map_area / pop_area) < 0.5)     return(NULL)   else     return(pop) }  filtered <- lapply(populations, check_area, map, continent) %>%   Filter(Negate(is.null), .) do.call(plot_map, filtered) + ggplot2::theme(legend.position = \"none\")"},{"path":"https://bodkan.net/slendr/articles/vignette-02-grid-model.html","id":"more-customized-spatial-model","dir":"Articles","previous_headings":"","what":"More customized spatial model","title":"Demes on a regular spatial grid","text":"want introduce spatiality model need manual control position subpopulation, can course customize spatial layout much detail. Consider followin map South America:  Let’s lay demes scattered, irregular fashion. illustration purposes, define population’s geographic range circle radius 200 km. Importantly, note introduced one ancestral population population associated location world map! want simulate data coalescent backend, formally encode population genealogies eventually coalesce. words, models specified run msprime() back end contain isolated demes formally descend single ancestor run models msprime, get error infinite coalescent times. formally introduce ancestral population : Furthermore, let’s say fairly good idea complex interaction/gene-flow network deme, can encode like (instead forcing regular arrangement demes gene-flow interactions previous examples): Now can compile model&nbsp`twist, however: try simulate data non-spatial way using msprime, skip serialization model data disk, skipping spatial interaction dispersal parameters. words, care simulating demographic model traditional, Wright-Fisher, random-mating demes gene flow , dispersal within individual deme. ? Mostly just demonstrate possible! However, certainly situations “half-spatial” model useful – instance, situation within-deme individual dynamics interest, location subpopulation . can make sure demographic model specified correctly quickly visualizing :  can also plot spatial organization demes map glory, including gene flow events (one arrow per unidirectional gene flow). Note get warning message stating (non-spatial) ancestral population won’t visualized map:  Finally, can simulate tree sequence model! Notice simulating data using msprime(), effectively dropping continuous space dimension model. situation, map serves visual aid, making easier set complex “spatial” position demes map.","code":"xrange <- c(-90, -20) yrange <- c(-58, 15)  map <- world(xrange = xrange, yrange = yrange, crs = \"EPSG:31970\") plot_map(map) # non-spatial ancestral population p_anc <- population(\"p_anc\", N = 1000, time = 1)  # spatial populations p1 <- population(\"p1\", N = 1000, time = 500, parent = p_anc, map = map, center = c(-75, 0), radius = 200e3) p2 <- population(\"p2\", N = 1000, time = 500, parent = p_anc, map = map, center = c(-60, 5), radius = 200e3) p3 <- population(\"p3\", N = 1000, time = 500, parent = p_anc, map = map, center = c(-65, -5), radius = 200e3) p4 <- population(\"p4\", N = 1000, time = 500, parent = p_anc, map = map, center = c(-60, -20), radius = 200e3) p5 <- population(\"p5\", N = 1000, time = 500, parent = p_anc, map = map, center = c(-65, -35), radius = 200e3) p6 <- population(\"p6\", N = 1000, time = 500, parent = p_anc, map = map, center = c(-69, -42), radius = 200e3) p7 <- population(\"p7\", N = 1000, time = 500, parent = p_anc, map = map, center = c(-51, -10), radius = 200e3) p8 <- population(\"p8\", N = 1000, time = 500, parent = p_anc, map = map, center = c(-45, -15), radius = 200e3) p9 <- population(\"p9\", N = 1000, time = 500, parent = p_anc, map = map, center = c(-71, -12), radius = 200e3) p10 <- population(\"p10\", N = 1000, time = 500, parent = p_anc, map = map, center = c(-55, -25), radius = 200e3) gf <- list(   gene_flow(p1, p2, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p2, p1, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p1, p3, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p3, p1, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p2, p3, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p3, p2, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p2, p7, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p7, p2, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p3, p7, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p7, p3, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p7, p8, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p8, p7, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p4, p7, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p7, p4, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p4, p5, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p5, p4, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p5, p6, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p6, p5, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p3, p4, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p4, p3, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p1, p9, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p9, p1, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p3, p9, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p9, p3, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p4, p9, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p9, p4, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p10, p4, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p4, p10, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p10, p8, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p8, p10, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p10, p5, 1000, 2000, proportion = 0.1, overlap = FALSE),   gene_flow(p5, p10, 1000, 2000, proportion = 0.1, overlap = FALSE) ) model <- compile_model(   populations = list(p_anc, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10), gene_flow = gf,   generation_time = 1, simulation_length = 5000,   serialize = FALSE ) #> Warning: Model containing a mix of spatial and non-spatial populations will be compiled. #> Although this is definitely supported, make sure this is really what you want. #> Warning: Spatial models must be serialized to disk for SLiM to simulate data from. #> Compiled like this, your model can only be simulated with msprime. plot_model(model) plot_map(model, gene_flow = TRUE) #> Warning: All gene-flow event will be visualized at once. If you wish to visualize #> gene flows at a particular point in time, use the `time` argument. #> Warning: Non-spatial populations in your model won't be visualized ts <- msprime(model, sequence_length = 10e6, recombination_rate = 1e-8, random_seed = 42)  ts #> ╔═══════════════════════════╗ #> ║TreeSequence               ║ #> ╠═══════════════╤═══════════╣ #> ║Trees          │     34,057║ #> ╟───────────────┼───────────╢ #> ║Sequence Length│ 10,000,000║ #> ╟───────────────┼───────────╢ #> ║Time Units     │generations║ #> ╟───────────────┼───────────╢ #> ║Sample Nodes   │     22,000║ #> ╟───────────────┼───────────╢ #> ║Total Size     │    9.4 MiB║ #> ╚═══════════════╧═══════════╝ #> ╔═══════════╤═══════╤═════════╤════════════╗ #> ║Table      │Rows   │Size     │Has Metadata║ #> ╠═══════════╪═══════╪═════════╪════════════╣ #> ║Edges      │182,742│  5.6 MiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Individuals│ 11,000│300.8 KiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Migrations │      0│  8 Bytes│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Mutations  │      0│ 16 Bytes│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Nodes      │ 74,344│  2.0 MiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Populations│     11│605 Bytes│         Yes║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Provenances│      1│ 10.5 KiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Sites      │      0│ 16 Bytes│          No║ #> ╚═══════════╧═══════╧═════════╧════════════╝"},{"path":"https://bodkan.net/slendr/articles/vignette-04-nonspatial-models.html","id":"extracting-parameters-from-a-model-or-tree-sequences","dir":"Articles","previous_headings":"","what":"Extracting parameters from a model or tree sequences","title":"Traditional, non-spatial models","text":"situations (model parameters drawn random distributions need know parameters used simulations), function extract_parameters() can used. function peeks slendr tree sequence object extract parameters original slendr model: completeness, although isn’t relevant example either, function can also get parameters compiled model. instance, can check parameters used compile built-slendr introgression model running: can see, extract_parameters() returns list data frames, one data frame aspect demographic model (applicable).","code":"extract_parameters(ts_msprime) #> $splits #>   pop parent    N   time remove #> 1 AFR   <NA> 3000 100000     NA #> 2 OOA    AFR  500  60000  23000 #> 3 EHG    OOA 1000  28000   6000 #> 5 ANA    OOA 3000  28000   4000 #> 4 EUR    EHG 2000  25000     NA #> 6 YAM    EHG  500   7000   2500 #>  #> $gene_flows #>   from  to start  end proportion #> 1  ANA YAM  6500 6400       0.50 #> 2  ANA EUR  8000 6000       0.50 #> 3  YAM EUR  4000 3000       0.75 #>  #> $resizes #>   pop         how     N  time end #> 1 OOA        step  2000 40000  NA #> 2 EUR exponential 10000  5000   0 introgression_model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  extract_parameters(introgression_model) #> $splits #>   pop parent    N    time remove #> 1  CH   <NA>   10 6500000     NA #> 2 AFR     CH   10 6000000     NA #> 3 NEA    AFR   10  600000  40000 #> 4 EUR    AFR 5000   70000     NA #>  #> $gene_flows #>   from  to start   end proportion #> 1  NEA EUR 55000 45000       0.03"},{"path":"https://bodkan.net/slendr/articles/vignette-04-nonspatial-models.html","id":"named-samples","dir":"Articles","previous_headings":"","what":"Named samples","title":"Traditional, non-spatial models","text":"addendum, worth mentioning addition automatically naming recorded samples according format \"<population>_<number>\", slendr supports uniquely named samples. instance, imagine want record ancient individual representing 45.000 years old hunter gatherer known Ust’-Ishim (Fu, _et al., Nature, 2014). include sample among , generically named, samples like : simulate just like : inspect table recorded individuals, can see Ust’-Ishim individual stored proper symbolic name: later compute summary statistics tree sequences, makes referring specific individuals even convenient:","code":"schedule_amh <- schedule_sampling(   model,   times = c(0, 5000, 12000, 20000, 35000, 39000, 43000),   list(eur, 3), list(ehg, 1), list(yam, 1), list(ana, 3), list(ooa, 1), list(afr, 1) )  schedule_ui <- schedule_sampling(model, times = 45000, list(ooa, 1, \"Ust_Ishim\"))  # bind the two tables together into a single schedule schedule <- rbind(schedule_amh, schedule_ui) ts <- msprime(model, sequence_length = 100000, recombination_rate = 0, samples = schedule) ts_samples(ts) #>         name  time pop #> 1  Ust_Ishim 45000 OOA #> 2      AFR_1 43000 AFR #> 3      OOA_1 43000 OOA #> 4      AFR_2 39000 AFR #> 5      OOA_2 39000 OOA #> 6      AFR_3 35000 AFR #> 7      OOA_3 35000 OOA #> 8      AFR_4 20000 AFR #> 9      ANA_1 20000 ANA #> 10     ANA_2 20000 ANA #> 11     ANA_3 20000 ANA #> 12     EHG_1 20000 EHG #> 13     EUR_1 20000 EUR #> 14     EUR_2 20000 EUR #> 15     EUR_3 20000 EUR #> 16     AFR_5 12000 AFR #> 17     ANA_4 12000 ANA #> 18     ANA_5 12000 ANA #> 19     ANA_6 12000 ANA #> 20     EHG_2 12000 EHG #> 21     EUR_4 12000 EUR #> 22     EUR_5 12000 EUR #> 23     EUR_6 12000 EUR #> 24     AFR_6  5000 AFR #> 25     ANA_7  5000 ANA #> 26     ANA_8  5000 ANA #> 27     ANA_9  5000 ANA #> 28     EUR_7  5000 EUR #> 29     EUR_8  5000 EUR #> 30     EUR_9  5000 EUR #> 31     YAM_1  5000 YAM #> 32     AFR_7     0 AFR #> 33    EUR_10     0 EUR #> 34    EUR_11     0 EUR #> 35    EUR_12     0 EUR ts_f3(ts, A = \"AFR_1\", B = \"EUR_1\", C = \"Ust_Ishim\", mode = \"branch\") #> # A tibble: 1 × 4 #>   A     B     C            f3 #>   <chr> <chr> <chr>     <dbl> #> 1 AFR_1 EUR_1 Ust_Ishim 1210."},{"path":"https://bodkan.net/slendr/articles/vignette-05-tree-sequences.html","id":"setting-up-python-environment","dir":"Articles","previous_headings":"","what":"Setting up Python environment","title":"Tree-sequence processing and statistics","text":"First, order able interface tskit pyslim using reticulate package (run simulations using msprime, ), need working Python environment required Python modules pyslim, tskit msprime already installed. setting Python environments can quite hassle, slendr provides single function setup_env() make things easier. call without arguments, slendr automatically download, install, setup completely separate Python environment (based “miniconda” distribution) just slendr activate background. important stress setup_env() interfere way Python installations might already computer. Python installation environment entirely isolated used just purpose slendr workflows. Python environment set , can activate calling: can use another built-function check_env() make sure slendr installed configured correct environment us: Now ’re good go ready simulate analyse tree sequence outputs R!","code":"setup_env() init_env() #> The interface to all required Python modules has been activated. check_env() #> Summary of the currently active Python environment: #>  #> Python binary: /Users/mp/Library/r-miniconda-arm64/envs/Python-3.12_msprime-1.3.4_tskit-0.6.4_pyslim-1.1.0_tspop-0.0.2/bin/python  #> Python version: 3.12.12 | packaged by conda-forge | (main, Oct 22 2025, 23:34:53) [Clang 19.1.7 ]  #>  #> slendr requirements: #>  - tskit: version 0.6.4 ✓  #>  - msprime: version 1.3.4 ✓  #>  - pyslim: version 1.1.0 ✓  #>  - tspop: present ✓"},{"path":"https://bodkan.net/slendr/articles/vignette-05-tree-sequences.html","id":"model-of-neanderthal-introgression-into-eurasians","dir":"Articles","previous_headings":"Setting up Python environment","what":"Model of Neanderthal introgression into Eurasians","title":"Tree-sequence processing and statistics","text":"First, let’s set simple non-spatial model Neanderthal introgression using slendr. essentially procedure shown another vignette introducing non-spatial slendr models. different spatial model, except left map argument calling population(). ’s toy model visualized “demographic graph” sorts (.e., tree-like structure specifying population splits additional edges representing gene flow events). particularly illuminating simple example, ’s always worth keeping mind graph embedded within every slendr model can always invoked make sure model ’re setting correct:","code":"library(ggplot2) library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union set.seed(314159)  # create the ancestor of everyone and a chimpanzee outgroup # (we set both N = 1 to reduce the computational time for this model) chimp <- population(\"CH\", time = 6.5e6, N = 1000)  # two populations of anatomically modern humans: Africans and Europeans afr <- population(\"AFR\", parent = chimp, time = 6e6, N = 10000) eur <- population(\"EUR\", parent = afr, time = 70e3, N = 5000)  # Neanderthal population splitting at 600 ky ago from modern humans # (becomes extinct by 40 ky ago) nea <- population(\"NEA\", parent = afr, time = 600e3, N = 1000, remove = 40e3)  # 3% Neanderthal introgression into Europeans between 55-50 ky ago gf <- gene_flow(from = nea, to = eur, proportion = 0.03, start = 55000, end = 45000)  model <- compile_model(   populations = list(chimp, nea, afr, eur), gene_flow = gf,   generation_time = 30,   path = paste0(tempfile(), \"_introgression\") ) cowplot::plot_grid(   plot_model(model, sizes = FALSE),   plot_model(model, sizes = FALSE, log = TRUE),   nrow = 1 )"},{"path":"https://bodkan.net/slendr/articles/vignette-05-tree-sequences.html","id":"scheduling-of-sampling-events","dir":"Articles","previous_headings":"","what":"Scheduling of sampling events","title":"Tree-sequence processing and statistics","text":"Now defined model, sample data ? Ideally, like schedule sampling events given time, sampling defined number individuals given population. slendr provides function schedule_sampling() serves define sampling schedule automatically enforces populations already (.e. appearance simulation) still (removed simulation) present sampled . example, want sample two Neanderthal individuals (older one Altai Neanderthal published Pruefer et al. 2014, younger one Vindija Neanderthal published Pruefer et al., 2017). two genomes need estimate Neanderthal ancestry proportion using -called f4f_4-ratio statistic (, also see Petr et al., PNAS 2019): can see, schedule_sampling() function simply accepts vector times remembering schedule, list pairs (<slendr population>, <number individuals>) encoding populations many individuals remembered time points given times vector. Next, want sample present-day individuals: outgroup representing chimpanzee, couple Africans Europeans: can see , schedule_sampling() function returns plain old data frame simple structure three columns: time, population name, number individuals. means can define sampling events using whatever input data might already available (radiocarbon-dated ancient DNA samples Excel sheet publication). instance, lot interest estimate trajectory Neanderthal ancestry Europe time using ancient DNA data anatomically modern human individuals (also called early modern humans, EMH) across last couple tens thousands years. can simulate something close available EMH ancient DNA data set last 50 thousand years running : samples single ancient European individuals randomly chosen times 40 10 ky ago. One nice feature schedule_sampling() function schedules sampling events population, population present simulation given time. makes possible simply take wide time range sampling, specify populations sizes samples, let function generate sampling events populations present time. reason stricter control sampling required, behavior can switched setting strict = TRUE like : Now already model object ready, can simulate data , sampling individuals according sampling schedule. Although use slim() function shown previous vignettes, case run simulation msprime() coalescent back end. , model non-spatial using coalescent simulator much efficient forward simulation. Switching msprime SLiM back ends slendr demonstrated much detail dedicated vignette. simulation back end utilized msprime() function (well slim() function) produces tree-sequence output immediately loaded ready downstream analysis. Note bind individual sampling schedule data frames using rbind function provided base R (show , sampling schedule really just data frame can manipulate ).","code":"nea_samples <- schedule_sampling(model, times = c(70000, 40000), list(nea, 1)) nea_samples #> # A tibble: 2 × 8 #>    time pop       n name  y_orig x_orig y     x     #>   <int> <chr> <int> <lgl> <lgl>  <lgl>  <lgl> <lgl> #> 1 40000 NEA       1 NA    NA     NA     NA    NA    #> 2 70000 NEA       1 NA    NA     NA     NA    NA present_samples <- schedule_sampling(model, times = 0, list(chimp, 1), list(afr, 5), list(eur, 10)) present_samples #> # A tibble: 3 × 8 #>    time pop       n name  y_orig x_orig y     x     #>   <int> <chr> <int> <lgl> <lgl>  <lgl>  <lgl> <lgl> #> 1     0 CH        1 NA    NA     NA     NA    NA    #> 2     0 AFR       5 NA    NA     NA     NA    NA    #> 3     0 EUR      10 NA    NA     NA     NA    NA emh_samples <- schedule_sampling(model, times = runif(n = 40, min = 10000, max = 40000), list(eur, 1)) emh_samples #> # A tibble: 40 × 8 #>     time pop       n name  y_orig x_orig y     x     #>    <int> <chr> <int> <lgl> <lgl>  <lgl>  <lgl> <lgl> #>  1 10320 EUR       1 NA    NA     NA     NA    NA    #>  2 11188 EUR       1 NA    NA     NA     NA    NA    #>  3 11396 EUR       1 NA    NA     NA     NA    NA    #>  4 11529 EUR       1 NA    NA     NA     NA    NA    #>  5 11927 EUR       1 NA    NA     NA     NA    NA    #>  6 12675 EUR       1 NA    NA     NA     NA    NA    #>  7 13689 EUR       1 NA    NA     NA     NA    NA    #>  8 13744 EUR       1 NA    NA     NA     NA    NA    #>  9 14775 EUR       1 NA    NA     NA     NA    NA    #> 10 16362 EUR       1 NA    NA     NA     NA    NA    #> # ℹ 30 more rows # this attempts to sample a Neanderthal individual at a point when Neanderthals # are already extinct, resulting in an error schedule_sampling(model, times = 10000, list(nea, 1), strict = TRUE) Error: Cannot schedule sampling for 'NEA' at time 10000 because the population will not be present in the simulation at that point. Consider running this function with `strict = FALSE` which will automatically retain only valid sampling events. ts <- msprime(   model, sequence_length = 100e6, recombination_rate = 1e-8,   samples = rbind(nea_samples, present_samples, emh_samples),   random_seed = 314159, verbose = TRUE )  ts #> ╔═══════════════════════════╗ #> ║TreeSequence               ║ #> ╠═══════════════╤═══════════╣ #> ║Trees          │    240,041║ #> ╟───────────────┼───────────╢ #> ║Sequence Length│      1e+08║ #> ╟───────────────┼───────────╢ #> ║Time Units     │generations║ #> ╟───────────────┼───────────╢ #> ║Sample Nodes   │        116║ #> ╟───────────────┼───────────╢ #> ║Total Size     │   40.0 MiB║ #> ╚═══════════════╧═══════════╝ #> ╔═══════════╤═══════╤═════════╤════════════╗ #> ║Table      │Rows   │Size     │Has Metadata║ #> ╠═══════════╪═══════╪═════════╪════════════╣ #> ║Edges      │916,588│ 28.0 MiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Individuals│     58│  1.6 KiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Migrations │      0│  8 Bytes│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Mutations  │      0│ 16 Bytes│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Nodes      │189,654│  5.1 MiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Populations│      4│338 Bytes│         Yes║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Provenances│      1│  7.1 KiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Sites      │      0│ 16 Bytes│          No║ #> ╚═══════════╧═══════╧═════════╧════════════╝"},{"path":"https://bodkan.net/slendr/articles/vignette-05-tree-sequences.html","id":"named-samples","dir":"Articles","previous_headings":"","what":"Named samples","title":"Tree-sequence processing and statistics","text":"addition automatically named symbolic names, slendr also supports fully customized sample names (see bit detail). particularly convenient referring simulated individuals “real-world names”.","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-05-tree-sequences.html","id":"r-interface-for-tskit-and-pyslim","dir":"Articles","previous_headings":"","what":"R interface for tskit and pyslim","title":"Tree-sequence processing and statistics","text":"Tree-sequences one revolutionary developments population genetics last couple decades number reasons. One possibility store extremely large data sets succinctly encoding entire evolutionary history sample individuals series correlated tree genealogies along genome. Going much detail topic clearly beyond scope tutorial, especially everything explain much better elsewhere. Instead, demonstrate rest vignette can access manipulate tree-sequence outputs generated slendr models perform various statistics using Python modules tskit pyslim directly slendr, without leave R! key magical R package reticulate creates seamless binding Python modules R. means even don’t know Python, slendr allows quite lot tree-sequences R. course, proficient Python user, needs said tree-sequence file generated slendr & SLiM, can easily perform every conceivable analysis directly using tskit. intention show can continue working tree-sequence files R even run entire slendr simulation.","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-05-tree-sequences.html","id":"loading-and-processing-tree-sequence-output-files","dir":"Articles","previous_headings":"","what":"Loading and processing tree-sequence output files","title":"Tree-sequence processing and statistics","text":"default, msprime() slim() run produce tree-sequence object (saved temporary file) immediately load . Thus, use-cases, explicit loading simulated tree sequence needed. said, sake completeness, let’s run simulation save tree-sequence file . case tree-sequence output saved custom location disk, can load tree sequence using slendr function ts_read(). ’re dealing tree sequence produced SLiM back end (case ), can also instruct function simplify tree-sequence individuals explicitly sampled (recall sampling schedule set schedule_sampling() function ). Note provide model object generated compile_model() order model annotation information simulated tree-sequence data (, loading): surprisingly, get output got printed tree sequence returned msprime() function. shows normal circumstances, loading output manually via ts_read() needed. try simplify msprime-generated tree sequence, get warning. tree sequence already simplified form, definition coming coalescent simulator. default, simplification trims tree sequence remembered individuals (.e. explicitly scheduled sampling), true every msprime tree sequence. Alternatively, can also narrow simplification defined set individuals using simplify_to = argument. Internally, simplification implemented dedicated function ts_simplify() can always call explicitly, like : Similarly, slendr provides function ts_recapitate() performs [recapitation]https://tskit.dev/pyslim/docs/latest/tutorial.html#recapitation). , needed msprime tree sequence, fully coalesced (recapitated) definition. current tree sequence object, simply get warning informing us ’re attempting something effect: can make sure tree sequence fully coalesced calling another slendr function ts_coalesced(). useful dealing slim()-produced tree sequences: might noticed simulate mutations SLiM run. computational efficiency. Luckily, tree-sequence contains complete history sample individuals makes easy sprinkle mutations genealogies simulation . can add mutations given rate running: processed simulated tree sequence, can calculate basic statistics simulated data. However, , first like note everything rest vignette (.e. whenever call function prefix ts_*() slendr), interfacing tskit Python module hood. goal capture analyses one might want perform tree-sequences R wrap neat interface indistinguishable R function—, , reason reticulate created first place (making various Python data science modules appear regular R packages).","code":"output_file <- tempfile()  ts <- msprime(   model, sequence_length = 100e6, recombination_rate = 1e-8,   samples = rbind(nea_samples, present_samples, emh_samples),   random_seed = 314159 )  ts_write(ts, output_file)  output_file #> [1] \"/var/folders/lq/bl36db_s6w908hnjkntdp4140000gn/T//RtmpRP1PJZ/file5cfe68c67c96\" ts <- ts_read(output_file, model) ts #> ╔═══════════════════════════╗ #> ║TreeSequence               ║ #> ╠═══════════════╤═══════════╣ #> ║Trees          │    240,041║ #> ╟───────────────┼───────────╢ #> ║Sequence Length│      1e+08║ #> ╟───────────────┼───────────╢ #> ║Time Units     │generations║ #> ╟───────────────┼───────────╢ #> ║Sample Nodes   │        116║ #> ╟───────────────┼───────────╢ #> ║Total Size     │   40.0 MiB║ #> ╚═══════════════╧═══════════╝ #> ╔═══════════╤═══════╤═════════╤════════════╗ #> ║Table      │Rows   │Size     │Has Metadata║ #> ╠═══════════╪═══════╪═════════╪════════════╣ #> ║Edges      │916,588│ 28.0 MiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Individuals│     58│  1.6 KiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Migrations │      0│  8 Bytes│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Mutations  │      0│ 16 Bytes│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Nodes      │189,654│  5.1 MiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Populations│      4│338 Bytes│         Yes║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Provenances│      1│  7.1 KiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Sites      │      0│ 16 Bytes│          No║ #> ╚═══════════╧═══════╧═════════╧════════════╝ ts_simplify(ts) #> ╔═══════════════════════════╗ #> ║TreeSequence               ║ #> ╠═══════════════╤═══════════╣ #> ║Trees          │    238,681║ #> ╟───────────────┼───────────╢ #> ║Sequence Length│      1e+08║ #> ╟───────────────┼───────────╢ #> ║Time Units     │generations║ #> ╟───────────────┼───────────╢ #> ║Sample Nodes   │        116║ #> ╟───────────────┼───────────╢ #> ║Total Size     │   36.7 MiB║ #> ╚═══════════════╧═══════════╝ #> ╔═══════════╤═══════╤═════════╤════════════╗ #> ║Table      │Rows   │Size     │Has Metadata║ #> ╠═══════════╪═══════╪═════════╪════════════╣ #> ║Edges      │864,772│ 26.4 MiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Individuals│     58│  1.6 KiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Migrations │      0│  8 Bytes│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Mutations  │      0│ 16 Bytes│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Nodes      │139,203│  3.7 MiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Populations│      4│338 Bytes│         Yes║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Provenances│      2│  7.7 KiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Sites      │      0│ 16 Bytes│          No║ #> ╚═══════════╧═══════╧═════════╧════════════╝ ts_small <- ts_simplify(ts, simplify_to = c(\"CH_1\", \"NEA_1\", \"NEA_2\", \"AFR_1\", \"AFR_2\", \"EUR_20\", \"EUR_50\")) ts_small #> ╔═══════════════════════════╗ #> ║TreeSequence               ║ #> ╠═══════════════╤═══════════╣ #> ║Trees          │    132,496║ #> ╟───────────────┼───────────╢ #> ║Sequence Length│      1e+08║ #> ╟───────────────┼───────────╢ #> ║Time Units     │generations║ #> ╟───────────────┼───────────╢ #> ║Sample Nodes   │         14║ #> ╟───────────────┼───────────╢ #> ║Total Size     │   19.0 MiB║ #> ╚═══════════════╧═══════════╝ #> ╔═══════════╤═══════╤═════════╤════════════╗ #> ║Table      │Rows   │Size     │Has Metadata║ #> ╠═══════════╪═══════╪═════════╪════════════╣ #> ║Edges      │441,206│ 13.5 MiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Individuals│      7│220 Bytes│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Migrations │      0│  8 Bytes│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Mutations  │      0│ 16 Bytes│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Nodes      │ 79,249│  2.1 MiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Populations│      4│338 Bytes│         Yes║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Provenances│      2│  7.7 KiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Sites      │      0│ 16 Bytes│          No║ #> ╚═══════════╧═══════╧═════════╧════════════╝ ts <- ts_recapitate(ts, recombination_rate = 1e-8, Ne = 10000) ts_coalesced(ts) #> [1] TRUE ts <- ts_mutate(ts, mutation_rate = 1e-8, random_seed = 314159) ts #> ╔═══════════════════════════╗ #> ║TreeSequence               ║ #> ╠═══════════════╤═══════════╣ #> ║Trees          │    240,041║ #> ╟───────────────┼───────────╢ #> ║Sequence Length│      1e+08║ #> ╟───────────────┼───────────╢ #> ║Time Units     │generations║ #> ╟───────────────┼───────────╢ #> ║Sample Nodes   │        116║ #> ╟───────────────┼───────────╢ #> ║Total Size     │   76.8 MiB║ #> ╚═══════════════╧═══════════╝ #> ╔═══════════╤═══════╤═════════╤════════════╗ #> ║Table      │Rows   │Size     │Has Metadata║ #> ╠═══════════╪═══════╪═════════╪════════════╣ #> ║Edges      │916,588│ 28.0 MiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Individuals│     58│  1.6 KiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Migrations │      0│  8 Bytes│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Mutations  │623,249│ 22.0 MiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Nodes      │189,654│  5.1 MiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Populations│      4│338 Bytes│         Yes║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Provenances│      2│  7.9 KiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Sites      │621,331│ 14.8 MiB│          No║ #> ╚═══════════╧═══════╧═════════╧════════════╝"},{"path":"https://bodkan.net/slendr/articles/vignette-05-tree-sequences.html","id":"visualisation-of-trees-and-tree-sequences","dir":"Articles","previous_headings":"","what":"Visualisation of trees and tree-sequences","title":"Tree-sequence processing and statistics","text":"Now introduce function ts_phylo() can used extract one tree tree-sequence (either -th tree sequence, tree overlapping -th position simulated genome, depending value mode argument) convert phylo class, standard format phylogenetic trees R world. phylo format, see packages ape, phangorn, phytools. type tree object R console, can verify got ordinary phylo object: means whole R phylogenetic ecosystem disposal analyze trees. instance can use powerful package ggtree plot tree just extracted:","code":"# extract the 42nd tree in the tree sequence tree <- ts_phylo(ts_small, 42 - 1) #> Starting checking the validity of tree... #> Found number of tips: n = 14  #> Found number of nodes: m = 13  #> Done. tree #>  #> Phylogenetic tree with 14 tips and 13 internal nodes. #>  #> Tip labels: #>   13 (EUR_50), 12 (EUR_50), 11 (CH_1), 10 (CH_1), 9 (AFR_2), 8 (AFR_2), ... #> Node labels: #>   77386, 70, 2699, 5175, 5199, 6642, ... #>  #> Rooted; includes branch length(s). library(ggtree) #> ggtree v4.0.1 Learn more at https://yulab-smu.top/contribution-tree-data/ #>  #> Please cite: #>  #> Guangchuang Yu.  Data Integration, Manipulation and Visualization of #> Phylogenetic Trees (1st edition). Chapman and Hall/CRC. 2022, #> doi:10.1201/9781003279242, ISBN: 9781032233574 ggtree(tree) +   geom_point2(aes(subset = !isTip)) + # points for internal nodes   geom_tiplab() + # sample labels for tips   hexpand(0.1)    # make more space for the tip labels library(ape) plot(tree) nodelabels()"},{"path":"https://bodkan.net/slendr/articles/vignette-05-tree-sequences.html","id":"accessing-tskit-functionality-directly","dir":"Articles","previous_headings":"","what":"Accessing tskit functionality directly","title":"Tree-sequence processing and statistics","text":"mentioned previous section, goal vignette show use slendr perform main tree-sequence operations using convenient R interface tskit. However, always keep mind restricted subset tskit functionality slendr translated R (.e. functions prefix ts_). Thanks incredible R package reticulate, can access Python methods object variables directly, using $ operator. example, instead calling function ts_coalesced() tree-sequence , check trees coalesced running following snippet instead (note inefficient ’re operation first one hundred trees): believe makes sense use R interface whenever possible (even makes many operations little bit convenient). However, functionality slendr missing, can always resort accessing Python objects directly just demonstrated. can verify methods attributes Python tree-sequence object still accessible R: fact, recognize elements output examples involving ts_ functions vignette! short, blackbox—slendr provides slightly convenient layer tskit R users.","code":"# iterate over all trees in the tree-sequence and check if each # has only one root (i.e. is fully coalesced) - note that Python # lists are 0-based, which is something we need to take care of all(sapply(seq_len(ts$num_trees)[1:100],            function(i) ts$at_index(i - 1)$num_roots == 1)) names(ts) #>   [1] \"alignments\"                      \"allele_frequency_spectrum\"       #>   [3] \"as_fasta\"                        \"as_nexus\"                        #>   [5] \"as_vcf\"                          \"aslist\"                          #>   [7] \"at\"                              \"at_index\"                        #>   [9] \"breakpoints\"                     \"check_index\"                     #>  [11] \"coiterate\"                       \"concatenate\"                     #>  [13] \"count_topologies\"                \"decapitate\"                      #>  [15] \"delete_intervals\"                \"delete_sites\"                    #>  [17] \"diffs\"                           \"discrete_genome\"                 #>  [19] \"discrete_time\"                   \"divergence\"                      #>  [21] \"divergence_matrix\"               \"diversity\"                       #>  [23] \"draw_svg\"                        \"draw_text\"                       #>  [25] \"dump\"                            \"dump_tables\"                     #>  [27] \"dump_text\"                       \"edge\"                            #>  [29] \"edge_diffs\"                      \"edges\"                           #>  [31] \"edges_child\"                     \"edges_left\"                      #>  [33] \"edges_metadata\"                  \"edges_parent\"                    #>  [35] \"edges_right\"                     \"edgesets\"                        #>  [37] \"equals\"                          \"extend_haplotypes\"               #>  [39] \"f2\"                              \"f3\"                              #>  [41] \"f4\"                              \"file_uuid\"                       #>  [43] \"first\"                           \"Fst\"                             #>  [45] \"genealogical_nearest_neighbours\" \"general_stat\"                    #>  [47] \"genetic_relatedness\"             \"genetic_relatedness_matrix\"      #>  [49] \"genetic_relatedness_vector\"      \"genetic_relatedness_weighted\"    #>  [51] \"genotype_matrix\"                 \"get_ll_tree_sequence\"            #>  [53] \"get_num_mutations\"               \"get_num_nodes\"                   #>  [55] \"get_num_records\"                 \"get_num_sites\"                   #>  [57] \"get_num_trees\"                   \"get_pairwise_diversity\"          #>  [59] \"get_population\"                  \"get_sample_size\"                 #>  [61] \"get_samples\"                     \"get_sequence_length\"             #>  [63] \"get_time\"                        \"haplotypes\"                      #>  [65] \"has_reference_sequence\"          \"ibd_segments\"                    #>  [67] \"impute_unknown_mutations_time\"   \"indexes_edge_insertion_order\"    #>  [69] \"indexes_edge_removal_order\"      \"individual\"                      #>  [71] \"individual_locations\"            \"individual_populations\"          #>  [73] \"individual_times\"                \"individuals\"                     #>  [75] \"individuals_flags\"               \"individuals_location\"            #>  [77] \"individuals_metadata\"            \"individuals_nodes\"               #>  [79] \"individuals_population\"          \"individuals_time\"                #>  [81] \"kc_distance\"                     \"keep_intervals\"                  #>  [83] \"last\"                            \"ld_matrix\"                       #>  [85] \"ll_tree_sequence\"                \"load\"                            #>  [87] \"load_tables\"                     \"ltrim\"                           #>  [89] \"map_to_vcf_model\"                \"max_root_time\"                   #>  [91] \"max_time\"                        \"mean_descendants\"                #>  [93] \"metadata\"                        \"metadata_schema\"                 #>  [95] \"migration\"                       \"migrations\"                      #>  [97] \"migrations_dest\"                 \"migrations_left\"                 #>  [99] \"migrations_metadata\"             \"migrations_node\"                 #> [101] \"migrations_right\"                \"migrations_source\"               #> [103] \"migrations_time\"                 \"min_time\"                        #> [105] \"mutation\"                        \"mutations\"                       #> [107] \"mutations_metadata\"              \"mutations_node\"                  #> [109] \"mutations_parent\"                \"mutations_site\"                  #> [111] \"mutations_time\"                  \"nbytes\"                          #> [113] \"newick_trees\"                    \"node\"                            #> [115] \"nodes\"                           \"nodes_flags\"                     #> [117] \"nodes_individual\"                \"nodes_metadata\"                  #> [119] \"nodes_population\"                \"nodes_time\"                      #> [121] \"num_edges\"                       \"num_individuals\"                 #> [123] \"num_migrations\"                  \"num_mutations\"                   #> [125] \"num_nodes\"                       \"num_populations\"                 #> [127] \"num_provenances\"                 \"num_samples\"                     #> [129] \"num_sites\"                       \"num_trees\"                       #> [131] \"pair_coalescence_counts\"         \"pair_coalescence_quantiles\"      #> [133] \"pair_coalescence_rates\"          \"pairwise_diversity\"              #> [135] \"parse_positions\"                 \"parse_sites\"                     #> [137] \"parse_windows\"                   \"pca\"                             #> [139] \"population\"                      \"populations\"                     #> [141] \"populations_metadata\"            \"provenance\"                      #> [143] \"provenances\"                     \"records\"                         #> [145] \"reference_sequence\"              \"rtrim\"                           #> [147] \"sample_count_stat\"               \"sample_nodes_by_ploidy\"          #> [149] \"sample_size\"                     \"samples\"                         #> [151] \"segregating_sites\"               \"sequence_length\"                 #> [153] \"shift\"                           \"simplify\"                        #> [155] \"site\"                            \"sites\"                           #> [157] \"sites_metadata\"                  \"sites_position\"                  #> [159] \"split_edges\"                     \"subset\"                          #> [161] \"table_metadata_schemas\"          \"tables\"                          #> [163] \"tables_dict\"                     \"Tajimas_D\"                       #> [165] \"time_units\"                      \"to_macs\"                         #> [167] \"to_nexus\"                        \"trait_correlation\"               #> [169] \"trait_covariance\"                \"trait_linear_model\"              #> [171] \"trait_regression\"                \"trees\"                           #> [173] \"trim\"                            \"union\"                           #> [175] \"variants\"                        \"write_fasta\"                     #> [177] \"write_nexus\"                     \"write_vcf\"                       #> [179] \"Y1\"                              \"Y2\"                              #> [181] \"Y3\""},{"path":"https://bodkan.net/slendr/articles/vignette-05-tree-sequences.html","id":"calculating-f-statistics","dir":"Articles","previous_headings":"","what":"Calculating f-statistics","title":"Tree-sequence processing and statistics","text":"addition revolutionary breakthrough terms computation efficiency, many statistics often interested population genetics natural consequence direct access tree sequence genealogies, simply genealogies capture true demographic history sample. , can’t go much detail encourage take look paper Ralph et al. duality statistics expressed terms branch lengths traditional summaries based samples genetic variation. instance, functions ts_f2(), ts_f3(), ts_f4() ts_f4ratio() calculate well-known set Patterson’s ff-statistics: functions accept mode = argument, specifying whether statistics calculated using mutation site patterns (mode = \"site\", default), branch lengths (mode = \"branch\"), node (mode = \"node\"), well windows argument, similarly “multiway” statistics implemented tskit. See relevant sections official tskit documentation topic. Note previous chunk referred individuals names (numeric IDs nodes tskit Python). allow readability make easier see individuals based specified sampling schedule (names assigned individuals based order sampling). can get overview individuals scheduled sampling (.e. permanently remembered) names helper function ts_samples(): said, like run statistics nodes rather individuals, can simply using integer IDs instead character names function’s interface.","code":"# f2 is a measure of the branch length connecting A and B ts_f2(ts, A = \"EUR_1\", B = \"AFR_1\") #> # A tibble: 1 × 3 #>   A     B            f2 #>   <chr> <chr>     <dbl> #> 1 EUR_1 AFR_1 0.0000448 # f4 is a measure of the drift shared between A and B after their split from C ts_f3(ts, A = \"EUR_1\", B = \"AFR_1\", C = \"CH_1\") #> # A tibble: 1 × 4 #>   A     B     C            f3 #>   <chr> <chr> <chr>     <dbl> #> 1 EUR_1 AFR_1 CH_1  0.0000130 # this value should be very close to zero (no introgression in Africans) ts_f4(ts, \"AFR_1\", \"AFR_2\", \"NEA_1\", \"CH_1\", mode = \"branch\") #> # A tibble: 1 × 5 #>   W     X     Y     Z        f4 #>   <chr> <chr> <chr> <chr> <dbl> #> 1 AFR_1 AFR_2 NEA_1 CH_1  -118. # this value should be significantly negative (many more ABBA sites # compared to BABA site due to the introgression into Europeans) ts_f4(ts, \"AFR_1\", \"EUR_1\", \"NEA_1\", \"CH_1\", mode = \"branch\") #> # A tibble: 1 × 5 #>   W     X     Y     Z        f4 #>   <chr> <chr> <chr> <chr> <dbl> #> 1 AFR_1 EUR_1 NEA_1 CH_1  -741. ts_samples(ts) #> # A tibble: 58 × 3 #>    name   time pop   #>    <chr> <dbl> <chr> #>  1 NEA_1 70000 NEA   #>  2 NEA_2 40000 NEA   #>  3 EUR_1 39171 EUR   #>  4 EUR_2 39134 EUR   #>  5 EUR_3 37739 EUR   #>  6 EUR_4 36531 EUR   #>  7 EUR_5 36362 EUR   #>  8 EUR_6 35945 EUR   #>  9 EUR_7 33900 EUR   #> 10 EUR_8 33854 EUR   #> # ℹ 48 more rows"},{"path":"https://bodkan.net/slendr/articles/vignette-05-tree-sequences.html","id":"estimating-neanderthal-ancestry-proportions","dir":"Articles","previous_headings":"","what":"Estimating Neanderthal ancestry proportions","title":"Tree-sequence processing and statistics","text":"Let’s try put new tools practice estimate proportion Neanderthal ancestry Africans Europeans simulated data. can using Patterson’s f4f_4-ratio statistic implemented ts_f4ratio() function slendr (can find information particular version statistic Petr et al., PNAS 2019): now summarise inferred Neanderthal distribution populations, see Neanderthal ancestry Africans (expected model–Africans receive Neanderthal introgression pulse) small proportion Neanderthal ancestry Europeans (consistent 3% introgression pulse simulated ):  exactly specified model configuration , suggesting simulations work . can see quite bit noise ’s simulated small amount sequence. can also plot trajectory Neanderthal ancestry Europe time-window simulated ancient present-day DNA samples:  , result consistent empirical estimates Neanderthal ancestry using ancient DNA data (see Petr et al., PNAS 2019).","code":"# first get a table of simulated African and European individuals in the tree-sequence inds <- ts_samples(ts) %>% dplyr::filter(pop %in% c(\"AFR\", \"EUR\"))  # estimate the amounts of Neanderthal ancestry in these individuals and add # these values to the table inds$ancestry <- ts_f4ratio(ts, X = inds$name, \"NEA_1\", \"NEA_2\", \"AFR_1\", \"CH_1\")$alpha ggplot(inds, aes(pop, ancestry, fill = pop)) +   geom_boxplot() +   geom_jitter() +   labs(y = \"Neanderthal ancestry proportion\", x = \"\") +   theme(legend.position = \"none\") +   coord_cartesian(ylim = c(0, 0.1)) dplyr::filter(inds, pop == \"EUR\") %>%   ggplot(aes(time, ancestry)) +   geom_point() +   geom_smooth(method = \"lm\", linetype = 2, color = \"red\", linewidth = 0.5) +   xlim(40000, 0) + coord_cartesian(ylim = c(0, 0.1)) +   labs(x = \"time [years ago]\", y = \"Neanderthal ancestry proportion\") #> `geom_smooth()` using formula = 'y ~ x'"},{"path":"https://bodkan.net/slendr/articles/vignette-05-tree-sequences.html","id":"admixtools-analyses","dir":"Articles","previous_headings":"","what":"ADMIXTOOLS analyses","title":"Tree-sequence processing and statistics","text":"case like verify f-statistics results using venerable ADMIXTOOLS software (see linked paper formally introduced statistics first place), can convert tree-sequence data file format called EIGENSTRAT using ts_eigenstrat() function. file conversion internally handled R package admixr returns EIGENSTRAT object ties individual EIGENSTRAT file components together (see tutorial admixr extensive overview). admixr R package running automated ADMIXTOOLS analyses entirely R makes types analyses convenient. Running admixr analysis easy plugging object admixr function. instance, can estimate proportion Neanderthal ancestry couple individuals XX like (admixr calls proportion alpha): fact, lets compare values obtained tskit admixr/ADMIXTOOLS individuals:  correspondence two looks good! 🎉 , note large amount variance around expected value 3% ancestry due extremely small amount sequence data simulated .","code":"snps <- ts_eigenstrat(ts, prefix = file.path(tempdir(), \"eigenstrat\", \"data\")) #> 1282 multiallelic sites (0.206% out of 621331 total) detected and removed library(admixr)  f4ratio(data = snps, X = c(\"EUR_1\", \"EUR_2\", \"AFR_2\"),         A = \"NEA_1\", B = \"NEA_2\", C = \"AFR_1\", O = \"CH_1\") #> # A tibble: 3 × 8 #>   A     B     X     C     O       alpha  stderr Zscore #>   <chr> <chr> <chr> <chr> <chr>   <dbl>   <dbl>  <dbl> #> 1 NEA_1 NEA_2 EUR_1 AFR_1 CH_1  0.0218  0.00506   4.30 #> 2 NEA_1 NEA_2 EUR_2 AFR_1 CH_1  0.0328  0.00788   4.16 #> 3 NEA_1 NEA_2 AFR_2 AFR_1 CH_1  0.00408 0.00208   1.96 europeans <- inds[inds$pop == \"EUR\", ]$name  # tskit result result_ts <- ts_f4ratio(ts, X = europeans, A = \"NEA_1\", B = \"NEA_2\", C = \"AFR_1\", O = \"CH_1\") %>% select(alpha_ts = alpha)  # result obtained by admixr/ADMIXTOOLS result_admixr <- f4ratio(snps, X = europeans, A = \"NEA_1\", B = \"NEA_2\", C = \"AFR_1\", O = \"CH_1\") %>% select(alpha_admixr = alpha)  bind_cols(result_admixr, result_ts) %>%   ggplot(aes(alpha_ts, alpha_admixr)) +   geom_point() +   geom_abline(slope = 1, linetype = 2, color = \"red\", linewidth = 0.5) +   labs(x = \"f4-ratio statistic calculated with admixr/ADMIXTOOLS\",        y = \"f4-ratio statistic calculated with tskit\")"},{"path":"https://bodkan.net/slendr/articles/vignette-05-tree-sequences.html","id":"vcf-output","dir":"Articles","previous_headings":"","what":"VCF output","title":"Tree-sequence processing and statistics","text":"case need process simulated data software, can use function ts_vcf() save simulated genotypes VCF format: can also specify subset individuals saved VCF:","code":"ts_vcf(ts, path = file.path(tempdir(), \"output.vcf.gz\")) ts_vcf(ts, path = file.path(tempdir(), \"output_subset.vcf.gz\"),        individuals = c(\"CH_1\", \"NEA_1\", \"EUR_1\", \"AFR_1\"))"},{"path":"https://bodkan.net/slendr/articles/vignette-05-tree-sequences.html","id":"other-statistics","dir":"Articles","previous_headings":"","what":"Other statistics","title":"Tree-sequence processing and statistics","text":"follows brief overview statistics implemented tskit slendr provides easy--use R interface. see, goal functions get result using single function call, making convenient quick interactive exploratory analyses simulated data right R console. continue use simulated Neanderthal introgression tree-sequence data examples.","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-05-tree-sequences.html","id":"f_st","dir":"Articles","previous_headings":"Other statistics","what":"FstF_{st}","title":"Tree-sequence processing and statistics","text":"FstF_{st} statistic implemented function ts_fst(). single genome-wide FstF_{st} calculated (.e. window-based calculation), ts_fst() returns simple three-column data frame case non-named list sample sets provided, set names generated automatically: course, much less readable encourage name sample sets appropriately. case two sample sets specified, pairwise statistics computed: many statistics implemented tskit, ts_fst() accepts windows argument, specifying breakpoints windows. case, Fst column resulting data frame called “list-column”, item column vector FstF_{st} values, one per window. List-columns can little confusing new R users, highly encourage get used allow extremely concise elegant handling structured data within normal data frames (can start introduction). instance, window-based FstF_st values afr-vs-eur calculation (first row table ):","code":"ts_fst(ts, sample_sets = list(afr = c(\"AFR_1\", \"AFR_2\", \"AFR_3\"), eur = c(\"EUR_1\", \"EUR_2\"))) #> # A tibble: 1 × 3 #>   x     y        Fst #>   <chr> <chr>  <dbl> #> 1 afr   eur   0.0495 ts_fst(ts, sample_sets = list(c(\"AFR_1\", \"AFR_2\", \"AFR_3\"), c(\"EUR_1\", \"EUR_2\"))) #> # A tibble: 1 × 3 #>   x     y        Fst #>   <chr> <chr>  <dbl> #> 1 set_1 set_2 0.0495 ts_fst(ts, sample_sets = list(afr = c(\"AFR_1\", \"AFR_2\", \"AFR_3\"),                               eur = c(\"EUR_1\", \"EUR_2\"),                               nea = c(\"NEA_1\", \"NEA_2\"))) #> # A tibble: 3 × 3 #>   x     y        Fst #>   <chr> <chr>  <dbl> #> 1 afr   eur   0.0495 #> 2 afr   nea   0.555  #> 3 eur   nea   0.541 # define breakpoints between 20 windows breakpoints <- seq(0, ts$sequence_length, length.out = 21)  # calculate window-based Fst statistic win_fst <- ts_fst(   ts, windows = breakpoints,   sample_sets = list(afr = c(\"AFR_1\", \"AFR_2\", \"AFR_3\"),                      eur = c(\"EUR_1\", \"EUR_2\"),                      nea = c(\"NEA_1\", \"NEA_2\")) )  # we get 20 values for each parwise calculation win_fst #> # A tibble: 3 × 3 #>   x     y     Fst          #>   <chr> <chr> <named list> #> 1 afr   eur   <dbl [20]>   #> 2 afr   nea   <dbl [20]>   #> 3 eur   nea   <dbl [20]> win_fst[1, ]$Fst #> $`1` #>  [1] 0.04241163 0.06803338 0.04129167 0.06031210 0.05516414 0.03059425 #>  [7] 0.03320629 0.05755971 0.05271680 0.04346970 0.03659568 0.05432308 #> [13] 0.05913699 0.05905198 0.04119386 0.04389669 0.05086942 0.06181126 #> [19] 0.03929837 0.06373172"},{"path":"https://bodkan.net/slendr/articles/vignette-05-tree-sequences.html","id":"tajimas-d","dir":"Articles","previous_headings":"Other statistics","what":"Tajima’s DD","title":"Tree-sequence processing and statistics","text":"function ts_tajima() nearly interface ts_fst() shown . non-window version calculated, get single genome-wide values sample set (named non-named list character vectors individual names): window-based version, function returns D column list column vectors ii-th element Tajima’s D value ii-th window:","code":"ts_tajima(ts, list(afr = c(\"AFR_1\", \"AFR_2\", \"AFR_3\"), eur = c(\"EUR_1\", \"EUR_2\"))) #> # A tibble: 2 × 2 #>   set           D #>   <chr>     <dbl> #> 1 afr   -0.000701 #> 2 eur   -0.0140 ts_tajima(ts, list(afr = c(\"AFR_1\", \"AFR_2\"), eur = c(\"EUR_1\", \"EUR_2\")), windows = breakpoints) #> # A tibble: 2 × 2 #>   set   D            #>   <chr> <named list> #> 1 afr   <dbl [20]>   #> 2 eur   <dbl [20]>"},{"path":"https://bodkan.net/slendr/articles/vignette-05-tree-sequences.html","id":"diversity","dir":"Articles","previous_headings":"Other statistics","what":"Diversity","title":"Tree-sequence processing and statistics","text":"can calculate diversity within given groups individuals function ts_diversity(). instance, even extremely simplified example, expect highest levels diversity Africans, followed Europeans, Neanderthals “degenerate” single individual outgroup “chimpanzee”. true? Let’s find . First extract individuals populations, creating list character vectors group (functions ts_diversity() expects input): Now can calculate diversity population sort results increasing order diversity: Great! matches expectations. simulated chimp “population” one individual, expect essentially diversity millions years evolution.","code":"# get sampled individuals from all populations sample_sets <- ts_samples(ts) %>%   split(., .$pop) %>%   lapply(function(pop) pop$name)  sample_sets #> $AFR #> [1] \"AFR_1\" \"AFR_2\" \"AFR_3\" \"AFR_4\" \"AFR_5\" #>  #> $CH #> [1] \"CH_1\" #>  #> $EUR #>  [1] \"EUR_1\"  \"EUR_2\"  \"EUR_3\"  \"EUR_4\"  \"EUR_5\"  \"EUR_6\"  \"EUR_7\"  \"EUR_8\"  #>  [9] \"EUR_9\"  \"EUR_10\" \"EUR_11\" \"EUR_12\" \"EUR_13\" \"EUR_14\" \"EUR_15\" \"EUR_16\" #> [17] \"EUR_17\" \"EUR_18\" \"EUR_19\" \"EUR_20\" \"EUR_21\" \"EUR_22\" \"EUR_23\" \"EUR_24\" #> [25] \"EUR_25\" \"EUR_26\" \"EUR_27\" \"EUR_28\" \"EUR_29\" \"EUR_30\" \"EUR_31\" \"EUR_32\" #> [33] \"EUR_33\" \"EUR_34\" \"EUR_35\" \"EUR_36\" \"EUR_37\" \"EUR_38\" \"EUR_39\" \"EUR_40\" #> [41] \"EUR_41\" \"EUR_42\" \"EUR_43\" \"EUR_44\" \"EUR_45\" \"EUR_46\" \"EUR_47\" \"EUR_48\" #> [49] \"EUR_49\" \"EUR_50\" #>  #> $NEA #> [1] \"NEA_1\" \"NEA_2\" ts_diversity(ts, sample_sets) %>% dplyr::arrange(diversity) #> # A tibble: 4 × 2 #>   set   diversity #>   <chr>     <dbl> #> 1 CH    0.0000431 #> 2 NEA   0.0000455 #> 3 EUR   0.000394  #> 4 AFR   0.000400"},{"path":"https://bodkan.net/slendr/articles/vignette-05-tree-sequences.html","id":"divergence","dir":"Articles","previous_headings":"Other statistics","what":"Divergence","title":"Tree-sequence processing and statistics","text":"can calculate pairwise divergence groups individuals using function ts_divergence(). Given model, expect lowest divergence two modern human groups AFR EUR, Neanderthals two modern humans, three groups (AFR, EUR NEA) equal, much deeper divergence outgroup chimpanzee CH. sorting table based value divergence column, can see results fit expectations.","code":"ts_divergence(ts, sample_sets) %>% arrange(divergence) #> # A tibble: 6 × 3 #>   x     y     divergence #>   <chr> <chr>      <dbl> #> 1 AFR   EUR     0.000449 #> 2 EUR   NEA     0.000757 #> 3 AFR   NEA     0.000780 #> 4 CH    NEA     0.00401  #> 5 CH    EUR     0.00402  #> 6 AFR   CH      0.00402"},{"path":"https://bodkan.net/slendr/articles/vignette-05-tree-sequences.html","id":"more-information","dir":"Articles","previous_headings":"","what":"More information","title":"Tree-sequence processing and statistics","text":"couple examples statistical functions implemented tskit provide native R interface slendr. can find tree-sequence statistics reference manual project website. statistics tskit library implemented, intend expand selection provided slendr near future. functionality like use project missing slendr, please don’t hesitate let us now creating issue GitHub page. Finally, like see examples tskit interface action, take look vignette describes switching SLiM msprime back ends slendr package.","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-06-locations.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Spatially annotated tree sequences","text":"main selling point slendr R package programming complex spatially explicit population genetic models. use SLiM simulation engine, can store simulated data efficiently tree sequence format allows us run large population-scale simulations. previous vignettes, described can specify spatial population dynamics can access tree sequence data calculate population genetic statistics (focusing non-spatial models simplicity). Now ’s time show work simulated tree sequence spatial context.","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-06-locations.html","id":"model-specification","dir":"Articles","previous_headings":"","what":"Model specification","title":"Spatially annotated tree sequences","text":"Let’s first load required R libraries: begin specifying spatial model. use demographic model modern human history West Eurasia, extensively discussed introductory tutorial main landing page. complete model definition script, without comments: sanity check defined demography correctly, can plot graph summarizing population divergences geneflow events calling plot_model(model):  completeness, (slightly busy) overview spatial population ranges defined :","code":"library(slendr)  library(dplyr) library(ggplot2)  init_env()  seed <- 314159 set.seed(seed) # simulated world map map <- world(   xrange = c(-13, 70), # min-max longitude   yrange = c(18, 65),  # min-max latitude   crs = \"EPSG:3035\"    # coordinate reference system (CRS) for West Eurasia )  # couple of broad geographic regions africa <- region(   \"Africa\", map,   polygon = list(c(-18, 20), c(38, 20), c(30, 33),                  c(20, 33), c(10, 38), c(-6, 35)) ) europe <- region(   \"Europe\", map,   polygon = list(     c(-8, 35), c(-5, 36), c(10, 38), c(20, 35), c(25, 35),     c(33, 45), c(20, 58), c(-5, 60), c(-15, 50)   ) ) anatolia <- region(   \"Anatolia\", map,   polygon = list(c(28, 35), c(40, 35), c(42, 40),                  c(30, 43), c(27, 40), c(25, 38)) )  # define population histories  # African ancestral population afr <- population(   \"AFR\", time = 52000, N = 3000,   map = map, polygon = africa )  # population of the first migrants out of Africa ooa <- population(   \"OOA\", parent = afr, time = 51000, N = 500, remove = 25000,   center = c(33, 30), radius = 400e3 ) %>%   move(     trajectory = list(c(40, 30), c(50, 30), c(60, 40)),     start = 50000, end = 40000, snapshots = 20   )  # Eastern hunter-gatherers ehg <- population(   \"EHG\", parent = ooa, time = 28000, N = 1000, remove = 6000,   polygon = list(     c(26, 55), c(38, 53), c(48, 53), c(60, 53),     c(60, 60), c(48, 63), c(38, 63), c(26, 60)) )  # European population eur <- population(name = \"EUR\", parent = ehg, time = 25000, N = 2000, polygon = europe)  # Anatolian farmers ana <- population(   name = \"ANA\", time = 28000, N = 3000, parent = ooa, remove = 4000,   center = c(34, 38), radius = 500e3, polygon = anatolia ) %>%   expand_range(     by = 2500e3, start = 10000, end = 7000,     polygon = join(europe, anatolia), snapshots = 20   ) # expand the range by 2.500 km  # Yamnaya steppe population yam <- population(   name = \"YAM\", time = 7000, N = 500, parent = ehg, remove = 2500,   polygon = list(c(26, 50), c(38, 49), c(48, 50),                  c(48, 56), c(38, 59), c(26, 56)) ) %>%   move(trajectory = list(c(15, 50)), start = 5000, end = 3000, snapshots = 10)  # geneflow events gf <- list(   gene_flow(from = ana, to = yam, proportion = 0.5, start = 6000, end = 5000, overlap = FALSE),   gene_flow(from = ana, to = eur, proportion = 0.5, start = 8000, end = 6000),   gene_flow(from = yam, to = eur, proportion = 0.75, start = 4000, end = 3000) )  # compile the spatial model model <- compile_model(   populations = list(afr, ooa, ehg, eur, ana, yam),   gene_flow = gf,   generation_time = 30, resolution = 10e3,   competition = 150e3, mating = 120e3, dispersal = 90e3 ) plot_model(model) plot_map(afr, ooa, ehg, eur, ana, yam)"},{"path":"https://bodkan.net/slendr/articles/vignette-06-locations.html","id":"scheduling-sampling-events-and-simulation","dir":"Articles","previous_headings":"","what":"Scheduling sampling events and simulation","title":"Spatially annotated tree sequences","text":"Now schedule sampling single individual population every two thousand years, starting 40 thousand years ago way present (feature discussed basic tree sequence overview): Finally, can simulate data model process output tree sequence (recapitate simplify ):","code":"# one ancient individual every two thousand years ancient <- schedule_sampling(model,                     times = seq(40000, 1, by = -500),                     list(ooa, 1), list(ehg, 1), list(eur, 1),                     list(ana, 1), list(yam, 1))  # present-day Africans and Europeans present <- schedule_sampling(model, times = 0, list(afr, 5), list(eur, 30))  samples <- rbind(ancient, present) ts <- slim(   model, sequence_length = 100e3, recombination_rate = 1e-8, burnin = 200e3,   samples = samples, method = \"batch\", random_seed = 314159, max_attempts = 1 ) %>%   ts_recapitate(recombination_rate = 1e-8, Ne = 10000, random_seed = seed) %>%   ts_simplify()  ts #> ╔═════════════════════════╗ #> ║TreeSequence             ║ #> ╠═══════════════╤═════════╣ #> ║Trees          │      101║ #> ╟───────────────┼─────────╢ #> ║Sequence Length│  100,000║ #> ╟───────────────┼─────────╢ #> ║Time Units     │    ticks║ #> ╟───────────────┼─────────╢ #> ║Sample Nodes   │      432║ #> ╟───────────────┼─────────╢ #> ║Total Size     │222.4 KiB║ #> ╚═══════════════╧═════════╝ #> ╔═══════════╤═════╤════════╤════════════╗ #> ║Table      │Rows │Size    │Has Metadata║ #> ╠═══════════╪═════╪════════╪════════════╣ #> ║Edges      │1,241│38.8 KiB│          No║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Individuals│  730│73.1 KiB│         Yes║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Migrations │    0│ 8 Bytes│          No║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Mutations  │    0│ 1.2 KiB│          No║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Nodes      │  948│35.8 KiB│         Yes║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Populations│    7│ 2.7 KiB│         Yes║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Provenances│    3│46.8 KiB│          No║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Sites      │    0│16 Bytes│          No║ #> ╚═══════════╧═════╧════════╧════════════╝"},{"path":"https://bodkan.net/slendr/articles/vignette-06-locations.html","id":"extracting-spatial-tree-sequence-information","dir":"Articles","previous_headings":"","what":"Extracting spatial tree sequence information","title":"Spatially annotated tree sequences","text":"showed basic tutorial, important function data exploration ts_nodes(). function extracts information individuals nodes recorded tree sequence object loaded annotated slendr : completeness, also functions ts_individuals(), ts_nodes() ts_edges() extract tree sequence tables “raw” unprocessed form, ts_nodes() much convenient data exploration analyses. First, combined information low-level tables individuals nodes single table importantly, model generated data spatial model, ts_nodes() automatically annotates node/individual tables position node space (real projected coordinates) time. means can spatial data analysis directly table returned ts_nodes(). Even better, although can see returned object belongs slendr’s class slendr_ts_nodes, internally stored spatial sf object. means can use functionality powerful R package sf well many packages geospatial analyses directly data: Typing object R console presents user-friendly summary spatio-temporal data extracted tree sequence: first part summary, see many individuals (sampled retained) nodes present tree sequence together additional useful information, including section internally stored sf object. crucial point—**can always use internal sf object spatial data directly*. data returned ts_nodes() internally transformed projected CRS used model, can use returned object data class sf. instance, beginning vignette, specified world map model represented projected CRS (EPSG 3035) can verify typing: fact ts_nodes() result just another sf object makes easy visualize overlay contents map, see .","code":"data <- ts_nodes(ts) class(data) #> [1] \"slendr\"       \"slendr_nodes\" \"sf\"           \"tbl_df\"       \"tbl\"          #> [6] \"data.frame\" data #> Simple feature collection with 948 features and 12 fields (with 2 geometries empty) #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 2721964 ymin: 428651.3 xmax: 8613304 ymax: 4959957 #> Projected CRS: ETRS89-extended / LAEA Europe #> # A tibble: 948 × 13 #>    name  pop   node_id  time time_tskit           location sampled #>    <chr> <fct>   <int> <dbl>      <dbl>        <POINT [m]> <lgl>   #>  1 AFR_1 AFR       362     0          0 (3665253 847038.2) TRUE    #>  2 AFR_1 AFR       363     0          0 (3665253 847038.2) TRUE    #>  3 AFR_2 AFR       364     0          0 (4877281 428651.3) TRUE    #>  4 AFR_2 AFR       365     0          0 (4877281 428651.3) TRUE    #>  5 AFR_3 AFR       366     0          0 (3491753 724345.8) TRUE    #>  6 AFR_3 AFR       367     0          0 (3491753 724345.8) TRUE    #>  7 AFR_4 AFR       368     0          0  (3754934 1216666) TRUE    #>  8 AFR_4 AFR       369     0          0  (3754934 1216666) TRUE    #>  9 AFR_5 AFR       370     0          0  (3806357 1063276) TRUE    #> 10 AFR_5 AFR       371     0          0  (3806357 1063276) TRUE    #> # ℹ 938 more rows #> # ℹ 6 more variables: remembered <lgl>, retained <lgl>, alive <lgl>, #> #   pedigree_id <dbl>, ind_id <dbl>, pop_id <int> map #> slendr 'map' object  #> -------------------  #> map: internal coordinate reference system EPSG 3035  #> spatial limits (in degrees longitude and latitude): #>   - vertical -13 ... 70 #>   - horizontal 18 ... 65"},{"path":"https://bodkan.net/slendr/articles/vignette-06-locations.html","id":"using-the-simple-features-interface","dir":"Articles","previous_headings":"","what":"Using the simple features interface","title":"Spatially annotated tree sequences","text":"’s hard overstate powerful R ecosystem around sf package . However, getting familiar package geospatial analysis general can bit hurdle, especially novice users takes time get familiar many new concepts. Although many slendr features encoding programming spatial models handling simulated tree sequence data discussed far designed abstract away complexities underlying low-level details let focus problem hand, spatial data analysis unfortunately whole another matter. Luckily, data generated slendr different source spatial data great free resources disposal. bottom line : spatio-temporal data extracted tree sequences slendr different normal sf object. resource find manipulating, plotting, analysing sf data can applied slendr results well. remainder vignette look couple examples.","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-06-locations.html","id":"plotting-locations-of-simulated-sampled-individuals","dir":"Articles","previous_headings":"","what":"Plotting locations of simulated sampled individuals","title":"Spatially annotated tree sequences","text":"Every spatial object slendr internally class sf. flexibility ggplot2 sf packages means can overlay locations sampled individuals (saved sf format ts_nodes()) top world map (also sf object):  sf simple features objects (, extension, even slendr_spatial objects) internally stored normal data frames couple bells whistles top , powerful tools manipulating tabular data disposal. example, let’s say wanted split sampled individuals tree sequence epochs plot individually using standard ggplot2 features. simply first , adding new column specifying epoch simulated individual belong: chunk code simply adds new column epoch sf spatial data frame object called epochs . can use ggplot2 function geom_sf plot locations sampled individuals map, facet corresponding one epoch (warning can safely ignored):  hope little excursion handling slendr spatial objects (, extension, sf objects) standard data frame manipulation functions ggplot2 visualisation convinced great flexibility analysing spatial slendr data. best introduction -called “tidy” data analysis, encourage read freely-available book R Data Science.","code":"sampled_data <- ts_nodes(ts) %>% filter(sampled)  ggplot() +   geom_sf(data = map, fill = \"lightgray\", color = NA) +   geom_sf(data = sampled_data, aes(shape = pop, color = time)) +   ggtitle(\"Locations of simulated sampled individuals\") +   scale_color_continuous(type = \"viridis\") +   theme_bw() epochs <- sampled_data %>%   mutate(epoch = cut(time, breaks = c(40000, 30000, 10000, 4000, 0)),          epoch = ifelse(is.na(epoch), 0, epoch),          epoch = factor(epoch, labels = c(\"present\", \"(present, 4 ky]\", \"(4 ky, 10 ky]\",                                           \"(10 ky, 30 y]\", \"(30 ky, 40 ky]\"))) ggplot() +   geom_sf(data = map, fill = \"lightgray\", color = NA) +   geom_sf(data = epochs, aes(shape = pop, color = pop)) +   facet_wrap(~ epoch) +   ggtitle(\"Locations of simulated sampled individuals in different epochs\") +   theme_bw()"},{"path":"https://bodkan.net/slendr/articles/vignette-06-locations.html","id":"extracting-spatio-temporal-ancestral-relationships","dir":"Articles","previous_headings":"","what":"Extracting spatio-temporal ancestral relationships","title":"Spatially annotated tree sequences","text":"Perhaps even useful plotting locations simulated individuals accessing locations (times) ancestors particular tree sequence node (“focal node”). Starting focal node individual, can trace geographical location nodes lineage going back way root function ts_ancestors(). record time location every individual happens ancestor least one sampled individual, means know true location every node tree sequence. simplest use case determining locations times every single node genealogical history individual along tree sequence (possible recover ancestral relationships multiple samples ): function starts given node (, name sampled diploid individual provided, two nodes), extracts information parent nodes node entire tree sequence, records locations times, proceeds one level “higher” genealogical history gather information parents parent nodes, etc., reaches root node. result process another sf object row table encodes information single branch genealogy “focal” node individual (example, \"EUR_25\"): row table, two columns location parent_location carry spatial location node (node_id) parent node (parent_id), respectively, columns time parent_time (times nodes) pop parent_pop (populations nodes belong). column connection contains sf geometry object line connecting two nodes coordinate reference system “model world”. column focal_id tells us focal node’s genealogy rows table belong , level column shows deep genealogical past branch (.e. row table) belong . table contains complete information spatio-temporal relationships nodes genealogy given focal sample. spirit demonstrating slendr tree sequence tables interact sf ggplot2 environments, let’s look immediate parent nodes two nodes sampled individual (.e. nodes level 1) using filter function R package dplyr: mentioned , three columns encoding spatial information: location parent_location carry information location child parent node (POINT class), connection object (LINESTRING class) contains line connecting two nodes (branch tree sequence also spatial connection). can plot three spatial features (two points line) individually map:  figure can see red focal node immediate parents tree sequence genealogy (coalescent sense, immediate parents individual!). case ’re surprised see two parents, recall recombination events make history encoded sample complicated can involve ancestors “move ” tree sample, just two ancestors. Looking example detail, can see one node (chromosome) individual “EUR_67” two ancestors, covering portion individuals chromosome, chromosome covered single ancestor (columns left_pos right_pos): convenient way analysis companion function ts_ancestors() called plot_ancestors(). function accepts sf object spatial branching data created ts_ancestors() plots paths nodes map leading focal node root(s) tree sequence (instead just paths immediate parents shown previous figure). case, working single diploid individual, get two sets paths nodes (chromosomes) plot two facets:  can compare result animation recapitulates simulation, presented first vignette. comparing spatial tree sequence figure animation, can immediately notice several things: spatial tree sequence paths trace ancestry single European individual back Africa. fact, also see cluster past ancestral nodes (.e. concentrated coalescent events) place Africa (OOA) migrant population settled around 40,000 thousand years ago (yellow population animation). One chromosome traces ancestry EHG population indicated green square expected programmed Yamnaya migration (descending EHG) east central Europe contribute significant part ancestry present-day Europeans (compare demographic graph top vignette). also see chromosome traces ancestry Anatolia (blue crosses). makes sense, simulated European ancestry part Anatolian. Let’s look spatial ancestry another sample. instance, know simulated history Anatolian population model much simpler. According demographic graph , Anatolians split ancestral population Eurasians Anatolia expanded wave Europe. sampled following individuals: Can see hint spatial dynamics Anatolians spatio-temporal distribution ancestral node locations one sampled individuals? Let’s pick last individual immediately plot spatial ancestry tidyverse-style using pipe operator %>%:  might expect given late age sample, position map (red crossed circle) Anatolia Europe represents one descendants migrants moved Anatolia Europe. can clearly seen position parental nodes tree sequence: nodes represent real individuals lived point past, can see , indeed, lived Anatolia.","code":"ind <- \"EUR_67\"  lineages <- ts_ancestors(ts, ind, verbose = TRUE) #> Collecting ancestors of EUR_67 [1/1]... #>  #> Generating data about spatial relationships of nodes... lineages #> Simple feature collection with 134 features and 12 fields #> Active geometry column: connection #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 2721964 ymin: 546923.8 xmax: 8506059 ymax: 4652439 #> Projected CRS: ETRS89-extended / LAEA Europe #> # A tibble: 134 × 15 #>    name  pop   node_id level child_id parent_id child_time parent_time child_pop #>  * <chr> <fct>   <int> <fct>    <int>     <int>      <dbl>       <dbl> <fct>     #>  1 EUR_… EUR       406 1          406       446          0        1300 EUR       #>  2 EUR_… EUR       406 2          446       469       1300        3550 EUR       #>  3 EUR_… EUR       406 3          469       488       3550        5890 EUR       #>  4 EUR_… EUR       406 4          488       494       5890        6970 EUR       #>  5 EUR_… EUR       406 4          488       570       5890       13690 EUR       #>  6 EUR_… EUR       406 5          494       570       6970       13690 EUR       #>  7 EUR_… EUR       406 5          570       675      13690       21370 EUR       #>  8 EUR_… EUR       406 6          675       750      21370       25960 EUR       #>  9 EUR_… EUR       406 7          750       756      25960       26230 EHG       #> 10 EUR_… EUR       406 8          756       792      26230       28000 EHG       #> # ℹ 124 more rows #> # ℹ 6 more variables: parent_pop <fct>, child_location <POINT [m]>, #> #   parent_location <POINT [m]>, connection <LINESTRING [m]>, left_pos <dbl>, #> #   right_pos <dbl> filter(lineages, level == 1) #> Simple feature collection with 2 features and 12 fields #> Active geometry column: connection #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 3898723 ymin: 2562183 xmax: 4274254 ymax: 2895750 #> Projected CRS: ETRS89-extended / LAEA Europe #> # A tibble: 2 × 15 #>   name   pop   node_id level child_id parent_id child_time parent_time child_pop #> * <chr>  <fct>   <int> <fct>    <int>     <int>      <dbl>       <dbl> <fct>     #> 1 EUR_67 EUR       406 1          406       446          0        1300 EUR       #> 2 EUR_67 EUR       407 1          407       503          0        7810 EUR       #> # ℹ 6 more variables: parent_pop <fct>, child_location <POINT [m]>, #> #   parent_location <POINT [m]>, connection <LINESTRING [m]>, left_pos <dbl>, #> #   right_pos <dbl> level1_branches <- ts_ancestors(ts, \"EUR_67\") %>% filter(level == 1)  ggplot() +   geom_sf(data = map, fill = \"lightgray\", color = NA) +   geom_sf(data = level1_branches[, ]$child_location, shape = 13, size = 3, color = \"red\") +   geom_sf(data = level1_branches[, ]$connection, linetype = 3) +   geom_sf(data = level1_branches[, ]$parent_location, shape = 20, color = \"blue\") +   theme_bw() +   ggtitle(\"Parent nodes (blue) of a focal individual (red)\") as_tibble(level1_branches)[, c(\"name\", \"node_id\", \"child_id\", \"parent_id\", \"left_pos\", \"right_pos\")] #> # A tibble: 2 × 6 #>   name   node_id child_id parent_id left_pos right_pos #>   <chr>    <int>    <int>     <int>    <dbl>     <dbl> #> 1 EUR_67     406      406       446        0    100000 #> 2 EUR_67     407      407       503        0    100000 ggplot() +   geom_sf(data = map) +   geom_sf(data = lineages, size = 0.5, alpha = 0.2) +   geom_sf(data = sf::st_set_geometry(lineages, \"parent_location\"),           aes(shape = parent_pop, color = parent_pop)) +   geom_sf(data = filter(ts_nodes(ts), name == ind), size = 3) +   guides(alpha = \"none\") +   coord_sf(expand = 0) +   labs(x = \"longitude\", y = \"latitude\") +   facet_grid(. ~ node_id) +   ggtitle(\"Ancestry encoded by two nodes (chromosomes) of EUR_67\") ts_samples(ts) %>% filter(pop == \"ANA\") #> # A tibble: 48 × 3 #>    name    time pop   #>    <chr>  <int> <chr> #>  1 ANA_1  27500 ANA   #>  2 ANA_2  27000 ANA   #>  3 ANA_3  26500 ANA   #>  4 ANA_4  26000 ANA   #>  5 ANA_5  25500 ANA   #>  6 ANA_6  25000 ANA   #>  7 ANA_7  24500 ANA   #>  8 ANA_8  24000 ANA   #>  9 ANA_9  23500 ANA   #> 10 ANA_10 23000 ANA   #> # ℹ 38 more rows lineages <- ts_ancestors(ts, \"ANA_45\")  ggplot() +   geom_sf(data = map) +   geom_sf(data = lineages, size = 0.5, alpha = 0.2) +   geom_sf(data = sf::st_set_geometry(lineages, \"parent_location\"),           aes(shape = parent_pop, color = parent_pop)) +   geom_sf(data = filter(ts_nodes(ts), name == \"ANA_45\"), size = 3) +   guides(alpha = \"none\") +   coord_sf(expand = 0) +   labs(x = \"longitude\", y = \"latitude\") +   facet_grid(. ~ node_id) +   ggtitle(\"Ancestry encoded by two nodes (chromosomes) of ANA_45\")"},{"path":"https://bodkan.net/slendr/articles/vignette-06-locations.html","id":"calculating-distances-and-other-statistics-using-the-sf-package","dir":"Articles","previous_headings":"","what":"Calculating distances and other statistics using the sf package","title":"Spatially annotated tree sequences","text":"can summarise spatial ancestral dynamics figures using statistics? Lets take one look sf object locations times ancestral nodes sampled individuals, focusing following subset columns: can use standard dplyr table manipulation functions compute distances connected notes times separate (.e. branch lengths traditional phylogenetic sense). can use two quantities compute fast () movement ancestral individuals different time periods history sample: Let’s also convert data (absolute distances distance per generation – .e., “speed”) long format easier plotting side side: Let’s try summarise information distances “traveled” nodes different time period fitting spline (rather plotting raw data individual nodes):","code":"lineages <-   ts_samples(ts) %>%   pull(name) %>%   ts_ancestors(ts, x = .)  select(lineages, connection, child_time, parent_time) #> Simple feature collection with 23928 features and 2 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 2721964 ymin: 428651.3 xmax: 8613304 ymax: 4959957 #> Projected CRS: ETRS89-extended / LAEA Europe #> # A tibble: 23,928 × 3 #>                             connection child_time parent_time #>                       <LINESTRING [m]>      <dbl>       <dbl> #>  1  (8103641 3334456, 7956278 3180199)      40000       40330 #>  2  (7956278 3180199, 8036310 1911729)      40330       43900 #>  3  (7956278 3180199, 8031610 2059804)      40330       44020 #>  4  (8036310 1911729, 8031610 2059804)      43900       44020 #>  5  (8031610 2059804, 7687313 1689532)      44020       45970 #>  6  (7687313 1689532, 7175192 1476174)      45970       47740 #>  7  (7687313 1689532, 6867500 1338048)      45970       48730 #>  8  (7175192 1476174, 6867500 1338048)      47740       48730 #>  9  (6867500 1338048, 6754277 1091742)      48730       49810 #> 10 (6754277 1091742, 3290558 497125.8)      49810       60400 #> # ℹ 23,918 more rows distances <- lineages %>%   mutate(branch_length = abs(parent_time - child_time) / model$generation_time,          distance = sf::st_length(connection) %>% units::set_units(km) %>% as.numeric(),          speed = distance / branch_length,          epoch = cut(parent_time, breaks = c(Inf, seq(60000, 0, by = -3000)), dig.lab = 10, include.lowest = TRUE)) %>%   as_tibble() %>% # strip away the spatial annotation   select(name, pop, node_id, branch_length, distance, speed, parent_pop, parent_time, child_pop, child_time, epoch) distances_long <- distances %>%   filter(child_time < 60000) %>%   filter(!pop %in% c(\"AFR\", \"OOA\")) %>%   tidyr::pivot_longer(cols = c(distance, speed),                       names_to = \"stat\",                       values_to = \"value\") %>%   mutate(facet = case_when(     stat == \"distance\" ~ \"absolute distance of a node from parent\",     stat == \"speed\" ~ \"distance traveled by a node per generation\")) distances_long %>%   ggplot(aes(child_time, value, color = child_pop)) +   geom_smooth(method = \"loess\", aes(group = child_pop)) +   geom_hline(yintercept = 0, linetype = 2, linewidth = 0.5) +   labs(y = \"kilometers\", x = \"time [years ago]\") +   theme(axis.text.x = element_text(hjust = 1, angle = 45),         legend.position = \"bottom\") +   facet_wrap(~ facet, scales = \"free_y\") +   guides(color = guide_legend(\"ancestral node population\")) #> `geom_smooth()` using formula = 'y ~ x'"},{"path":[]},{"path":"https://bodkan.net/slendr/articles/vignette-07-engines.html","id":"defining-a-model","dir":"Articles","previous_headings":"Detecting gene flow from msprime and SLiM tree sequences","what":"Defining a model","title":"Simulations using SLiM and msprime engines","text":"now define simple non-spatial model gene flow populations (also known population admixture introgression). involve essentially procedure shown another vignette introducing non-spatial slendr models. Note different normally specify spatial model, except left map argument making population() calls. demonstrate additional features slendr interface tskit Python library, perform gene flow detection test using -called f4f_4 f4f_4-ratio statistics (briefly introduces vignette). make things little interesting, define two population models: one model without gene flow, another includes gene flow. defining model expressing ff-statistics use nomenclature used first study Patterson et al. described f4−ratiof_4-ratio statistic first place. ’re familiar statistical tests gene flow, recommend take look relevant sections linked paper. shiny_graph Let’s start first defining populations splits established figure : Note Ne populations x1 x2 set much higher rest. set NeN_e populations lower values speed forward SLiM simulations (won’t affect results ’re interested anyway). Higher values NeN_e x1 x2 populations ensure effect drift acting two populations much smaller. simulate later measure proportion ancestry population b x1, ensure ancestry proportion drift far away expectation make interesting patterns stand clearly. (course, done demonstration purposes speed SLiM simulations making NeN_e populations smaller. practice, running kinds simulations using msprime back end.)","code":"seq_len <- 100e6 # amount of sequence to simulate rec_rate <- 1e-8 # uniform recombination rate mut_rate <- 1e-8 # mutation rate  o <- population(\"outgroup\", time = 1, N = 100) c <- population(\"c\", time = 2500, N = 100, parent = o) a <- population(\"a\", time = 3000, N = 100, parent = c) b <- population(\"b\", time = 3500, N = 100, parent = a) x1 <- population(\"x1\", time = 3800, N = 5000, parent = c) x2 <- population(\"x2\", time = 4000, N = 5000, parent = x1)"},{"path":"https://bodkan.net/slendr/articles/vignette-07-engines.html","id":"compiling-the-model-and-simulating-data","dir":"Articles","previous_headings":"","what":"Compiling the model and simulating data","title":"Simulations using SLiM and msprime engines","text":"now use populations compile two models: first model without gene flow (left panel figure ), second model include 10% gene flow b x1 (right panel figure ). also schedule sampling couple individuals end simulation: 50 individuals populations x1 x2 capture bit natural variation b ancestry x1, one individual rest. running simulations, let’s first make sure models set correctly:   Now run models (without gene flow) two slendr backends, SLiM msprime: Note using exactly model configuration object simulation runs! fact, even function interface looks nearly exactly . doesn’t matter specific details demographic models , slendr interpret correctly regardless back end simulation engine choose use.","code":"# no gene flow model model_nogf <- compile_model(populations = list(a, b, x1, x2, c, o), generation_time = 1, simulation_length = 4500)  samples <- schedule_sampling(   model_nogf, times = 4500,   list(a, 1), list(b, 1), list(x1, 50), list(x2, 50), list(c, 1), list(o, 1) )  # model with gene flow gf <- gene_flow(from = b, to = x1, start = 4100, end = 4400, proportion = 0.1)  model_gf <- compile_model(populations = list(a, b, x1, x2, c, o), gene_flow = gf, generation_time = 1, simulation_length = 4500)  samples <- schedule_sampling(   model_gf, times = 4500,   list(a, 1), list(b, 1), list(x1, 50), list(x2, 50), list(c, 1), list(o, 1) ) plot_model(model_nogf, sizes = FALSE) plot_model(model_gf, sizes = FALSE, proportions = TRUE) # model without gene flow slim_nogf <- slim(model_nogf, sequence_length = seq_len, recombination_rate = rec_rate, samples = samples, random_seed = seed) msprime_nogf <- msprime(model_nogf, sequence_length = seq_len, recombination_rate = rec_rate, samples = samples, random_seed = seed)  # model with b -> x1 gene flow slim_gf <- slim(model_gf, sequence_length = seq_len, recombination_rate = rec_rate, samples = samples, random_seed = seed) msprime_gf <- msprime(model_gf, sequence_length = seq_len, recombination_rate = rec_rate, samples = samples, random_seed = seed)"},{"path":"https://bodkan.net/slendr/articles/vignette-07-engines.html","id":"comparing-the-outputs-of-msprime-and-slim-runs-of-a-slendr-model","dir":"Articles","previous_headings":"Compiling the model and simulating data","what":"Comparing the outputs of msprime and SLiM runs of a slendr model","title":"Simulations using SLiM and msprime engines","text":"run introgression models two simulation back ends, let’s load SLiM msprime tree sequence outputs compare contents (hoping !). can see , tree sequence summary data loaded processed slendr’s ts_read() function (data produced SLiM backend) similar got “manually” msprime-produced tree sequence using custom defined functions. somehow obvious nice cheap sanity check indicating tree sequence data structure produced two backends demographic model almost .","code":"# SLiM outputs -- we can use built-in slendr functions for those slim_nogf <-   slim_nogf %>%   ts_recapitate(Ne = 10, recombination_rate = rec_rate, random_seed = seed) %>%   ts_mutate(mut_rate, random_seed = seed)  slim_gf <-   slim_gf %>%   ts_recapitate(Ne = 10, recombination_rate = rec_rate, random_seed = seed) %>%   ts_mutate(mut_rate, random_seed = seed)  # msprime outputs (note that recapitation and simplification doesn't make # sense here because we already have fully coalesced genealogies for our # individuals  of interest msprime_nogf <- ts_mutate(msprime_nogf, mut_rate, random_seed = seed) msprime_gf <- ts_mutate(msprime_gf, mut_rate, random_seed = seed) slim_nogf #> ╔════════════════════════╗ #> ║TreeSequence            ║ #> ╠═══════════════╤════════╣ #> ║Trees          │ 248,158║ #> ╟───────────────┼────────╢ #> ║Sequence Length│   1e+08║ #> ╟───────────────┼────────╢ #> ║Time Units     │   ticks║ #> ╟───────────────┼────────╢ #> ║Sample Nodes   │  21,008║ #> ╟───────────────┼────────╢ #> ║Total Size     │70.5 MiB║ #> ╚═══════════════╧════════╝ #> ╔═══════════╤═══════╤════════╤════════════╗ #> ║Table      │Rows   │Size    │Has Metadata║ #> ╠═══════════╪═══════╪════════╪════════════╣ #> ║Edges      │972,815│29.7 MiB│          No║ #> ╟───────────┼───────┼────────┼────────────╢ #> ║Individuals│131,789│12.6 MiB│         Yes║ #> ╟───────────┼───────┼────────┼────────────╢ #> ║Migrations │      0│ 8 Bytes│          No║ #> ╟───────────┼───────┼────────┼────────────╢ #> ║Mutations  │256,674│ 9.1 MiB│          No║ #> ╟───────────┼───────┼────────┼────────────╢ #> ║Nodes      │157,230│ 5.5 MiB│         Yes║ #> ╟───────────┼───────┼────────┼────────────╢ #> ║Populations│      7│ 2.8 KiB│         Yes║ #> ╟───────────┼───────┼────────┼────────────╢ #> ║Provenances│      3│46.9 KiB│          No║ #> ╟───────────┼───────┼────────┼────────────╢ #> ║Sites      │256,355│ 6.1 MiB│          No║ #> ╚═══════════╧═══════╧════════╧════════════╝ msprime_nogf #> ╔═══════════════════════════╗ #> ║TreeSequence               ║ #> ╠═══════════════╤═══════════╣ #> ║Trees          │     62,745║ #> ╟───────────────┼───────────╢ #> ║Sequence Length│      1e+08║ #> ╟───────────────┼───────────╢ #> ║Time Units     │generations║ #> ╟───────────────┼───────────╢ #> ║Sample Nodes   │        208║ #> ╟───────────────┼───────────╢ #> ║Total Size     │   14.4 MiB║ #> ╚═══════════════╧═══════════╝ #> ╔═══════════╤═══════╤═════════╤════════════╗ #> ║Table      │Rows   │Size     │Has Metadata║ #> ╠═══════════╪═══════╪═════════╪════════════╣ #> ║Edges      │247,454│  7.6 MiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Individuals│    104│  2.9 KiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Migrations │      0│  8 Bytes│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Mutations  │ 69,172│  2.4 MiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Nodes      │ 32,685│893.7 KiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Populations│      6│414 Bytes│         Yes║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Provenances│      2│  3.9 KiB│          No║ #> ╟───────────┼───────┼─────────┼────────────╢ #> ║Sites      │ 69,144│  1.6 MiB│          No║ #> ╚═══════════╧═══════╧═════════╧════════════╝"},{"path":"https://bodkan.net/slendr/articles/vignette-07-engines.html","id":"comparing-results-of-population-genetics-statistics","dir":"Articles","previous_headings":"Compiling the model and simulating data","what":"Comparing results of population genetics statistics","title":"Simulations using SLiM and msprime engines","text":"loaded msprime SLiM tree sequences generated model, let’s see can get comparable results calculate statistics interest. Let’s first extract individuals populations x1 x2 estimate values f4(c,x1 x2;b,o)f_4(c, x1 \\textrm{ } x2; b, o) (significantly negative individuals population x1 due ’s ancestry coming b introgression models consistent zero x2) f4-ratio(,b, x2;c,o)f_4\\textrm{-ratio}(, b, \\textrm{ } x2; c, o), estimates proportion b-like ancestry x1 x2: Now, let’s repeat analysis tree sequences produced msprime backend two slendr demographic models: Finally can proceed plotting SLiM msprime backend results two models compare together. noted , despite fact SLiM forward simulator msprime coalescent simulator, population genetic expectations gene flow gene flow models match closely (barring level uncertainty expected due randomness population genetic processes play).   Things seem looking good behave expected! couple observations: model without gene flow, f4f_4 statistic value zero x1 x2 populations. expected, f4f_4 ~0 consistent relationship lineages conforming standard phylogenetic tree (admixture edges). Essentially, f4f_4 hypothesis test “tree-ness” data. model includes gene flow b x1, f4f_4 value significantly negative. means simple tree hypothesis can rejected gene flow must occurred b x1. Note test reveal direction gene flow, ’s presence. Consistently f4f_4 results, f4−ratiof_4-ratio estimates match expectations. Specifically, statistic estimates around 10% ancestry b x1 gene flow model 0% ancestry cases. importantly, results obtained SLiM msprime back ends nearly exactly . means (non-spatial models) can use SLiM msprime backend interchangeably.","code":"# extract vector of names of the \"test individuals\" in populations `x1` and `x2` X <- ts_samples(slim_gf) %>% filter(pop %in% c(\"x1\", \"x2\")) %>% pull(name) X #>   [1] \"x1_1\"  \"x1_2\"  \"x1_3\"  \"x1_4\"  \"x1_5\"  \"x1_6\"  \"x1_7\"  \"x1_8\"  \"x1_9\"  #>  [10] \"x1_10\" \"x1_11\" \"x1_12\" \"x1_13\" \"x1_14\" \"x1_15\" \"x1_16\" \"x1_17\" \"x1_18\" #>  [19] \"x1_19\" \"x1_20\" \"x1_21\" \"x1_22\" \"x1_23\" \"x1_24\" \"x1_25\" \"x1_26\" \"x1_27\" #>  [28] \"x1_28\" \"x1_29\" \"x1_30\" \"x1_31\" \"x1_32\" \"x1_33\" \"x1_34\" \"x1_35\" \"x1_36\" #>  [37] \"x1_37\" \"x1_38\" \"x1_39\" \"x1_40\" \"x1_41\" \"x1_42\" \"x1_43\" \"x1_44\" \"x1_45\" #>  [46] \"x1_46\" \"x1_47\" \"x1_48\" \"x1_49\" \"x1_50\" \"x2_1\"  \"x2_2\"  \"x2_3\"  \"x2_4\"  #>  [55] \"x2_5\"  \"x2_6\"  \"x2_7\"  \"x2_8\"  \"x2_9\"  \"x2_10\" \"x2_11\" \"x2_12\" \"x2_13\" #>  [64] \"x2_14\" \"x2_15\" \"x2_16\" \"x2_17\" \"x2_18\" \"x2_19\" \"x2_20\" \"x2_21\" \"x2_22\" #>  [73] \"x2_23\" \"x2_24\" \"x2_25\" \"x2_26\" \"x2_27\" \"x2_28\" \"x2_29\" \"x2_30\" \"x2_31\" #>  [82] \"x2_32\" \"x2_33\" \"x2_34\" \"x2_35\" \"x2_36\" \"x2_37\" \"x2_38\" \"x2_39\" \"x2_40\" #>  [91] \"x2_41\" \"x2_42\" \"x2_43\" \"x2_44\" \"x2_45\" \"x2_46\" \"x2_47\" \"x2_48\" \"x2_49\" #> [100] \"x2_50\" # calculate f4-statistics on individuals of `x1` and `x2` populations using data # from the two models (a model with no gene flow and a gene flow model) -- we use # map_dfr to iterate across all individuals from `X_individuals` and binding all # resulting data frames into a single data frame df_slim_f4 <- rbind(   map_dfr(X, ~ ts_f4(slim_nogf, \"c_1\", .x, \"b_1\", \"outgroup_1\")) %>% mutate(model = \"no gene flow\"),   map_dfr(X, ~ ts_f4(slim_gf, \"c_1\", .x, \"b_1\", \"outgroup_1\")) %>% mutate(model = \"gene flow\") ) %>%   select(X, f4, model) %>%   mutate(simulator = \"SLiM backend\")  # compute the proportions of `b` ancestry in `x1` (expected 10%) and `x2` # (expected 0% because this population did not receive any gene flow from `b`) df_slim_f4ratio <- rbind(   ts_f4ratio(slim_nogf, X, \"a_1\", \"b_1\", \"c_1\", \"outgroup_1\") %>% mutate(model = \"no gene flow\"),   ts_f4ratio(slim_gf, X, \"a_1\", \"b_1\", \"c_1\", \"outgroup_1\") %>% mutate(model = \"gene flow\") ) %>%   select(X, alpha, model) %>%   mutate(simulator = \"SLiM backend\") df_msprime_f4 <- rbind(   map_dfr(X, ~ ts_f4(msprime_nogf, \"c_1\", .x, \"b_1\", \"outgroup_1\")) %>% mutate(model = \"no gene flow\"),   map_dfr(X, ~ ts_f4(msprime_gf, \"c_1\", .x, \"b_1\", \"outgroup_1\")) %>% mutate(model = \"gene flow\") ) %>%   select(X, f4, model) %>%   mutate(simulator = \"msprime backend\")  # compute the proportions of `b` ancestry in `x1` (expected 10%) and `x2` # (expected 0% because this population did not receive any gene flow from `b`) df_msprime_f4ratio <- rbind(   ts_f4ratio(msprime_nogf, X, \"a_1\", \"b_1\", \"c_1\", \"outgroup_1\") %>% mutate(model = \"no gene flow\"),   ts_f4ratio(msprime_gf, X, \"a_1\", \"b_1\", \"c_1\", \"outgroup_1\") %>% mutate(model = \"gene flow\") ) %>%   select(X, alpha, model) %>%   mutate(simulator = \"msprime backend\") df_f4 <- rbind(df_slim_f4, df_msprime_f4) %>%   mutate(population = ifelse(grepl(\"x1_\", X),                              \"x1 (received gene flow)\",                              \"x2 (no gene flow)\"))  ggplot(df_f4, aes(f4, fill = population)) +   geom_histogram(bins = 50) +   facet_grid(simulator ~ model) +   geom_vline(xintercept = 0, linetype = 2) +   labs(y = \"number of individuals\", x = \"f4 statistic\",        title = \"f4(c, x1 or x2; b, outgroup)\",        subtitle = \"f4 ~0 is consistent with no gene flow, negative value indicates gene flow with 'b'\") +   theme(legend.position = \"bottom\") df_f4ratio <- rbind(df_slim_f4ratio, df_msprime_f4ratio) %>%   mutate(population = ifelse(grepl(\"x1_\", X),                              \"x1 (received gene flow)\",                              \"x2 (no gene flow)\"))  ggplot(df_f4ratio, aes(alpha, fill = population)) +   geom_histogram(bins = 30) +   facet_grid(simulator ~ model) +   geom_vline(xintercept = 0.1, linetype = 2) +   labs(y = \"number of individuals\", x = \"ancestry proportion (f4-ratio statistic)\",        title = \"f4-ratio estimate of 'b' ancestry calculated from simulated data\",        subtitle = \"f4-ratio = f4(a, outgroup; x1 or x2, c) / f4(a, outgroup; b, c)\") +   theme(legend.position = \"bottom\")"},{"path":"https://bodkan.net/slendr/articles/vignette-07-engines.html","id":"computing-allele-frequency-spectra","dir":"Articles","previous_headings":"","what":"Computing allele frequency spectra","title":"Simulations using SLiM and msprime engines","text":"Let’s look one example. Imagine following five demographic models describing changes population size abstract population:  models population size change events , depending specifics project, defined using different time units. work radiocarbon-dated samples ancient DNA might used thinking population history units “years present”—case, “present” time (bottom figure) time 0 earlier events specified “5000 years present”, etc. hand, interested modelling theoretical population, might want concern quite happy starting simulation “generation 1” continue specified “generation X”. slendr package makes extremely easy, can specify times whatever direction units want, long kept consistent populations events model. rather unique feature among popgen simulation software programs either make express model “generations forward direction”, explicitly convert time generations going backwards. previous section vignette shown SLiM msprime can used simulation backend. remainder vignette present additional analysis, demonstrating fact can express time models forward backward direction still run models slendr’s SLiM (forward simulator) msprime (backward simulator). Specifically, define five demographic models figure twice, different orientations time – forward backward. compute allele frequency spectrum simulation (five models, forward backward) verify forward backward pairs give result regardless whether use SLiM back end msprime backend.","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-07-engines.html","id":"model-definition","dir":"Articles","previous_headings":"Computing allele frequency spectra","what":"Model definition","title":"Simulations using SLiM and msprime engines","text":"First, let’s define five population histories forward time direction: Now let’s flip flow time around define population histories units “time ago”: convenience, write helper function , given population history object (ten objects just ), compile slendr model, run SLiM msprime back ends, load tree sequence, compute allele frequency spectrum (AFS) . save us lots code repetition (always good thing), minimize chance copy-pasting bugs (definitely good thing!) compare AFS patterns across different models two slendr simulation back ends (according population genetics theory). Now function doesn’t anything special. simply wraps standard slendr simulation pipeline (1. create population(s); 2. compile model object; 3. simulate model; 4. load results; 5. analyse data) single function. Now whole pipeline, can generate simulated data bind result single data frame: Finally, can plot allele frequency spectra models, two time directions, two simulation back ends:  , couple things note: two models involve population contraction (single step exponential collapse), see decrease low frequency variants. hand, models population expansion show high proportion low frequency variants. model constant population size shows intermediate pattern. nice validation simulation works expected exactly predicted population genetics theory. forward backward time models give exactly result. unexpected anything else bug slendr. However, although unsurprising, hope makes clear free use whatever time unit specification want encode slendr models. non-spatial models, results obtained msprime SLiM back ends consistent one another. , makes sense although completely different software, population genetic theory governing shape allele frequency spectra applies equally . fact, example just implemented important part slendr unit test suite verifies simulations created slendr correct.","code":"N <- 1000 N_factor <- 5 # by what factor should Ne change  seq_len <- 50e6 rec_rate <- 1e-8 mut_rate <- 1e-8 # constant Ne model forward_const <- population(\"const\", time = 1, N = N)  # decreasing step Ne model forward_decr <- population(\"decr\", time = 1, N = N, map = FALSE) %>%   resize(time = 2000, N = N / N_factor, how = \"step\")  # increasing step Ne model forward_incr <- population(\"inc\", time = 1, N = N) %>%   resize(time = 2000, N = N * N_factor, how = \"step\")  # exponential increase in size forward_exp_incr <- population(\"exp_inc\", time = 1, N = N) %>%   resize(time = 2000, end = 3000, N = N * N_factor, how = \"exponential\")  # exponential decrease in size forward_exp_decr <- population(\"exp_decr\", time = 1, N = N) %>%   resize(time = 2000, end = 3000, N = N / N_factor, how = \"exponential\") # constant Ne model backward_const <- population(\"const\", time = 5000, N = N)  # decreasing step Ne model backward_decr <- population(\"decr\", time = 5000, N = N) %>%   resize(time = 3000, N = N / N_factor, how = \"step\")  # increasing step Ne model backward_incr <- population(\"inc\", time = 5000, N = N) %>%   resize(time = 3000, N = N * N_factor, how = \"step\")  # exponential increase in size backward_exp_incr <- population(\"exp_inc\", time = 5000, N = N) %>%   resize(time = 3000, end = 2000, N = N * N_factor, how = \"exponential\")  # exponential decrease in size backward_exp_decr <- population(\"exp_decr\", time = 5000, N = N) %>%   resize(time = 3000, end = 2000, N = N / N_factor, how = \"exponential\") compile_run_afs <- function(model_name, pop, seed = 42) {   # maximum length of the simulation (necessary for forward models which start   # in generation 1)   simulation_length <- 5000    # define sampling times given the direction of time   if (attr(pop, \"history\")[[1]]$time == 1) {     sampling_time <- simulation_length     direction <- \"forward\"   } else {     sampling_time <- 0     direction <- \"backward\"   }    # compile model   model <- compile_model(pop, generation_time = 15, direction = direction, simulation_length = simulation_length)    samples <- schedule_sampling(model, times = sampling_time, list(pop, 50))    # run the model in SLiM   ts_slim <- slim(model, sequence_length = seq_len, recombination_rate = rec_rate,                   samples = samples, random_seed = seed, verbose = FALSE)    # run the same model in msprim   ts_msprime <- msprime(model, sequence_length = seq_len, recombination_rate = rec_rate,                         samples = samples, random_seed = seed, verbose = FALSE)    # load the SLiM tree sequence   ts_slim <- ts_recapitate(ts_slim, Ne = N, recombination_rate = rec_rate, random_seed = seed) %>%     ts_mutate(mut_rate, random_seed = seed)    # load the msprime tree sequence   ts_msprime <- ts_mutate(ts_msprime, mut_rate, random_seed = seed)    # compute the AFS from the SLiM and msprime tree sequences and bind the   # results (derived allele counts per frequency bin) in a data frame   msprime_afs <- ts_afs(ts_msprime, polarised = TRUE)[-1]   slim_afs <- ts_afs(ts_slim, polarised = TRUE)[-1]    rbind(     data.frame(simulator = \"msprime\", model = model_name, f = msprime_afs),     data.frame(simulator = \"SLiM\", model = model_name, f = slim_afs)   ) %>%     group_by(simulator, model) %>%     mutate(n = 1:n(), direction = direction) %>%     ungroup() } afs <- bind_rows(   compile_run_afs(\"constant\", forward_const),   compile_run_afs(\"constant\", backward_const),   compile_run_afs(\"step contraction\", forward_decr),   compile_run_afs(\"step contraction\", backward_decr),   compile_run_afs(\"step increase\", forward_incr),   compile_run_afs(\"step increase\", backward_incr),   compile_run_afs(\"exponential decrease\", forward_exp_decr),   compile_run_afs(\"exponential decrease\", backward_exp_decr),   compile_run_afs(\"exponential increase\", forward_exp_incr),   compile_run_afs(\"exponential increase\", backward_exp_incr) ) %>%   mutate(model = factor(     model, levels = c(\"step contraction\", \"constant\", \"step increase\",                       \"exponential decrease\", \"exponential increase\"))   ) ggplot(afs, aes(n, f, color = direction, linetype = simulator)) +   geom_line(stat = \"identity\") +   facet_wrap(~ model) +   labs(x = \"number of derived alleles\", y = \"frequency\",        title = \"Site frequency spectra obtained from five demographic models\",        subtitle = \"Each model was specified in forward or backward direction of time and executed by two different backend scripts in slendr (SLiM and msprime)\") +   guides(color = guide_legend(\"direction of\\ntime in slendr\"),          linetype = guide_legend(\"slendr backend\\nengine used\")) +   scale_linetype_manual(values = c(3, 2)) +   scale_x_continuous(breaks = c(1, seq(20, 100, 20)), limits = c(1, 100)) +   theme(legend.position = \"bottom\")"},{"path":"https://bodkan.net/slendr/articles/vignette-07-engines.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Simulations using SLiM and msprime engines","text":"example shows standard, non-spatial demographic model like implement simulate R, slendr gives way efficiently using ’s msprime back end addition SLiM back end used throughout documentation.","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-08-nonslendr-tskit.html","id":"non-spatial-slim-tree-sequences","dir":"Articles","previous_headings":"","what":"Non-spatial SLiM tree sequences","title":"Analyzing non-slendr tree sequences","text":"Consider following SLiM script, creates couple populations (different NeN_e) splitting ancestral population p1 (lets save /tmp/nonspatial.slim): run script SLiM, can use slendr load output tree sequence (saved /tmp/nonspatial-slim.trees), simplify , overlay mutations using standard functionality originally developed slendr tree sequences. Note command use loading slendr tree sequences, except direct ts_read() function straight tree-sequence output file rather using ts_read(<model-object>) format used working standard slendr simulations. way, slendr can extract information individual’s names, nodes, population assignments, etc. just slendr tree sequence function ts_nodes(). standard slendr models, function loads “raw” node individual tree-sequences tables, performs couple join operations, presents whole thing nice unified form interactive data analysis (can also include spatial information—see ): Moving tskit statistics, can use data table extract list nodes belonging population (various tskit tree-sequence statistics operate , slendr follows design). computing nucleotide diversity four populations using ts_diversity() function, first creating list lists node IDs (.e. chromosomes) individuals population: Just slendr tree sequences (demonstrated paper) can get individual trees , extracted phylogenetic format provided ape R package. first simplify tree sequence even just 10 nodes make things manageable: R tree object, can use packages like ggtree visualize tree (phylogenetic package work ). Note nodes ‘ape phylo’ trees must conform strict format (must labelled 1...N), extract information node IDs tskit tree-sequence data able plot tree.","code":"initialize() {     setSeed(42);     initializeTreeSeq();     initializeMutationRate(0);     initializeMutationType(\"m1\", 0.5, \"f\", 0.0);     initializeGenomicElementType(\"g1\", m1, 1.0);     initializeGenomicElement(g1, 0, 1e6);     initializeRecombinationRate(1e-8); }  1 early() {     sim.addSubpop(\"p1\", 10); }  1000 early() {     sim.addSubpopSplit(\"p2\", 500, p1); }  3000 early() {     sim.addSubpopSplit(\"p3\", 2500, p1); }  5000 early() {     sim.addSubpopSplit(\"p4\", 10000, p1); }  6000 late() {     sim.treeSeqOutput(\"/var/folders/lq/bl36db_s6w908hnjkntdp4140000gn/T//RtmpBB7nOY/file62275a78c50e\"); } ts <- ts_read(nonspatial_trees_file) %>%   ts_simplify() %>%   ts_mutate(mutation_rate = 1e-7, random_seed = SEED) data <- ts_nodes(ts) %>% dplyr::filter(sampled) data #> # A tibble: 26,020 × 11 #>    pop   node_id  time time_tskit sampled remembered retained alive pedigree_id #>    <chr>   <int> <dbl>      <dbl> <lgl>   <lgl>      <lgl>    <lgl>       <dbl> #>  1 p1          0     0          0 TRUE    FALSE      FALSE    TRUE     20073000 #>  2 p1          1     0          0 TRUE    FALSE      FALSE    TRUE     20073000 #>  3 p1          2     0          0 TRUE    FALSE      FALSE    TRUE     20073001 #>  4 p1          3     0          0 TRUE    FALSE      FALSE    TRUE     20073001 #>  5 p1          4     0          0 TRUE    FALSE      FALSE    TRUE     20073002 #>  6 p1          5     0          0 TRUE    FALSE      FALSE    TRUE     20073002 #>  7 p1          6     0          0 TRUE    FALSE      FALSE    TRUE     20073003 #>  8 p1          7     0          0 TRUE    FALSE      FALSE    TRUE     20073003 #>  9 p1          8     0          0 TRUE    FALSE      FALSE    TRUE     20073004 #> 10 p1          9     0          0 TRUE    FALSE      FALSE    TRUE     20073004 #> # ℹ 26,010 more rows #> # ℹ 2 more variables: ind_id <dbl>, pop_id <int> sample_sets <- split(data$node_id, data$pop)  # compute nucleotide diversity in each population # (any other ts_*() tskit R interface function should work) ts_diversity(ts, sample_sets) #> # A tibble: 4 × 2 #>   set    diversity #>   <chr>      <dbl> #> 1 p1    0.00000755 #> 2 p2    0.000241   #> 3 p3    0.000463   #> 4 p4    0.000201 samples <- sample(data$node_id, 10) ts_small <- ts_simplify(ts, simplify_to = samples)  # extract the 42nd tree in the genealogy to an R 'phylo' format tree <- ts_phylo(ts_small, 42 - 1) #> Starting checking the validity of tree... #> Found number of tips: n = 10  #> Found number of nodes: m = 9  #> Done. tree #>  #> Phylogenetic tree with 10 tips and 9 internal nodes. #>  #> Tip labels: #>   1, 0, 9, 4, 8, 7, ... #> Node labels: #>   45, 28, 22, 31, 35, 36, ... #>  #> Rooted; includes branch length(s). library(ggtree) #> ggtree v4.0.1 Learn more at https://yulab-smu.top/contribution-tree-data/ #>  #> Please cite: #>  #> Guangchuang Yu.  Data Integration, Manipulation and Visualization of #> Phylogenetic Trees (1st edition). Chapman and Hall/CRC. 2022, #> doi:10.1201/9781003279242, ISBN: 9781032233574 #>  #> Attaching package: 'ggtree' #> The following object is masked from 'package:magrittr': #>  #>     inset  labels <- ts_nodes(tree) %>% select(node = phylo_id, tskit_id = node_id)  ggtree(tree, branch.length = \"none\") %<+% labels +   geom_label(aes(label = tskit_id)) library(ape) plot(tree, show.tip.label = FALSE) nodelabels() tiplabels()"},{"path":"https://bodkan.net/slendr/articles/vignette-08-nonslendr-tskit.html","id":"msprime-non-slendr-tree-sequences","dir":"Articles","previous_headings":"","what":"msprime (non-slendr) tree sequences","title":"Analyzing non-slendr tree sequences","text":"applies also msprime tree sequences (really surprising, given ’s tskit hood). can start Python: can proceed loading msprime tree sequence R analyze slendr functionality:","code":"import msprime ts = msprime.sim_ancestry(100) ts.dump(<trees file>) ts <- ts_read(msprime_trees_file)  ts_nodes(ts) #> # A tibble: 199 × 7 #>    pop   ind_id node_id  time time_tskit sampled pop_id #>    <chr>  <dbl>   <int> <dbl>      <dbl> <lgl>    <int> #>  1 0         NA       0     0          0 TRUE         0 #>  2 0         NA       1     0          0 TRUE         0 #>  3 0         NA       2     0          0 TRUE         0 #>  4 0         NA       3     0          0 TRUE         0 #>  5 0         NA       4     0          0 TRUE         0 #>  6 0         NA       5     0          0 TRUE         0 #>  7 0         NA       6     0          0 TRUE         0 #>  8 0         NA       7     0          0 TRUE         0 #>  9 0         NA       8     0          0 TRUE         0 #> 10 0         NA       9     0          0 TRUE         0 #> # ℹ 189 more rows"},{"path":"https://bodkan.net/slendr/articles/vignette-08-nonslendr-tskit.html","id":"spatial-slim-non-slendr-tree-sequences","dir":"Articles","previous_headings":"","what":"Spatial SLiM (non-slendr) tree sequences","title":"Analyzing non-slendr tree sequences","text":"Furthermore, generalized interface also supports slendr’s spatial tree-sequence features, bells whistles. instance, lets take following spatial SLiM script (modified SLiM manual) execute SLiM usual way: can load simplify output tree sequence just vignette (anywhere slendr documentation): Finally, can access spatio-temporal data embedded output tree sequence standard slendr way (note spatial sf column location POINT data type): get tree sequence converted spatial sf data format, can use standard geospatial packages use spatial data analysis methods packages provide. briefly demonstrate means, can trivially plot location recorded node:  can also collect spatio-temporal ancestry information particular node (.e. times locations ancestors way root, “link” plot signifying parent-child edge somewhere along tree sequence) plot 2D surface (x y dimensions [0, 1]). plot little chaotic, hopefully conveys idea (“focal node” 0 highlighted red). essentially plot last figure paper.","code":"initialize() {     setSeed(42);       initializeSLiMOptions(keepPedigrees=T, dimensionality=\"xy\");       initializeTreeSeq();       initializeMutationRate(1e-7);       initializeMutationType(\"m1\", 0.5, \"f\", 0.0);       initializeGenomicElementType(\"g1\", m1, 1.0);       initializeGenomicElement(g1, 0, 1e6);       initializeRecombinationRate(1e-8); } 1 early() {     sim.addSubpop(\"p1\", 500);      // initial positions are random in ([0,1], [0,1])     p1.individuals.x = runif(p1.individualCount);       p1.individuals.y = runif(p1.individualCount); } modifyChild() {       // draw a child position near the first parent, within bounds       do child.x = parent1.x + rnorm(1, 0, 0.02);       while ((child.x < 0.0) | (child.x > 1.0));        do child.y = parent1.y + rnorm(1, 0, 0.02);       while ((child.y < 0.0) | (child.y > 1.0));        return T; } 1: late() {     sim.treeSeqRememberIndividuals(sim.subpopulations.individuals, permanent = F); }  10000 late() {     sim.treeSeqOutput(\"/var/folders/lq/bl36db_s6w908hnjkntdp4140000gn/T//RtmpBB7nOY/file62272df13262\"); } ts <- ts_read(spatial_trees_file) %>% ts_simplify() data <- ts_nodes(ts) data #> Simple feature collection with 1955 features and 11 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 0.07649281 ymin: 0.0006142841 xmax: 0.9984433 ymax: 0.9892587 #> CRS:           NA #> # A tibble: 1,955 × 12 #>    pop   node_id  time time_tskit               location sampled remembered #>    <chr>   <int> <dbl>      <dbl>                <POINT> <lgl>   <lgl>      #>  1 p1          0     0          0   (0.904485 0.0777489) TRUE    FALSE      #>  2 p1          1     0          0   (0.904485 0.0777489) TRUE    FALSE      #>  3 p1          2     0          0   (0.668828 0.5246381) TRUE    FALSE      #>  4 p1          3     0          0   (0.668828 0.5246381) TRUE    FALSE      #>  5 p1          4     0          0  (0.7707701 0.1518462) TRUE    FALSE      #>  6 p1          5     0          0  (0.7707701 0.1518462) TRUE    FALSE      #>  7 p1          6     0          0  (0.7617792 0.2616453) TRUE    FALSE      #>  8 p1          7     0          0  (0.7617792 0.2616453) TRUE    FALSE      #>  9 p1          8     0          0 (0.9807475 0.04223008) TRUE    FALSE      #> 10 p1          9     0          0 (0.9807475 0.04223008) TRUE    FALSE      #> # ℹ 1,945 more rows #> # ℹ 5 more variables: retained <lgl>, alive <lgl>, pedigree_id <dbl>, #> #   ind_id <dbl>, pop_id <int> ggplot() + geom_sf(data = data, aes(color = time), alpha = 0.5) ancestral_links <- ts_ancestors(ts, 0)  ggplot() +     geom_sf(data = ancestral_links, size = 0.5, aes(alpha = parent_time)) +     geom_sf(data = sf::st_set_geometry(ancestral_links, \"parent_location\"), aes(color = parent_time)) +     geom_sf(data = data[data$node_id == 0, ], size = 3, color = \"red\")"},{"path":"https://bodkan.net/slendr/articles/vignette-08-nonslendr-tskit.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Analyzing non-slendr tree sequences","text":"vignette gave brief overview using slendr’s R-tskit interface loading, processing, analyzing “pure” non-slendr tree sequences produced msprime SLiM scripts. Although touched upon basic features R-tskit interface standard tree sequences, important note far slendr concerned, matter tree sequence produced, long conforms tskit specification. means regardless source tree sequence data, able use slendr’s tskit functionality run analyses.","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-09-paper.html","id":"note","dir":"Articles","previous_headings":"","what":"Note","title":"Examples from the slendr paper","text":"Since publication slendr paper, new versions SLiM slendr released. Specifically, results paper based SLiM version 4.0.1 slendr version 0.5. Whenever new version SLiM released, ’s always chance aspect randomness simulation changes slightly, affects results even though random seed kept value. , figures paper (specifically figure Example 4 paper) look slightly different. However, results still relevant applicable, just presentation changed.","code":"# workaround for GitHub actions getting \"Killed\" due to out of memory issues # -- when running unit tests on GitHub, smaller amount of sequence will be # simulated if (Sys.getenv(\"RUNNER_OS\") != \"\") {   scaling <- 10 # use 10X less sequence on GitHub actions } else {   scaling <- 1 # but simulate normal amount of data otherwise }  library(slendr)  library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(ggplot2) library(purrr) library(tidyr) library(cowplot) library(forcats)  init_env() #> The interface to all required Python modules has been activated.  SEED <- 42 set.seed(SEED) # placeholder \"figure\" where a code chunk will be pasted p_code <- ggplot() +   geom_text(aes(x = 1, y = 1), label = \"code will be here\") +   theme_void()"},{"path":[]},{"path":"https://bodkan.net/slendr/articles/vignette-09-paper.html","id":"script-from-panel-a","dir":"Articles","previous_headings":"Example 1 (Figure 2)","what":"Script from panel A","title":"Examples from the slendr paper","text":"","code":"o <- population(\"o\", time = 1, N = 100) c <- population(\"c\", time = 2500, N = 100, parent = o) a <- population(\"a\", time = 2800, N = 100, parent = c) b <- population(\"b\", time = 3700, N = 100, parent = a) x1 <- population(\"x1\", time = 4000, N = 15000, parent = c) x2 <- population(\"x2\", time = 4300, N = 15000, parent = x1)  gf <- gene_flow(from = b, to = x1, start = 5400, end = 5800, 0.1)  model <- compile_model(   populations = list(o, a, b, c, x1, x2), gene_flow = gf,   generation_time = 1, simulation_length = 6000 )  plot_model(model, sizes = FALSE, proportions = TRUE) # panel B  ts <- msprime(model, sequence_length = 100e6 / scaling, recombination_rate = 1e-8, random_seed = SEED) %>%   ts_mutate(mutation_rate = 1e-8, random_seed = SEED)  samples <- ts_samples(ts) %>% group_by(pop) %>% sample_n(100)  # panel C divergence <- ts_divergence(ts, split(samples$name, samples$pop))  # panel D f4ratio <- ts_f4ratio(   ts, X = filter(samples, pop %in% c(\"x1\", \"x2\"))$name,   A = \"a_1\", B = \"b_1\", C = \"c_1\", O = \"o_1\" )"},{"path":[]},{"path":"https://bodkan.net/slendr/articles/vignette-09-paper.html","id":"plotting-code","dir":"Articles","previous_headings":"Example 1 (Figure 2)","what":"Plotting code","title":"Examples from the slendr paper","text":"","code":"divergence <- divergence %>% mutate(pair = paste(x, \"-\", y))  f4ratio <- f4ratio %>% mutate(population = gsub(\"^(.*)_.*$\", \"\\\\1\", X), alpha = alpha * 100)  p_ex1_divergence <- divergence %>%   ggplot(aes(fct_reorder(pair, divergence), divergence)) +   geom_point(size = 2.5) +   xlab(\"population pair\") + ylab(\"pairwise divergence\") +   theme_minimal() +   theme(legend.position = \"bottom\",         legend.text = element_text(size = 10),         axis.text.x = element_text(hjust = 1, angle = 45, size = 8),         axis.title.x = element_blank())  p_ex1_f4ratio <- f4ratio %>%   ggplot(aes(population, alpha)) +   geom_hline(yintercept = 0, linetype = 2) +   geom_jitter(alpha = 0.5) +   geom_boxplot(outlier.shape = NA, alpha = 0.7) +   ylab(base::expression(italic(\"f\")[4]~\"-ratio ancestry proportion [%]\")) +   theme_minimal() +   coord_cartesian(ylim = c(0, 20)) +   theme(legend.position = \"none\",         axis.text.x = element_text(size = 11),         axis.title.x = element_blank(),         panel.grid.major.x = element_blank())#; p_ex3_f4ratio  # let's avoid ggpubr as another dependency: # https://github.com/kassambara/ggpubr/blob/master/R/as_ggplot.R#L27 p_ex1_legend <- ggdraw() + draw_grob(grid::grobTree(get_legend(p_ex1_divergence)))  p_ex1_model <- plot_model(model, sizes = FALSE, proportions = TRUE)  p_ex1 <- plot_grid(   p_code,   plot_grid(     p_ex1_model,     plot_grid(       p_ex1_divergence + theme(legend.position = \"none\"),       p_ex1_f4ratio,       ncol = 2, rel_widths = c(1, 0.8), labels = c(\"C\", \"D\")     ),     p_ex1_legend, nrow = 3, rel_heights = c(1, 1, 0.1),     labels = \"B\"   ),   nrow = 1, labels = c(\"A\", \"\") )  p_ex1"},{"path":[]},{"path":"https://bodkan.net/slendr/articles/vignette-09-paper.html","id":"script-from-panel-a-1","dir":"Articles","previous_headings":"Example 2 (Figure 3)","what":"Script from panel A","title":"Examples from the slendr paper","text":"","code":"map <- world(xrange = c(0, 10), yrange = c(0, 10),              landscape = region(center = c(5, 5), radius = 5))  p1 <- population(\"pop1\", time = 1, N = 2000, map = map, competition = 0) p2 <- population(\"pop2\", time = 1, N = 2000, map = map, competition = 9) p3 <- population(\"pop3\", time = 1, N = 2000, map = map, competition = 6) p4 <- population(\"pop4\", time = 1, N = 2000, map = map, competition = 5) p5 <- population(\"pop5\", time = 1, N = 2000, map = map, competition = 4) p6 <- population(\"pop6\", time = 1, N = 2000, map = map, competition = 3) p7 <- population(\"pop7\", time = 1, N = 2000, map = map, competition = 2) p8 <- population(\"pop8\", time = 1, N = 2000, map = map, competition = 1)  model <- compile_model(   populations = list(p1, p2, p3, p4, p5, p6, p7, p8),   generation_time = 1, simulation_length = 5000, resolution = 0.1,   mating = 0.1, dispersal = 0.05 )  ts <-   slim(model, sequence_length = 10e6 / scaling, recombination_rate = 1e-8, random_seed = SEED) %>%   ts_simplify() %>%   ts_mutate(mutation_rate = 1e-7, random_seed = SEED) #> Warning: Simplifying a non-recapitated tree sequence. Make sure this is what #> you really want  locations <- ts_nodes(ts) %>% filter(time == max(time))  heterozygosity <- ts_samples(ts) %>%   group_by(pop) %>%   sample_n(100) %>%   mutate(pi = ts_diversity(ts, name)$diversity)"},{"path":"https://bodkan.net/slendr/articles/vignette-09-paper.html","id":"plotting-code-1","dir":"Articles","previous_headings":"Example 2 (Figure 3)","what":"Plotting code","title":"Examples from the slendr paper","text":"","code":"p_ex2_clustering <- ggplot() +   geom_sf(data = map) +   geom_sf(data = locations, aes(color = pop), size = 0.05, alpha = 0.25) +   facet_grid(. ~ pop, switch = \"x\") +   xlab(\"spatial distributions emerged in the simulation\") +   theme(     strip.background = element_blank(),     strip.text = element_text(size = 11),     panel.grid = element_blank(),     axis.ticks = element_blank(),     axis.text = element_blank(),     panel.background = element_blank()   ) +   guides(color = \"none\")  p_ex2_diversity <- ggplot(heterozygosity, aes(pop, pi, color = pop)) +   geom_violin(color = \"black\") +   geom_jitter(alpha = 0.5) +   labs(y = \"individual heterozygosity\") +   guides(color = \"none\") +   theme_minimal() +   theme(axis.title.x = element_blank(),         axis.text.x = element_blank(), panel.grid.major.x = element_blank(),         plot.margin = margin(t = 0.2, r = 0.2, b = -0.1, l = 0.2, \"cm\"))  p_ex2 <- plot_grid(   p_code,   plot_grid(     p_ex2_diversity,     p_ex2_clustering +       theme(plot.margin = margin(t = 0, r = 0.4, b = 0, l = 1.8, \"cm\")),     nrow = 2,     rel_heights = c(1, 0.5),     labels = c(\"B\", \"C\")   ),   nrow = 2, labels = c(\"A\", \"\"), rel_heights = c(1.5, 1) )  p_ex2"},{"path":[]},{"path":"https://bodkan.net/slendr/articles/vignette-09-paper.html","id":"script-from-panel-a-2","dir":"Articles","previous_headings":"Example 3 (Figure 4)","what":"Script from panel A","title":"Examples from the slendr paper","text":"","code":"map <- world(xrange = c(-13, 70), yrange = c(18, 65), crs = 3035)  R1 <- region(   \"EHG range\", map,   polygon = list(c(26, 55), c(38, 53), c(48, 53), c(60, 53),                  c(60, 60), c(48, 63), c(38, 63), c(26, 60)) ) R2 <- region(   \"Europe\", map,   polygon = list(     c(-8, 35), c(-5, 36), c(10, 38), c(20, 35), c(25, 35),     c(33, 45), c(20, 58), c(-5, 60), c(-15, 50)   ) ) R3 <- region(   \"Anatolia\", map,   polygon = list(c(28, 35), c(40, 35), c(42, 40),                  c(30, 43), c(27, 40), c(25, 38)) ) R4 <- join(R2, R3) R5 <- region(   \"YAM range\", map,   polygon = list(c(26, 50), c(38, 49), c(48, 50),                  c(48, 56), c(38, 59), c(26, 56)) )  ooa_trajectory <- list(c(40, 30), c(50, 30), c(60, 40), c(45, 55)) map <- world(xrange = c(-13, 70), yrange = c(18, 65), crs = 3035)  ooa <- population(   \"OOA\", time = 50000, N = 500, remove = 23000,    map = map, center = c(33, 30), radius = 400e3 ) %>%   move(trajectory = ooa_trajectory, start = 50000, end = 40000, snapshots = 30)  ehg <- population(   \"EHG\", time = 28000, N = 1000, parent = ooa, remove = 6000,   map = map, polygon = R1 )  eur <- population(   \"EUR\", time = 30000, N = 2000, parent = ooa,   map = map, polygon = R2 ) %>%   resize(N = 10000, time = 5000, end = 0, how = \"exponential\")  ana <- population(   \"ANA\", time = 25000, N = 4000, parent = ooa, remove = 3000,   map = map, polygon = R3 ) %>%   expand_range(by = 3e6, start = 10000, end = 7000, polygon = R4, snapshots = 15)  yam <- population(   \"YAM\", time = 7000, N = 600, parent = ehg, remove = 2500,   map = map, polygon = R5 ) %>%   move(trajectory = list(c(15, 50)), start = 5000, end = 3000, snapshots = 10)  gf <- list(   gene_flow(ana, to = yam, proportion = 0.5, start = 6500, end = 5000),   gene_flow(ana, to = eur, proportion = 0.6, start = 8000, end = 6000),   gene_flow(yam, to = eur, proportion = 0.7, start = 3500, end = 3000) )  model <- compile_model(   populations = list(ooa, ehg, eur, ana, yam), gene_flow = gf,   generation_time = 30, resolution = 10e3,   competition = 150e3, mating = 120e3, dispersal = 90e3 )  samples <- schedule_sampling(   model, times = seq(0, 50000, by = 1000),   list(ehg, 20), list(ana, 20), list(yam, 20), list(eur, 20) )  plot_model(model, sizes = FALSE) plot_map(model)  ts <- slim(   model, burnin = 200000, samples = samples, random_seed = SEED,   sequence_length = 200000, recombination_rate = 1e-8 )"},{"path":"https://bodkan.net/slendr/articles/vignette-09-paper.html","id":"plotting-code-2","dir":"Articles","previous_headings":"Example 3 (Figure 4)","what":"Plotting code","title":"Examples from the slendr paper","text":"","code":"p_map <- plot_map(model) +   theme(legend.position = \"bottom\") +   guides(alpha = \"none\")  p_ex3 <- plot_grid(   p_code,   plot_grid(     plot_model(model, sizes = FALSE),     p_map,     labels = c(\"B\", \"C\"), nrow = 2, rel_heights = c(1, 1)   ),   ncol = 2, labels = c(\"A\", \"\"), rel_widths = c(1, 1.2) )  p_ex3"},{"path":[]},{"path":"https://bodkan.net/slendr/articles/vignette-09-paper.html","id":"script-from-panel-a-3","dir":"Articles","previous_headings":"Example 4 (Figure 5)","what":"Script from panel A","title":"Examples from the slendr paper","text":"","code":"ts_small <- ts_simplify(ts, simplify_to = c(\"EUR_578\", \"YAM_75\", \"ANA_163\", \"EHG_208\"))  # tskit uses zero-based indexing tree <- ts_phylo(ts_small, i = 0 / scaling) #> Starting checking the validity of tree... #> Found number of tips: n = 8  #> Found number of nodes: m = 7  #> Done. nodes <- ts_nodes(tree) edges <- ts_edges(tree)  ancestors <- ts_ancestors(ts, \"EUR_578\")"},{"path":"https://bodkan.net/slendr/articles/vignette-09-paper.html","id":"plotting-code-3","dir":"Articles","previous_headings":"Example 4 (Figure 5)","what":"Plotting code","title":"Examples from the slendr paper","text":"explained top page, random number generation current SLiM slightly different version 4.0.1 available time writing paper. figure looks little different well (different random generation implies different movement individuals, different individuals sampled). record, ’s original figure used paper also originally part vignette:","code":"library(ggtree) #> ggtree v4.0.1 Learn more at https://yulab-smu.top/contribution-tree-data/ #>  #> Please cite: #>  #> Guangchuang Yu.  Data Integration, Manipulation and Visualization of #> Phylogenetic Trees (1st edition). Chapman and Hall/CRC. 2022, #> doi:10.1201/9781003279242, ISBN: 9781032233574 #>  #> Attaching package: 'ggtree' #> The following object is masked from 'package:tidyr': #>  #>     expand  # prepare annotation table for ggtree linking R phylo node ID (not tskit integer # ID!) of each node with its population name df <- as_tibble(nodes) %>% select(node = phylo_id, pop)  abs_comma <- function (x, ...) {   format(abs(x) / 1000, ..., scientific = FALSE, trim = TRUE) }  highlight_nodes <- as_tibble(nodes) %>% dplyr::filter(name == \"EUR_578\") %>% .$phylo_id  p_tree <- ggtree(tree, aes(color = pop, fill = pop)) %<+% df +   geom_tiplab(align = TRUE, geom = \"label\", offset = 2000,               color = \"white\", fontface = \"bold\", size = 2.7) +   geom_tiplab(align = TRUE, geom = NULL, linetype = \"dotted\", size = 0) +   geom_point2(aes(subset = (node %in% highlight_nodes)), color = \"black\", size = 2.7) +   geom_label2(aes(label = label, subset = !isTip),               color = \"black\", size = 2.7) +   theme_tree2() +   theme(legend.position = \"none\") +   xlab(\"time before present [thousand years ago]\") +   scale_x_continuous(limits = c(-80000, 31000), labels = abs_comma,                      breaks = -c(100, 80, 60, 40, 20, 0) * 1000) #> Warning in (function (mapping = NULL, data = NULL, ..., stat = \"identity\", : #> Ignoring unknown parameters: `label.size` #> Warning in geom_label2(aes(label = label, subset = !isTip), color = \"black\", : #> Ignoring unknown parameters: `label.size` p_tree <- revts(p_tree)  # nodes$label <- ifelse(is.na(nodes$name), nodes$node_id, nodes$name) nodes$label <- sapply(1:nrow(nodes), function(i) {   if (is.na(nodes[i, ]$name))     nodes[i, ]$node_id   else {     ind <- nodes[i, ]$name     paste(nodes[!is.na(nodes$name) & nodes$name == ind, ]$node_id, collapse = \"&\")   } })  p_map <- ggplot() +   geom_sf(data = map) +   geom_sf(data = edges, aes(color = parent_pop), size = 0.5) +   geom_sf_label(data = nodes[!nodes$sampled, ],                 aes(label = node_id, fill = pop), size = 3) +   geom_sf_label(data = nodes[nodes$sampled, ],                 aes(label = label, fill = pop), size = 3,                 fontface = \"bold\", color = \"white\") +   coord_sf(xlim = c(3177066.1, 7188656.9),            ylim = c(757021.7, 5202983.3), expand = 0) +   guides(fill = guide_legend(\"\", override.aes = aes(label = \"\"))) +   guides(color = \"none\") +   scale_colour_discrete(drop = FALSE) +   scale_fill_discrete(drop = FALSE) +   theme_bw() +   theme(legend.position = \"bottom\",         axis.title.x = element_blank(),         axis.title.y = element_blank())  chrom_names <- stats::setNames(   c(\"EUR_578 (node 6)\", \"EUR_578 (node 7)\"),   unique(ancestors$node_id) )  p_ancestors <- ggplot() +   geom_sf(data = map) +   geom_sf(data = ancestors, size = 0.5, alpha = 0.25) +   geom_sf(data = sf::st_set_geometry(ancestors, \"parent_location\"),           aes(shape = parent_pop, color = parent_pop)) +   geom_sf(data = filter(ts_nodes(ts), name == \"EUR_578\"), size = 3) +   coord_sf(expand = 0) +   labs(x = \"longitude\", y = \"latitude\") +   theme_bw() +   facet_grid(. ~ node_id, labeller = labeller(node_id = chrom_names)) +   theme(legend.position = \"none\")  p_legend <- ggdraw() + draw_grob(grid::grobTree(get_legend(p_map)))  p_ex4 <- plot_grid(   p_code,   plot_grid(p_tree + theme(legend.position = \"none\"),             p_map + theme(legend.position = \"none\"),             labels = c(\"B\", \"C\"), rel_widths = c(1, 0.9)),   p_ancestors,   p_legend,   labels = c(\"A\", \"\", \"D\", \"\"),   nrow = 4, rel_heights = c(0.5, 1, 1, 0.1) )  p_ex4"},{"path":"https://bodkan.net/slendr/articles/vignette-09-paper.html","id":"run-time-of-each-code-example-from-the-paper","dir":"Articles","previous_headings":"","what":"Run time of each code example from the paper","title":"Examples from the slendr paper","text":"following times measured 16’’ MacBook Pro Apple M1 Pro chip (2021 model), 32 GB RAM, running macOS Ventura Version 13.1. table , ex1, ex2, ex3, ex4 correspond runtimes code shown one four example figures slendr paper.","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-10-tracts.html","id":"demographic-model","dir":"Articles","previous_headings":"","what":"Demographic model","title":"Extracting true ancestry tracts","text":"Let’s imagine following demographic model Neanderthal introgression ancestors non-Africans (represented “EUR” “PAP” populations, approximating European Papuan people living today), followed Denisovan introgression ancestors Papuans:","code":"anc_all <- population(\"ancestor_all\", time = 700e3, N = 10000, remove = 640e3) afr <- population(\"AFR\", parent = anc_all, time = 650e3, N = 10000) anc_arch <- population(\"ancestor_archaics\", parent = anc_all, time = 650e3, N = 10000, remove = 390e3) nea <- population(\"NEA\", parent = anc_arch, time = 400e3, N = 2000, remove = 30e3) den <- population(\"DEN\", parent = anc_arch, time = 400e3, N = 2000, remove = 30e3) nonafr <- population(\"nonAFR\", parent = afr, time = 100e3, N = 3000, remove = 39e3) eur <- population(\"EUR\", parent = nonafr, time = 45e3, N = 5000) pap <- population(\"PAP\", parent = nonafr, time = 45e3, N = 5000)  gf <- list(   gene_flow(from = nea, to = nonafr, proportion = 0.03, start = 55000, end = 50000),   gene_flow(from = den, to = pap, proportion = 0.07, start = 35000, end = 30000) )  model <- compile_model(   populations = list(anc_all, afr, anc_arch, nea, den, nonafr, eur, pap),   gene_flow = gf,   generation_time = 30,   serialize = FALSE )  plot_model(   model, sizes = FALSE,   order = c(\"AFR\", \"EUR\", \"nonAFR\", \"PAP\", \"ancestor_all\", \"DEN\", \"ancestor_archaics\", \"NEA\") )"},{"path":"https://bodkan.net/slendr/articles/vignette-10-tracts.html","id":"tree-sequence-simulation","dir":"Articles","previous_headings":"","what":"Tree sequence simulation","title":"Extracting true ancestry tracts","text":"Let’s now simulate 50Mb tree sequence model, recording 50 diploid individuals EUR PAP populations:","code":"samples <- schedule_sampling(model, times = 0, list(eur, 50), list(pap, 50))  ts <- msprime(model, sequence_length = 100e6, recombination_rate = 1e-8, samples = samples, random_seed = 42)"},{"path":"https://bodkan.net/slendr/articles/vignette-10-tracts.html","id":"extracting-ancestry-tracts","dir":"Articles","previous_headings":"","what":"Extracting ancestry tracts","title":"Extracting true ancestry tracts","text":"order extract tracts Neanderthal Denisovan ancestry, can use slendr’s new function ts_tracts() serves simplified R-friendly interface Python method tspop.get_pop_ancestry(). important piece information used function -called “census time”, records time recording “ancestral population” identity node ancestral subsegment sample set. Please see excellent vignette tspop information inner workings algorithm. case, let’s extract ancestry tracts corresponding ancestral nodes present 55 thousand years ago – time corresponds moment start archaic introgression: table ancestry tracts looks like. expect, see column indicating name individual, left right coordinates tract individual, well population name source ancestry tract:","code":"nea_tracts <- ts_tracts(ts, census = 55000) #>  #> PopAncestry summary #> Number of ancestral populations:     3 #> Number of sample chromosomes:        200 #> Number of ancestors:             44052 #> Total length of genomes:         20000000000.000000 #> Ancestral coverage:          20000000000.000000 den_tracts <- ts_tracts(ts, census = 35000) #>  #> PopAncestry summary #> Number of ancestral populations:     3 #> Number of sample chromosomes:        200 #> Number of ancestors:             55373 #> Total length of genomes:         20000000000.000000 #> Ancestral coverage:          20000000000.000000  tracts <- bind_rows(nea_tracts, den_tracts) tracts #> # A tibble: 17,002 × 10 #>    name  haplotype  time pop   source_pop     left    right length source_pop_id #>    <chr>     <int> <dbl> <chr> <fct>         <dbl>    <dbl>  <dbl>         <dbl> #>  1 EUR_1         1     0 EUR   NEA          781887   852668  70781             3 #>  2 EUR_1         1     0 EUR   NEA         1451389  1463837  12448             3 #>  3 EUR_1         1     0 EUR   NEA         1596995  1601441   4446             3 #>  4 EUR_1         1     0 EUR   NEA         1629857  1689656  59799             3 #>  5 EUR_1         1     0 EUR   NEA         3203711  3339565 135854             3 #>  6 EUR_1         1     0 EUR   NEA         3850629  3947923  97294             3 #>  7 EUR_1         1     0 EUR   NEA         6190700  6205627  14927             3 #>  8 EUR_1         1     0 EUR   NEA        10394211 10426667  32456             3 #>  9 EUR_1         1     0 EUR   NEA        13044685 13180258 135573             3 #> 10 EUR_1         1     0 EUR   NEA        14858956 14912068  53112             3 #> # ℹ 16,992 more rows #> # ℹ 1 more variable: node_id <dbl>"},{"path":"https://bodkan.net/slendr/articles/vignette-10-tracts.html","id":"summaries-of-ancestral-proportions","dir":"Articles","previous_headings":"","what":"Summaries of ancestral proportions","title":"Extracting true ancestry tracts","text":"summarise ancestry proportions target EUR PAP populations, see EUR population carries ~3% Neanderthal ancestry also true PAP population. However, also see Papuans carry 7% Denisovan ancestry. consistent model, also expectation empirical data. Let’s visualize proportions individual level:","code":"summary <- tracts %>%   group_by(name, node_id, pop, source_pop) %>%   summarise(prop = sum(length) / 100e6) #> `summarise()` has grouped output by 'name', 'node_id', 'pop'. You can override #> using the `.groups` argument.  summary %>% group_by(pop, source_pop) %>% summarise(mean(prop)) %>% arrange(source_pop, pop) #> `summarise()` has grouped output by 'pop'. You can override using the `.groups` #> argument. #> # A tibble: 3 × 3 #> # Groups:   pop [2] #>   pop   source_pop `mean(prop)` #>   <chr> <fct>             <dbl> #> 1 EUR   NEA              0.0303 #> 2 PAP   NEA              0.0348 #> 3 PAP   DEN              0.0739 summary %>% ggplot(aes(source_pop, prop, color = source_pop, fill = source_pop)) +   geom_jitter() +   coord_cartesian(ylim = c(0, 0.2)) +   geom_hline(yintercept = c(0.03, 0.08), linetype = 2) +   ylab(\"ancestry proportion\") +   facet_wrap(~ pop) +   ggtitle(\"Ancestry proportions in each individual\",           \"(vertical lines represent 3% and 7% baseline expectations\")"},{"path":"https://bodkan.net/slendr/articles/vignette-10-tracts.html","id":"chromosome-painting-of-ancestry-tracts","dir":"Articles","previous_headings":"","what":"“Chromosome painting” of ancestry tracts","title":"Extracting true ancestry tracts","text":"tracts object contains coordinates every single ancestry segment simulated individuals, can “paint” chromosome two archaic human ancestries:  lining NEA & DEN ancestry tracts EUR PAP populations, can see common origin Neanderthal ancestry non-African populations manifests significant overlap NEA tracts populations.","code":"tracts %>% mutate(chrom = paste(name, \" (node\", node_id, \")\")) %>% ggplot(aes(x = left, xend = right, y = chrom, yend = chrom, color = source_pop)) +   geom_segment(linewidth = 3) +   theme_minimal() +   labs(x = \"position [bp]\", y = \"haplotype\") +   ggtitle(\"True ancestry tracts along each chromosome\") +   theme(axis.text.y = element_blank(), panel.grid = element_blank()) +   facet_grid(pop ~ ., scales = \"free_y\")"},{"path":"https://bodkan.net/slendr/articles/vignette-10-tracts.html","id":"average-tract-lengths","dir":"Articles","previous_headings":"","what":"Average tract lengths:","title":"Extracting true ancestry tracts","text":"Let’s compute simple summaries tract lengths simulated data, compare theoretical expectations. Theoretical expectations (Racimo Slatkin 2015, Box 1) Neanderthal tracts: Denisovan tracts: can see, simulations far theoretical expectations, giving us confidence simulations (ancestry tract extraction algorithm) working expected.","code":"tracts %>%   group_by(pop, source_pop) %>%   summarise(mean(length)) #> `summarise()` has grouped output by 'pop'. You can override using the `.groups` #> argument. #> # A tibble: 3 × 3 #> # Groups:   pop [2] #>   pop   source_pop `mean(length)` #>   <chr> <fct>               <dbl> #> 1 EUR   NEA                65765. #> 2 PAP   NEA                69204. #> 3 PAP   DEN               100317. m <- 0.03 t <- 52500 / 30 r <- 1e-8  mean_nea <- 1 / ((1 - m) * r * (t - 1)) mean_nea #> [1] 58943.84 m <- 0.07 t <- 37500 / 30 r <- 1e-8  mean_den <- 1 / ((1 - m) * r * (t - 1)) mean_den #> [1] 86090.38"},{"path":"https://bodkan.net/slendr/articles/vignette-10-tracts.html","id":"distribution-of-ancestry-tract-lengths","dir":"Articles","previous_headings":"","what":"Distribution of ancestry tract lengths","title":"Extracting true ancestry tracts","text":"Finally, let’s plot distributions lengths ancestry tracts. case archaic human introgression well studied ’s perhaps exciting look figures. said, less well studied species, might interesting use kinds simulations inference introgression times proportions via Approximate Bayesian Computation another method:","code":"expectation_df <- data.frame(   pop = c(\"EUR\", \"PAP\", \"PAP\"),   source_pop = c(\"NEA\", \"NEA\", \"DEN\"),   length = c(mean_nea, mean_nea, mean_den) ) p_densities <- tracts %>% ggplot(aes(length, color = source_pop)) +   geom_density() +   geom_vline(data = expectation_df, aes(xintercept = length, color = source_pop),              linetype = 2) +   facet_wrap(~ pop) +   ggtitle(\"Distribution of tract lengths per different ancestries\")  cowplot::plot_grid(p_densities, p_densities + scale_x_log10(), nrow = 2)"},{"path":"https://bodkan.net/slendr/articles/vignette-10-tracts.html","id":"pure-msprime-tree-sequence","dir":"Articles","previous_headings":"","what":"Pure msprime tree sequence","title":"Extracting true ancestry tracts","text":"Finally, sanity check, let’s use pure msprime simulation example official tspop documentation test ts_tracts() behaves expected even standard msprime tree-sequence object. First, let’s run simulation code exactly : Let’s save msprime tree sequence disk can load R (.e., approximating might want want use ts_tracts() without running slendr simulation first): Now let’s move R , load tree sequence slendr extract ancestry tracts using ts_tracts(): setting squashed = FALSE, get full, un-squashed ancestry segments, appropriate ancestral node ID: comparing two tables pandas data frames tspop documentation, can see obtained results.","code":"import msprime  pop_size = 500 sequence_length = 1e7 seed = 98765 rho = 3e-8  # Make the Demography object. demography = msprime.Demography() demography.add_population(name=\"RED\", initial_size=pop_size) #> Population(initial_size=500, growth_rate=0, name='RED', description='', extra_metadata={}, default_sampling_time=None, initially_active=None, id=0) demography.add_population(name=\"BLUE\", initial_size=pop_size) #> Population(initial_size=500, growth_rate=0, name='BLUE', description='', extra_metadata={}, default_sampling_time=None, initially_active=None, id=1) demography.add_population(name=\"ADMIX\", initial_size=pop_size) #> Population(initial_size=500, growth_rate=0, name='ADMIX', description='', extra_metadata={}, default_sampling_time=None, initially_active=None, id=2) demography.add_population(name=\"ANC\", initial_size=pop_size) #> Population(initial_size=500, growth_rate=0, name='ANC', description='', extra_metadata={}, default_sampling_time=None, initially_active=None, id=3) demography.add_admixture(     time=100, derived=\"ADMIX\", ancestral=[\"RED\", \"BLUE\"], proportions=[0.5, 0.5] ) #> Admixture(time=100, derived='ADMIX', ancestral=['RED', 'BLUE'], proportions=[0.5, 0.5]) demography.add_census(time=100.01) # Census is here! #> CensusEvent(time=100.01) demography.add_population_split(     time=1000, derived=[\"RED\", \"BLUE\"], ancestral=\"ANC\" ) #> PopulationSplit(time=1000, derived=['RED', 'BLUE'], ancestral='ANC')  # Simulate. ts = msprime.sim_ancestry(     samples={\"RED\": 0, \"BLUE\": 0, \"ADMIX\" : 2},     demography=demography,     random_seed=seed,     sequence_length=sequence_length,     recombination_rate=rho ) import tempfile path = tempfile.NamedTemporaryFile(suffix=\".trees\").name  ts.dump(path) sim_ts <- ts_read(reticulate::py$path)  squashed_tracts <- ts_tracts(sim_ts, census = 100.01, squashed = TRUE) #>  #> PopAncestry summary #> Number of ancestral populations:     2 #> Number of sample chromosomes:        4 #> Number of ancestors:             118 #> Total length of genomes:         40000000.000000 #> Ancestral coverage:          40000000.000000  head(squashed_tracts) #> # A tibble: 6 × 4 #>   sample    left   right population #>    <dbl>   <dbl>   <dbl>      <dbl> #> 1      0       0  419848          0 #> 2      0  419848  483009          1 #> 3      0  483009 1475765          0 #> 4      0 1475765 2427904          1 #> 5      0 2427904 3635390          0 #> 6      0 3635390 4606954          1 tail(squashed_tracts) #> # A tibble: 6 × 4 #>   sample    left    right population #>    <dbl>   <dbl>    <dbl>      <dbl> #> 1      3 7134130  7362300          1 #> 2      3 7362300  7369409          0 #> 3      3 7369409  7596783          1 #> 4      3 7596783  8289015          0 #> 5      3 8289015  8918727          1 #> 6      3 8918727 10000000          0 full_tracts <- ts_tracts(sim_ts, census = 100.01, squashed = FALSE) #>  #> PopAncestry summary #> Number of ancestral populations:     2 #> Number of sample chromosomes:        4 #> Number of ancestors:             118 #> Total length of genomes:         40000000.000000 #> Ancestral coverage:          40000000.000000  head(full_tracts) #> # A tibble: 6 × 5 #>   sample   left   right ancestor population #>    <int>  <dbl>   <dbl>    <int>      <int> #> 1      0      0   33027       74          0 #> 2      0  33027  155453       33          0 #> 3      0 155453  290542       46          0 #> 4      0 290542  419848       18          0 #> 5      0 419848  483009       83          1 #> 6      0 483009 1475765       28          0 tail(full_tracts) #> # A tibble: 6 × 5 #>   sample    left    right ancestor population #>    <int>   <dbl>    <dbl>    <int>      <int> #> 1      3 8477625  8672850       94          1 #> 2      3 8672850  8849756       95          1 #> 3      3 8849756  8918727      131          1 #> 4      3 8918727  9165035       44          0 #> 5      3 9165035  9176562       47          0 #> 6      3 9176562 10000000       58          0"},{"path":"https://bodkan.net/slendr/articles/vignette-11-extensions.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Extending models with custom SLiM code","text":"slendr designed specifically purpose making easy possible program population genetic simulations spatio-temporal demographic histories using SLiM. primary goal means simulate arbitrarily complex spatial scenarios simulate data used development new spatial inference population genetic methods (benchmarking current methods). functionality briefly described vignette #1 detail vignette #6. spatial simulation features implemented, turned trivial support also “traditional”, non-spatial demographic models, described vignette #4 vignette #5 – tree-like models population divergences, gene-flow events, popularion resize events, like can see evolutionary biology textbook. non-spatial models can often implemented (executed) efficient coalescent setting, added possibility run compiled slendr model SLiM back-end script implemented msprime, hidden behind slendr function msprime(). Throughout time, slendr models purely neutral, without much planning extend simulations toward non-neutral scenarios. However, easy specification non-spatial demographic models simulation slendr/SLiM engine, many users asking possibility simulate non-neutral scenarios , generally, customization simplified genome architecture assumed slendr default (single chromosome uniform recombination purely neutral mutations). vignette describes can done slendr. even SLiM can things ? Fair question! , SLiM can obviously simulate nearly kind conceivable evolutionary model. One motivation supporting non-neutral customized genomic architecture mutation models slendr users find easier program complex “base” demographic models R (models complex history population divergences, gene-flow events, resizes), let slendr take care demographic history . provide custom SLiM code non-neutral evolution.**","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-11-extensions.html","id":"disclaimers-and-caveats","dir":"Articles","previous_headings":"","what":"Disclaimers and caveats","title":"Extending models with custom SLiM code","text":"want use slendr/SLiM extension functionality described vignette, aware following restrictions guidelines: extension functionality primarily design support complex selection models using customized SLiM snippets still using slendr handling basic demographic modeling scaffold (population splits, resizes, gene flows, etc.). handling demographic events remains unchanged even slim() models, coalescent msprime() engine slendr (implements coalescent, neutral counterpart slendr models) changed means customize . assumed SLiM script bundled slendr stays unmodified. extension SLiM code customization snippets added top – customizing mutation types, genomic element types, recombination maps, custom fitness callbacks, etc. Functionality involving demographic events (splits, gene-flow, etc.) stay place . User-provided custom code allowed change functionality operates. Related point – slendr models assume (always assume) Wright-Fisher (WF) dynamics. Although perhaps necessarily problem simulating non-spatial selection models (.e. slendr models don’t include map), adding selection spatial models SLiM WF setting unlikely lead meaningful results. need non-WF models, use pure SLiM. slendr useful . built-SLiM engine slendr provides several utility Eidos functions make easy extend engine custom callbacks, give possibility refer slendr-specific model information. See list section .","code":""},{"path":"https://bodkan.net/slendr/articles/vignette-11-extensions.html","id":"slendr-slim-api","dir":"Articles","previous_headings":"","what":"slendr / SLiM “API”","title":"Extending models with custom SLiM code","text":"describe following slendr / SLiM “API” functions constants can use customize default SLiM script comes bundled slendr: population() tick() model_time() save_state() reset_state() write_log() SIMULATION_START SIMULATION_END SEQUENCE_LENGTH PATH Let’s first load required R libraries dive :","code":"library(slendr) init_env()  library(dplyr) library(ggplot2) library(readr)  seed <- 42 set.seed(seed)"},{"path":"https://bodkan.net/slendr/articles/vignette-11-extensions.html","id":"referring-to-populations-population-eidos-function","dir":"Articles","previous_headings":"slendr / SLiM “API”","what":"Referring to populations: population() Eidos function","title":"Extending models with custom SLiM code","text":"recap, program slendr model, can refer populations using symbolic names “AFR” “EUR” slendr R script following way: Similarly, simulation finished need analyze tree-sequence produced slendr model, can refer populations (individuals sampled populations) using symbolic names like : Along lines, ’re customizing slendr/SLiM simulation, can get Subpopulation SLiM object corresponding symbolic name slendr population (used R side things) using Eidos function population() provided built-SLiM script slendr. instance, let’s assume compiled toy model human demography vignette #4 ran SLiMgui using slim(..., method = \"gui\"). can open Eidos console GUI type following: way, name populations symbolic names “AFR” “OOA”, can refer population SLiM extension code using symbolic names (.e., don’t know whether population called p0 p2 SLiM side things). symbolic names R SLiM parts slendr. Additionally, population() Eidos function provides helpful error checking. instance, try get SLiM Subpopulation object corresponding slendr population exist point doesn’t yet exist running SLiM simulation particular time, get informative error: make typo try access population doesn’t exist slendr model , get another informative error message: function useful practice, though? purpose vignette show extend slendr non-neutral scenarios, , example, select random chromosome given population using population() function like (maybe add beneficial mutation). use bit code elaborate complete examples . , point population() Eidos function provided slendr SLiM codebase make easier refer components slendr model defined SLiM extension code.","code":"afr <- population(\"AFR\", time = 100000, N = 20000) eur <- population(\"EUR\", time = 60000, N = 2000, parent = afr)  # <... compile model and simulate a tree sequence `ts` ...> # compute heterozygosity in the individual \"EUR\" ts_diversity(ts, \"EUR_1\")  # compute genetic divergence between selected Africans and Europeans afr_samples <- c(\"AFR_1\", \"AFR_2\", \"AFR_3\") eur_samples <- c(\"EUR_1\", \"EUR_2\", \"EUR_3\") ts_divergence(ts, list(afr = afr_samples, eur = eur_samples)) > // get a SLiM object corresponding to the \"AFR\" population > population(\"AFR\") Subpopulation<p0> > > // get the number of genomes in the population > length(population(\"AFR\").haplosomes) 6000 > > // get both \"AFR\" and \"OOA\" subpopulation objects > population(c(\"AFR\", \"OOA\")) Subpopulation<p0> Subpopulation<p1> > population(\"YAM\") The following populations not present in tick 81 (slendr model time 97600): YAM > population(\"asdf\") Not all provided population identifiers are present in the model. Check your code to make sure that all of these are defined: asdf target_genome = sample(population(\"AFR\").haplosomes, 1);  target_genome.addNewMutation(m0, selectionCoeff = 0.05, position = 1000000);"},{"path":"https://bodkan.net/slendr/articles/vignette-11-extensions.html","id":"referring-to-times-tick-eidos-function","dir":"Articles","previous_headings":"slendr / SLiM “API”","what":"Referring to times: tick() Eidos function","title":"Extending models with custom SLiM code","text":"Another useful feature slendr ability use arbitrary time units model definition. instance, creating “EUR” population snippet , wrote : numbers 100000 60000 split time meaningful , compile run slendr model like (run SLiMgui able demonstrate various Eidos functions) can interpret 90000 60000 “years present”, can quite convenient ’re building models using radiocarbon-dated fossil-dated ages, rather using traditional units generations (forward time SLiM, backwards time _msprime). However, time want refer “absolute time units” SLiM code, bit numerical conversion translate times “years present” SLiM’s “generations going forward”. Depending complexity model, can get tricky particularly burn-times, etc. tick() Eidos function makes possible use slendr model “natural time units” even SLiM side, without convert years present generations forward time, similarly population() function Eidos allows us refer slendr population symbolic names consistent way R SLiM . function takes time slendr time units – years present, generations backwards time, whatever used slendr R script – translates SLiM’s “ticks”. instance, example model modern human history, get tick number corresponding time 40 thousand years ago calling: Similarly consistency check performed population() Eidos function, tick() also makes sure time given lies within time window expected running simulation. instance, AFR-EUR toy model starts 90 thousand years ago, try get tick number corresponding million years ago, get : Indeed, tick-based time boundaries model : population(), can also perform slendr-time--tick conversion vectorized manner: Naturally, model use special time units (instance, times encoded generations, even forward time), tick() function becomes effectively identity function: Indeed, pop Eidos console SLiMgui model, can verify : model starts population “pop” created time point 1 ’s programmed run 1000 generations, meaning last generation simulation 1001. Still, tick() function can useful even slendr models use time units SLiM (generations forward time) provides useful boundary checking. instance, happens try get tick number model (runs generation 1 generation 1 + 1000): case, time point 0 invalid “predate” first generation toy model (1) time point 1000000 invalid “postdate” last generation model (1001). Additionally, tick() function automatically takes care offsetting tick count burn-period specified simulation: ’ll see thanks possibility using arbitrary integer expressions SLiM 4.2, can use tick() Eidos function easy straightforward scheduling custom callbacks.","code":"afr <- population(\"AFR\", time = 90000, N = 20000) eur <- population(\"EUR\", time = 60000, N = 2000, parent = afr) model <- compile_model(populations = list(afr, eur), generation_time = 30)  slim(model, sequence_length = 100000, recombination_rate = 1e-8, method = \"gui\") > tick(40000) # what does time 40000 in a slendr model correspond to in SLiM ticks? 1668 > tick(1e6) Some of the times fall outside of the range of the slendr model:   - oldest possible event: 90000   - youngest possible event: 0  The offending times were: 1000000 > // the very first time point of the simulation > tick(90e3) 1 > // the very last time point of the simulation > tick(0) 3001 > tick(c(90000, 0)) 1 3001 pop <- population(\"pop\", time = 1, N = 1000) simple_model <- compile_model(pop, generation_time = 1, simulation_length = 1000)  slim(simple_model, sequence_length = 1000, recombination_rate = 0, method = \"gui\") > // no conversion needed for forward-time models expressed in units of generations > tick(1) 1 > tick(1001) 1001 > tick(c(0, 1e6)) Some of the times fall outside of the range of the slendr model:   - oldest possible event: 1   - youngest possible event: 1001  The offending times were: 0, 1000000 pop <- population(\"pop\", time = 1, N = 1000) simple_model <- compile_model(pop, generation_time = 1, simulation_length = 1000)  slim(simple_model, sequence_length = 1000, recombination_rate = 0, burnin = 100, method = \"gui\") > tick(1) // model time at 1 generation is shifted by 100 burnin 101 > tick(1001) // same for the final time point of 1001 generations 1101"},{"path":"https://bodkan.net/slendr/articles/vignette-11-extensions.html","id":"referring-to-model-times-model_time-eidos-function","dir":"Articles","previous_headings":"slendr / SLiM “API”","what":"Referring to model times: model_time() Eidos function","title":"Extending models with custom SLiM code","text":"function inverse tick() function. instance, want write information associated time stamp using time context slendr model (like “years present” demonstrated ) tick numbers. example, gives us model time (years ago) corresponding first tick EUR-AFR model : gives us model time corresponding last tick simulation (.e. present-day “0 years present”):","code":"> model_time(1) 90000 > model_time(3001) 0"},{"path":"https://bodkan.net/slendr/articles/vignette-11-extensions.html","id":"logging-write_log-eidos-function","dir":"Articles","previous_headings":"slendr / SLiM “API”","what":"Logging: write_log() Eidos function","title":"Extending models with custom SLiM code","text":"write_log() tiny helper function provided slendr’s SLiM back-end script serves print given string SLiM log output together appropriate tick number time. produces result following kind:","code":"> write_log(\"hello from the current event\") tick 18 (model time 89490):   - hello from the current event"},{"path":"https://bodkan.net/slendr/articles/vignette-11-extensions.html","id":"saving-and-re-starting-simulation-state-save_state-and-reset_state","dir":"Articles","previous_headings":"slendr / SLiM “API”","what":"Saving and re-starting simulation state: save_state() and reset_state()","title":"Extending models with custom SLiM code","text":"Whenever ’re dealing simulations , say, trajectories beneficial alleles, usually take care situations allele interest gets lost simulation finishes running. cases, usually need reset simulation state just mutation added try . Section 9.2 venerable SLiM manual (“Making sweeps conditional fixation”) great example solve base SLiM. Although quite easy use approach slendr/SLiM extension snippets described , ’s one issue approach: SLiM’s sim.outputFull() sim.readFromPopulationFile() methods preserve important internal slendr tags assigned using <Subpopulation>.{set,get}Value() methods. require poking slendr’s SLiM codebase, confusing user. circumvent problem, slendr’s SLiM back-end script provides following functions: save_state(): saves full state SLiM simulation (just sim.outputFull() ), also saving slendr-specific values; reset_state(): restores full SLiM simulation state (including slendr specific tags values), chooses new random seed. latter performed restarting simulation using save_state() - reset_state() tandem practically always done order change outcome simulation. demonstrate two functions might used practice, let’s say wanted build (default purely neutral!) model African Eurasian history vignette discussed , say want add beneficial mutation “EUR” population time 15 ky ago. utilize bits Eidos code introduced far define following slendr extension snippet (now let’s ignore question actually add slendr simulation focus SLiM extension code isolation): Note simplicity don’t define mutation types, simply re-use m0 mutation type used slendr default. unlikely useful complex simulations look general solution defines custom mutation type purpose. point example show use save_state() reset_state() practice.","code":"function (void) add_mutation(s pop_name, f selection_coef) {   // sample the first target carrier chromosome of the new mutation...   target = sample(population(pop_name).haplosomes, 1);   // ... and add the mutation to it   mutation = target.addNewDrawnMutation(m0, position = 1);    defineGlobal(\"BACKGROUND\", target.mutations);   defineGlobal(\"FOCAL\", mutation);    write_log(\"adding beneficial mutation to population \" + pop_name); }  tick(15000) late() {   // save simulation state in case we need to restart if the mutation is lost   save_state();    add_mutation(\"pop\", s); }  tick(15000):SIMULATION_END late() {   segregating = sim.countOfMutationsOfType(m0) > 0;   fixed = sum(sim.substitutions.mutationType == m0) == 1;    // the mutation is not segregating and is not fixed either -- we must restart   if (!segregating & !fixed) {     write_log(\"mutation lost -- restarting\");      reset_state();      add_mutation(\"EUR\");   } }"},{"path":"https://bodkan.net/slendr/articles/vignette-11-extensions.html","id":"global-constants","dir":"Articles","previous_headings":"slendr / SLiM “API”","what":"Global constants","title":"Extending models with custom SLiM code","text":"inspecting built-SLiM simulation script slendr, find contains number global constants. considered internal users shouldn’t rely code. However, one useful constant can see used snippet SEQUENCE_LENGTH – total amount sequence simulated (.e., number passed slim(<model>, sequence_length = <SEQUENCE_LENGTH>, ...) R code). course, specifying initialize() {...} callback genomic elements give flexibility might want skip specifying sequence_length = entirely, also show . Another useful pair slendr constants SIMULATION_START SIMULATION_END, specify time points (ticks!) given slendr model start end. Even relevant writing customized SLiM extension scripts slendr constant PATH, contains path directory files SLiM simulation results (tree-sequence file) saved. can specified setting parameter path calls slim() function like slim(..., path = <directory>). means want save custom files (various tables allele frequencies, etc., .e. just tree-sequence file), don’t organize plumbing slendr R script SLiM extension code – can specify path = R use inside SLiM code PATH constant.","code":""},{"path":[]},{"path":"https://bodkan.net/slendr/articles/vignette-11-extensions.html","id":"putting-it-all-together-running-a-customized-slendr-simulation","dir":"Articles","previous_headings":"Practical examples","what":"Putting it all together: running a customized slendr simulation","title":"Extending models with custom SLiM code","text":"examples show can refer slendr population symbolic name SLiM side using population() Eidos function provided slendr built-SLiM script, can convert slendr-specific time units SLiM’s internal ticks using functions tick() model_time(). ’ve also learned save reset SLiM state slendr simulation using functions save_state() reset_state() write logging information using function write_log(). now demonstrate defining snippet SLiM code used customize complete slendr simulation. course, example ’ve chosen extremely trivial – can, principle, use feature available SLiM (long ’s compatible Wright-Fisher models, slendr assumes basis models). use customization practice? One way edit built-slendr SLiM script manually add SLiM code, brittle reproducible. ’s much better way ’s directly supported slendr’s R interface. Let’s say defined following model modern human demographic history slendr. exactly example one show vignette #4:  Let’s also assume following “SLiM snippet file” (line gets path example SLiM extension packaged slendr): can include extension snippet standard slendr engine SLiM script providing path compile_model(): can check extension snippet really appended built-SLiM engine script running slim() function setting method = \"gui\" (look towards end script!): far ’re primarily interested saving frequency trajectory beneficial allele <tempdir()>/trajectory.tsv. Checking file produced customized slim() simulation shows frequency trajectories indeed saved correctly: Speaking : one thing ’s little annoying extension snippet used example parameters hard-coded (selection coefficient, target population, even path frequency trajectory file). wanted run slendr script different values selection coefficient, examining behavior model depending population beneficial allele arise, ’d create multiple copies extension script. can better using slendr’s support substitution “templating”.","code":"library(slendr) init_env() #> The interface to all required Python modules has been activated. # African ancestral population afr <- population(\"AFR\", time = 90000, N = 3000)  # first migrants out of Africa ooa <- population(\"OOA\", parent = afr, time = 60000, N = 500, remove = 23000) %>%   resize(N = 2000, time = 40000, how = \"step\")  # Eastern hunter-gatherers ehg <- population(\"EHG\", parent = ooa, time = 28000, N = 1000, remove = 6000)  # European population eur <- population(\"EUR\", parent = ehg, time = 25000, N = 5000)  # Anatolian farmers ana <- population(\"ANA\", time = 28000, N = 3000, parent = ooa, remove = 4000)  # Yamnaya steppe population yam <- population(\"YAM\", time = 8000, N = 500, parent = ehg, remove = 2500)  # define gene-flow events gf <- list(   gene_flow(from = ana, to = yam, proportion = 0.4, start = 7900, end = 7800),   gene_flow(from = ana, to = eur, proportion = 0.5, start = 6000, end = 5000),   gene_flow(from = yam, to = eur, proportion = 0.65, start = 4000, end = 3500) ) extension_path <- system.file(\"extdata\", \"extension_trajectory.txt\", package = \"slendr\") // Because we want to simulate non-neutral evolution, we have to provide a // custom initialization callback -- slendr will use it to replace its default // neutral genomic architecture (i.e. the initialize() {...} callback it uses // by default for neutral simulations). Note that we can refer to slendr's // constants SEQUENCE_LENGTH and RECOMBINATION_RATE, which will carry values // passed through from R via slendr's slim() R function. initialize() {     // define some parameters of the model     defineConstant(\"s\", 0.1);     defineConstant(\"onset_time\", 15000);     defineConstant(\"target_pop\", \"EUR\");      initializeMutationType(\"m1\", 0.5, \"f\", s);      initializeGenomicElementType(\"g1\", m1, 1.0);     initializeGenomicElement(g1, 0, SEQUENCE_LENGTH - 1);      initializeMutationRate(0);     initializeRecombinationRate(RECOMBINATION_RATE);      defineConstant(\"traj_file\", paste0(PATH, \"trajectory.tsv\")); }  function (void) add_mutation(void) {     // sample one target carrier of the new mutation...     target = sample(population(target_pop).haplosomes, 1);     // ... and add the mutation in the middle of it     mut = target.addNewDrawnMutation(m1, position = asInteger(SEQUENCE_LENGTH / 2));      // save the mutation for later reference     defineGlobal(\"MUTATION\", mut);      write_log(\"adding beneficial mutation to population \" + target_pop);      // write the header of the output file     writeFile(traj_file, \"time\\tfrequency\"); }  tick(onset_time) late() {     // save simulation state in case we need to restart if the mutation is lost     // (save_state() is a built-in function provided by slendr for customization)     save_state();      add_mutation(); }  tick(onset_time):SIMULATION_END late() {     // the mutation is not segregating and is not fixed either -- we must restart     if (!MUTATION.isSegregating & !MUTATION.isFixed) {         write_log(\"mutation lost -- restarting\");          // reload the simulation state from just before we added the beneficial         // mutation above (reset_state() is another built-in slendr function)         reset_state();          add_mutation();     }      // compute the frequency of the mutation of interest     frequency = population(\"EUR\").haplosomes.mutationFrequenciesInHaplosomes();      // save the current frequency to the output file     writeFile(traj_file,               model_time(community.tick) + \"\\t\" +               frequency, append = T); } model <- compile_model(   populations = list(afr, ooa, ehg, eur, ana, yam),   gene_flow = gf, generation_time = 30,   extension = extension_path  # <--- include the SLiM extension snippet ) slim(model, sequence_length = 1e6, recombination_rate = 0, method = \"gui\") time    frequency 15000   0.0001 14970   0.0005 14940   0.0007 14910   0.0008 14880   0.0005 14850   0.0007 14820   0.0009 14790   0.001 14760   0.0013"},{"path":"https://bodkan.net/slendr/articles/vignette-11-extensions.html","id":"putting-it-all-together-parametrizing-a-customized-slendr-simulation","dir":"Articles","previous_headings":"Practical examples","what":"Putting it all together: parametrizing a customized slendr simulation","title":"Extending models with custom SLiM code","text":"easy parametrization customized slendr / SLiM models, slendr provides function substitute_values(). Simply speaking, rather hardcode values parameters extension SLiM snippet files, can indicate parameter value substituted file using simple syntax {{parameter_name}}. Take look new, flexible version snippet used look {{...}} template placeholders. version expanded study trajectory focal selected allele depending population originated time (rather hardcoding target population onset time directly customization script ). Substitute values parameters customization SLiM extension script: Missing parameter gives error immediately: plug parametrized script compile_model() just : can leverage flexibility solution run another version model, time adding mutation different population. fact, let’s check happens beneficial allele appears EHG, ANA, YAM populations. Note uses extension snippet, just substitutes different values placeholder parameters: can visualize different trajectories like . different allele frequency trajectories reflect complex demographic history European population, particularly dilution frequency due influx ancestry populations Europeans, shown demographic tree . simulations allele originated directly EUR another population EUR can trace ancestry ancient gene flow, trajectory allele leading fixation bit delayed, depending particular gene flow happened. Still, ’s strong selection reached fixation even prior gene flow gene flow happened strong proportion, reaches fixation much faster.","code":"extension_path <- system.file(\"extdata\", \"extension_trajectory_params.txt\", package = \"slendr\") // Define model constants (to be substituted) all in one place // (each {{placeholder}} will be replaced by a value passed from R). // Note that string constant template patterns are surrounded by \"quotes\"! initialize() {     defineConstant(\"s\", {{s}});     defineConstant(\"onset_time\", {{onset_time}});     defineConstant(\"target_pop\", \"{{target_pop}}\");     defineConstant(\"origin_pop\", \"{{origin_pop}}\");      // compose a trajectory file based on given parameters     defineConstant(\"traj_file\", PATH + \"/\" +                                 \"traj_\" + target_pop + \"_\" + origin_pop + \".tsv\"); } // Because we want to simulate non-neutral evolution, we have to provide a // custom initialization callback -- slendr will use it to replace its default // neutral genomic architecture (i.e. the initialize() {...} callback it uses // by default for neutral simulations). Note that we can refer to slendr's // constants SEQUENCE_LENGTH and RECOMBINATION_RATE, which will carry values // passed through from R via slendr's slim() R function. initialize() {     initializeMutationType(\"m1\", 0.5, \"f\", s);      initializeGenomicElementType(\"g1\", m1, 1.0);     initializeGenomicElement(g1, 0, SEQUENCE_LENGTH - 1);      initializeMutationRate(0);     initializeRecombinationRate(RECOMBINATION_RATE); }  function (void) add_mutation(void) {     // sample one target carrier of the new mutation...     target = sample(population(origin_pop).haplosomes, 1);     // ... and add the mutation in the middle of it     mut = target.addNewDrawnMutation(m1, position = asInteger(SEQUENCE_LENGTH / 2));      // save the mutation for later reference     defineGlobal(\"MUTATION\", mut);      write_log(\"adding beneficial mutation to population \" + target_pop);      writeFile(traj_file, \"time\\tfreq_origin\\tfreq_target\"); }  tick(onset_time) late() {     // save simulation state in case we need to restart if the mutation is lost     save_state();      add_mutation(); }  tick(onset_time):SIMULATION_END late() {     // the mutation is not segregating and is not fixed either -- we must restart     if (!MUTATION.isSegregating & !MUTATION.isFixed) {         write_log(\"mutation lost -- restarting\");          reset_state();          add_mutation();     }      // compute the frequency of the mutation of interest and save it (if the     // mutation is missing at this time, save its frequency as NA)     freq_origin = \"NA\";     freq_target = \"NA\";     if (population(origin_pop, check = T))       freq_origin = population(origin_pop).haplosomes.mutationFrequenciesInHaplosomes();     if (population(target_pop, check = T))       freq_target = population(target_pop).haplosomes.mutationFrequenciesInHaplosomes();      writeFile(traj_file,               model_time(community.tick) + \"\\t\" +               freq_origin + \"\\t\" +               freq_target, append = T); } extension <- substitute_values(   extension_path,   s = 0.1, onset_time = 15000,   origin_pop = \"EUR\", target_pop = \"EUR\" ) extension <- substitute_values(   extension_path,   onset_time = 15000,   origin_pop = \"EUR\", target_pop = \"EUR\" )  # Error: The extension script contains the following unsubstituted patterns: {{s}} model <- compile_model(   populations = list(afr, ooa, ehg, eur, ana, yam),   gene_flow = gf, generation_time = 30,   extension = extension ) slim(model, sequence_length = 1e6, recombination_rate = 0, path = tempdir(), random_seed = 42) run_model <- function(origin_pop, onset_time) {   extension <- substitute_values(     extension_path,     s = 0.1, onset_time = onset_time,     origin_pop = origin_pop, target_pop = \"EUR\"   )    model <- compile_model(     populations = list(afr, ooa, ehg, eur, ana, yam),     gene_flow = gf, generation_time = 30,     extension = extension   )    slim(model, sequence_length = 1e6, recombination_rate = 0,        path = tempdir(), random_seed = 42) }  run_model(origin_pop = \"EUR\", onset_time = 15000) run_model(origin_pop = \"ANA\", onset_time = 15000) run_model(origin_pop = \"EHG\", onset_time = 15000) run_model(origin_pop = \"YAM\", onset_time = 8000) load_traj <- function(origin_pop) {   df <- read.table(paste0(tempdir(), \"/traj_EUR_\", origin_pop, \".tsv\"), header = TRUE)   df$origin <- origin_pop   df$target <- \"EUR\"   df }  traj <- rbind(load_traj(\"EUR\"), load_traj(\"ANA\"), load_traj(\"EHG\"), load_traj(\"YAM\"))  library(ggplot2)  ggplot(traj) +   geom_line(aes(time, freq_target, linetype = \"EUR\"), color = \"black\") +   geom_line(aes(time, freq_origin, color = origin), linetype = \"dashed\") +   xlim(15000, 0) +   labs(title = \"Allele frequency in EUR given the origin in another population\",        x = \"years before present\", y = \"allele frequency\",        color = \"frequency\\nin original\\npopulation\",        linetype = \"frequency\\nin target\\npopulation\") +   scale_linetype_manual(values = c(\"solid\", \"dashed\")) +   facet_wrap(~ origin) #> Warning: Removed 419 rows containing missing values or values outside the scale range #> (`geom_line()`)."},{"path":"https://bodkan.net/slendr/articles/vignette-11-extensions.html","id":"programming-slendrslim-extension-snippets-directly-in-r-scripts","dir":"Articles","previous_headings":"Practical examples","what":"Programming slendr/SLiM extension snippets directly in R scripts","title":"Extending models with custom SLiM code","text":"Thanks multiline string support implemented R 4.2, can specify SLiM extension code directly R string inside R script, instead include external file like previous examples. Including SLiM code directly way makes little easier iterate development can put everything single reproducible R script. defined SLiM snippet way, rest code work exactly way example just (thing changed code providing SLiM extension string directly instead providing path file):","code":"# extension \"template\" provided as a single string (this contains the same code # as the script used just above, except specified directly in R) extension_template <- r\"( // Because we want to simulate non-neutral evolution, we have to provide a // custom initialization callback -- slendr will use it to replace its default // neutral genomic architecture (i.e. the initialize() {...} callback it uses // by default for neutral simulations). Note that we can refer to slendr's // constants SEQUENCE_LENGTH and RECOMBINATION_RATE, which will carry values // passed through from R via slendr's slim() R function. initialize() {     initializeMutationType(\"m1\", 0.5, \"f\", 0.0);      initializeGenomicElementType(\"g1\", m1, 1.0);     initializeGenomicElement(g1, 0, SEQUENCE_LENGTH - 1);      initializeMutationRate(0);     initializeRecombinationRate(RECOMBINATION_RATE); }  // Define model constants (to be substituted) all in one place // (each {{placeholder}} will be replaced by a value passed from R). // Note that string constant template patterns are surrounded by \"quotes\"! initialize() {     defineConstant(\"s\", {{s}});     defineConstant(\"onset_time\", {{onset_time}});     defineConstant(\"target_pop\", \"{{target_pop}}\");     defineConstant(\"origin_pop\", \"{{origin_pop}}\");      // compose the path to a trajectory file based on given parameters     defineConstant(\"traj_file\",                    PATH + \"/\" + \"traj_\" + target_pop + \"_\" + origin_pop + \".tsv\"); }  function (void) add_mutation(void) {     // sample one target carrier of the new mutation...     target = sample(population(origin_pop).haplosomes, 1);     // ... and add the mutation in the middle of it     mut = target.addNewMutation(m1, s, position = asInteger(SEQUENCE_LENGTH / 2));      // save the mutation for later reference     defineGlobal(\"MUTATION\", mut);      write_log(\"adding beneficial mutation to population \" + origin_pop);      writeFile(traj_file, \"tick\\ttime\\tfreq_origin\\tfreq_target\"); }  tick(onset_time) late() {     // save simulation state in case we need to restart if the mutation is lost     save_state();      add_mutation(); }  tick(onset_time):SIMULATION_END late() {     // the mutation is not segregating and is not fixed either -- we must restart     if (!MUTATION.isSegregating & !MUTATION.isFixed) {         write_log(\"mutation lost -- restarting\");          reset_state();          add_mutation();     }      // compute the frequency of the mutation of interest and save it (if the     // mutation is missing at this time, save its frequency as NA)     freq_origin = \"NA\";     freq_target = \"NA\";     if (population(origin_pop, check = T))       freq_origin = population(origin_pop).haplosomes.mutationFrequenciesInHaplosomes();     if (population(target_pop, check = T))       freq_target = population(target_pop).haplosomes.mutationFrequenciesInHaplosomes();      writeFile(traj_file,               community.tick + \"\\t\" +               model_time(community.tick) + \"\\t\" +               freq_origin + \"\\t\" +               freq_target, append = T); } )\" run_model <- function(origin_pop, onset_time) {   extension <- substitute_values(     extension_template, # <--- template SLiM code string directly (not as a file!)     s = 0.1, onset_time = onset_time,     origin_pop = origin_pop, target_pop = \"EUR\"   )    model <- compile_model(     populations = list(afr, ooa, ehg, eur, ana, yam),     gene_flow = gf, generation_time = 30,     extension = extension   )    slim(model, sequence_length = 1e6, recombination_rate = 0,        path = tempdir(), random_seed = 42) }  run_model(\"EUR\", onset_time = 15000)  head(load_traj(\"EUR\")) #>   tick  time freq_origin freq_target origin target #> 1 2501 15000       1e-04       1e-04    EUR    EUR #> 2 2502 14970       3e-04       3e-04    EUR    EUR #> 3 2503 14940       4e-04       4e-04    EUR    EUR #> 4 2504 14910       5e-04       5e-04    EUR    EUR #> 5 2505 14880       4e-04       4e-04    EUR    EUR #> 6 2506 14850       4e-04       4e-04    EUR    EUR"},{"path":"https://bodkan.net/slendr/articles/vignette-11-extensions.html","id":"customizing-genomic-architecture-selective-sweep-simulations","dir":"Articles","previous_headings":"Practical examples > Programming slendr/SLiM extension snippets directly in R scripts","what":"Customizing genomic architecture (selective sweep simulations)","title":"Extending models with custom SLiM code","text":"Customization slendr / SLiM models can extend also genomic architecture . altering initialization procedure providing custom initialize() {...} callback SLiM extension code entirely overrides setting (default just one) genomic element type recombination rate, users might want set entirely . means ’s possible avoid SEQUENCE_LENGTH RECOMBINATION_RATE arguments used slendr back-end engine provided via slim(..., sequence_length = ..., recombination_rate = ..., ...) arguments. Let’s take following slendr model Neanderthal introgression:  Now put together SLiM extension code set non-neutral slendr simulation: put everything together compiling slendr model (now swaps slendr’s default neutrality non-neutral genomic architecture, including deleterious mutations): also record 10 Neanderthals 100 Africans Europeans tree sequence: Using compiled model, can simulate tree sequence using slim() function like standard slendr workflow. However, note able skip sequence_length = recombination_rate = arguments! non-neutral extension snippet already customizes though, ’s reason us instruct slim() front way: ’s suggested Neanderthals significantly lower NeN_e compared anatomically modern humans (AMH), might decreased efficacy negative selection deleterious variants compared AMH. Consequently, following Neanderthal admixture AMH, introgressed Neanderthal DNA AMH negative selection, particularly regions genome stronger selective constraints. implies compute proportion Neanderthal ancestry along sample European genomes, see clear dip amount surviving Neanderthal DNA function distance locus selection. customized SLiM snippet saved allele frequency Neanderthal marker Europeans, can just load data directly visualize :  hypothesis clearly stands data! shouldn’t forget default data structure slendr tree sequence. gives us much flexibility terms statistics can compute, effectively can computed don’t need mutations genotype files calculate . instance, alternative direct computation allele frequencies SLiM run (saved frequencies.tsv), use simulated tree sequence quickly calculate genetic divergence Europeans Neanderthal windows along simulated genome.  Indeed, clearly observe lower introgression levels (indicated increased European-Neanderthal divergence) around loci selection increased surviving introgression far loci, purifying selection removed Neanderthal introgressed DNA regions selective constraint.","code":"# create the ancestor of everyone and a chimpanzee outgroup # (we set both N = 1 to reduce the computational time for this model) chimp <- population(\"CH\", time = 6.5e6, N = 1000)  # two populations of anatomically modern humans: Africans and Europeans afr <- population(\"AFR\", parent = chimp, time = 6e6, N = 10000) eur <- population(\"EUR\", parent = afr, time = 70e3, N = 5000)  # Neanderthal population splitting at 600 ky ago from modern humans # (becomes extinct by 40 ky ago) nea <- population(\"NEA\", parent = afr, time = 600e3, N = 1000, remove = 40e3)  # 5% Neanderthal introgression into Europeans between 55-50 ky ago gf <- gene_flow(from = nea, to = eur, proportion = 0.05, start = 55000, end = 45000)  model <- compile_model(   populations = list(chimp, nea, afr, eur), gene_flow = gf,   generation_time = 30 ) extension <- r\"( initialize() {   // model parameters to be substitute_values()'d from R below   defineConstant(\"gene_length\", {{gene_length}});   defineConstant(\"n_genes\", {{n_genes}});   defineConstant(\"n_markers\", {{n_markers}});   defineConstant(\"introgression_time\", {{introgression_time}});   defineConstant(\"freq_file\", PATH + \"/{{freq_file}}\");    // total length of the genome to be simulated   defineConstant(\"total_length\", n_genes * gene_length);    // positions of neutral Neanderthal markers along the genome   defineConstant(\"neutral_pos\", seq(0, total_length - 1, by = gene_length / n_markers));   // positions of deleterious mutations in the center of each gene   defineConstant(\"selected_pos\", seq(gene_length / 2, total_length - 1, by = gene_length)); }  // Because we want to simulate non-neutral evolution, we have to provide a // custom initialization callback -- slendr will use it to replace its default // neutral genomic architecture (i.e. the initialize() {...} callback it uses // by default for neutral simulations). initialize() {   initializeMutationType(\"m0\", 0.5, \"f\", 0.0); // neutral Neanderthal marker mutation type   initializeMutationType(\"m1\", 0.5, \"f\", {{s}}); // deleterious Neanderthal mutation type   initializeGenomicElementType(\"g1\", m0, 1.0); // genomic type of 'genes'    genes = c(); // gene start-end coordinates   breakpoints = c(); // recombination breakpoints   rates = c(); // recombination rates    // compute coordinates of genes, as well as the recombination map breakpoints   // between each gene   start = 0;   for (i in seqLen(n_genes)) {     // end of the next gene     end = start + gene_length - 1;     genes = c(genes, start, end);      // uniform recombination within a gene, followed by a 0.5 recombination breakpoint     rates = c(rates, RECOMBINATION_RATE, 0.5);     breakpoints = c(breakpoints, end, end + 1);      // start of the following genes     start = end + 1;   }    // odd elements --> starts of genes   gene_starts = integerMod(seqAlong(genes), 2) == 0;   // even elements --> ends of genes   gene_ends = integerMod(seqAlong(genes), 2) == 1;    // set up all the genes at once   initializeGenomicElement(g1, genes[gene_starts], genes[gene_ends]);    // set up the recombination map   initializeRecombinationRate(rates, breakpoints);    // no mutation rate (we will add neutral variation after the SLiM run)   initializeMutationRate(0); }  // Add Neanderthal-specific mutations one tick prior to the introgression tick(introgression_time) - 1 late() {   // get all Neanderthal chromosomes just prior to the introgression   target = population(\"NEA\").haplosomes;    write_log(\"adding neutral Neanderthal markers\");    mutations = target.addNewDrawnMutation(m0, position = asInteger(neutral_pos));   defineConstant(\"MARKERS\", target.mutations);    write_log(\"adding deleterious Neanderthal mutation\");    target.addNewDrawnMutation(m1, position = asInteger(selected_pos)); }  // At the end, write Neanderthal ancestry proportions along the genome to a file // (in our R analysis code we will compare the results of this with the // equivalent computation using a tree sequence) SIMULATION_END late() {   df = DataFrame(     \"gene\", asInteger(MARKERS.position / gene_length),     \"pos\", MARKERS.position,     \"freq\", sim.mutationFrequencies(population(\"EUR\"), MARKERS)   );   writeFile(freq_file, df.serialize(format = \"tsv\")); } )\" %>%   substitute_values(     introgression_time = 55000, s = -0.003,     gene_length = 5e6, n_genes = 200, n_markers = 100,     freq_file = \"frequencies.tsv\"   ) model <- compile_model(   populations = list(nea, eur), gene_flow = gf,   generation_time = 30,   extension = extension ) nea_samples <- schedule_sampling(model, times = 50000, list(nea, 1)) modern_samples <- schedule_sampling(model, times = 0, list(eur, 100))  samples <- rbind(nea_samples, modern_samples) slim(model, recombination_rate = 1e-8, samples = samples, path = \"~/Code/__archive/introgression_data/\") n_genes <- 200 gene_length <- 5e6 window_length <- 100e3 freqs <- read_tsv(\"~/Code/__archive/introgression_data/frequencies.tsv\") #> Rows: 40000000 Columns: 3 #> ── Column specification ──────────────────────────────────────────────────────── #> Delimiter: \"\\t\" #> dbl (3): gene, pos, freq #>  #> ℹ Use `spec()` to retrieve the full column specification for this data. #> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. freqs %>% mutate(pos = pos %% 5e6) %>% group_by(pos) %>% summarise(freq = 100 * mean(freq)) %>% ggplot() +   geom_line(aes(pos, freq)) +   geom_vline(xintercept = gene_length / 2, linetype = 2) +   labs(x = \"coordinate along a gene\", y = \"Neanderthal ancestry proportion [%]\",        title = \"Proportion of Neanderthal ancestry in Europeans along 5Mb independent genes\",        subtitle = \"(dashed line indicates introgressed deleterious Neanderthal allele)\") +   coord_cartesian(ylim = c(0, 3)) # load a tree sequence and extract the names of recorded individuals ts <- ts_read(file = \"~/Code/__archive/introgression_data/slim.trees\", model) samples <- ts_names(ts, split = \"pop\")  samples #> $EUR #>   [1] \"EUR_1\"   \"EUR_2\"   \"EUR_3\"   \"EUR_4\"   \"EUR_5\"   \"EUR_6\"   \"EUR_7\"   #>   [8] \"EUR_8\"   \"EUR_9\"   \"EUR_10\"  \"EUR_11\"  \"EUR_12\"  \"EUR_13\"  \"EUR_14\"  #>  [15] \"EUR_15\"  \"EUR_16\"  \"EUR_17\"  \"EUR_18\"  \"EUR_19\"  \"EUR_20\"  \"EUR_21\"  #>  [22] \"EUR_22\"  \"EUR_23\"  \"EUR_24\"  \"EUR_25\"  \"EUR_26\"  \"EUR_27\"  \"EUR_28\"  #>  [29] \"EUR_29\"  \"EUR_30\"  \"EUR_31\"  \"EUR_32\"  \"EUR_33\"  \"EUR_34\"  \"EUR_35\"  #>  [36] \"EUR_36\"  \"EUR_37\"  \"EUR_38\"  \"EUR_39\"  \"EUR_40\"  \"EUR_41\"  \"EUR_42\"  #>  [43] \"EUR_43\"  \"EUR_44\"  \"EUR_45\"  \"EUR_46\"  \"EUR_47\"  \"EUR_48\"  \"EUR_49\"  #>  [50] \"EUR_50\"  \"EUR_51\"  \"EUR_52\"  \"EUR_53\"  \"EUR_54\"  \"EUR_55\"  \"EUR_56\"  #>  [57] \"EUR_57\"  \"EUR_58\"  \"EUR_59\"  \"EUR_60\"  \"EUR_61\"  \"EUR_62\"  \"EUR_63\"  #>  [64] \"EUR_64\"  \"EUR_65\"  \"EUR_66\"  \"EUR_67\"  \"EUR_68\"  \"EUR_69\"  \"EUR_70\"  #>  [71] \"EUR_71\"  \"EUR_72\"  \"EUR_73\"  \"EUR_74\"  \"EUR_75\"  \"EUR_76\"  \"EUR_77\"  #>  [78] \"EUR_78\"  \"EUR_79\"  \"EUR_80\"  \"EUR_81\"  \"EUR_82\"  \"EUR_83\"  \"EUR_84\"  #>  [85] \"EUR_85\"  \"EUR_86\"  \"EUR_87\"  \"EUR_88\"  \"EUR_89\"  \"EUR_90\"  \"EUR_91\"  #>  [92] \"EUR_92\"  \"EUR_93\"  \"EUR_94\"  \"EUR_95\"  \"EUR_96\"  \"EUR_97\"  \"EUR_98\"  #>  [99] \"EUR_99\"  \"EUR_100\" #>  #> $NEA #> [1] \"NEA_1\" # compute coordinates of sliding windows along the genome windows <- seq(from = 0, to = n_genes * gene_length - 1, by = window_length)  head(windows) #> [1] 0e+00 1e+05 2e+05 3e+05 4e+05 5e+05 tail(windows) #> [1] 999400000 999500000 999600000 999700000 999800000 999900000 # compute divergence from the tree sequence in each window separately divergence <- ts_divergence(ts, samples, windows = windows, mode = \"branch\")$divergence[[1]] # compute average divergence at each position in a gene, and a 95% C.I. div_df <- tibble(   pop = \"eur\",   pos = windows %% gene_length,   div = divergence ) %>%   group_by(pop, pos) %>%   summarise(     mean = mean(div), n = n(), std = sd(div),     ci_low = mean - 2 * std / sqrt(n),     ci_up = mean + 2 * std / sqrt(n)   ) #> `summarise()` has grouped output by 'pop'. You can override using the `.groups` #> argument. ggplot(div_df) +   geom_ribbon(aes(pos, ymin = ci_low, ymax = ci_up), fill = \"grey70\") +   geom_line(aes(pos, mean)) +   geom_vline(aes(xintercept = gene_length / 2), linetype = 2) +   labs(x = \"coordinate along a gene\", y = \"divergence to Neanderthal\",        title = \"Divergence of Europeans to a Neanderthal genome along 5Mb independent genes\",        subtitle = \"(dashed line indicates introgressed deleterious Neanderthal allele)\")"},{"path":"https://bodkan.net/slendr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Martin Petr. Author, maintainer.","code":""},{"path":"https://bodkan.net/slendr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Petr M (2026). slendr: Simulation Framework Spatiotemporal Population Genetics. R package version 1.3.0.9000, https://github.com/bodkan/slendr.","code":"@Manual{,   title = {slendr: A Simulation Framework for Spatiotemporal Population Genetics},   author = {Martin Petr},   year = {2026},   note = {R package version 1.3.0.9000},   url = {https://github.com/bodkan/slendr}, }"},{"path":[]},{"path":"https://bodkan.net/slendr/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"A Simulation Framework for Spatiotemporal Population Genetics","text":"slendr toolbox running population genomic simulations entirely R. original motivation developing provide framework simulating spatially-explicit genomic data real geographic landscapes, however, grown much since : slendr can now simulate data traditional, non-spatial demographic models using msprime simulation engine, even supports selection scenarios via user-defined SLiM estension snippets. addition defining models simulation data , slendr also provides set functions computing population genetic statistics, utilizing tskit module underlying computation. page briefly summarizes slendr’s important features. detailed description slendr architecture extensive set practical code examples can found paper PCI journal website.","code":""},{"path":"https://bodkan.net/slendr/index.html","id":"citing-slendr","dir":"","previous_headings":"","what":"Citing slendr","title":"A Simulation Framework for Spatiotemporal Population Genetics","text":"slendr paper now published Peer Community Journal! use slendr work, please cite : Petr, Martin; Haller, Benjamin C.; Ralph, Peter L.; Racimo, Fernando. slendr: framework spatio-temporal population genomic simulations geographic landscapes. Peer Community Journal, Volume 3 (2023), article . e121. doi: 10.24072/pcjournal.354. Citations help justify development fixing bugs! Thank !","code":""},{"path":"https://bodkan.net/slendr/index.html","id":"main-features","dir":"","previous_headings":"","what":"Main features","title":"A Simulation Framework for Spatiotemporal Population Genetics","text":"brief summary slendr’s important features. R package allows : Program demographic models, including population splits, population size changes, gene-flow events using extremely simple declarative language entirely R (see vignette example model-definition interface). Even complex models can written little code require bare minimum R programming knowledge (thing user needs know call R function R data frame look like). Execute slendr models using efficient, tailor-made SLiM msprime simulation scripts bundled R package. simulation engines save outputs form efficient tree-sequence data structure. SLiM msprime programming needed! Read manipulate tree-sequence data compute population genetic statistics via slendr’s built-R interface tree-sequence library tskit. slendr provides library functions computing population genetic statistics using easy--use R interface, without convert files formats (VCF, EIGENSTRAT) analysis different software. Although originally assumed neutrality simulated models, slendr now provides simple extension mechanism customization SLiM-based models using user-defined SLiM code. Simulations selection models arbitrary complexity now entirely possible. Schedule sampling events specify many individuals’ genomes, populations, times (optionally, locations) recorded given simulation engine (SLiM msprime) simulated tree-sequence object. Encode complex models population movements landscape (see brief example model , extended explanation tutorial). Simulate dynamic spatial demographic models using SLiM’s continuous-space simulation capabilities directly R (, SLiM programming required). results simulations saved tree sequences can processed analysed using standard R geospatial data analysis libraries. slendr performs conversion tree sequence tables appropriate spatial R data type automatically. Specify within-population individual dispersal dynamics R interface leveraging SLiM’s individual interaction parameters implemented SLiM back-end script. Utilizing flexibility R wealth libraries statistics, geospatial analysis graphics, combining power population genetic simulation frameworks SLiM msprime, slendr R package makes possible write entire workflows without need leave R environment.","code":""},{"path":"https://bodkan.net/slendr/index.html","id":"testing-the-r-package-in-an-online-rstudio-session","dir":"","previous_headings":"","what":"Testing the R package in an online RStudio session","title":"A Simulation Framework for Spatiotemporal Population Genetics","text":"can open RStudio session test examples vignettes directly web browser clicking button (installation needed!):  case RStudio instance appears starting slowly, please patient (Binder freely available service limited computational resources provided community). Binder crashes, try reloading web page, restart cloud session. get browser-based RStudio session, can navigate vignettes/ directory test examples !","code":""},{"path":"https://bodkan.net/slendr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"A Simulation Framework for Spatiotemporal Population Genetics","text":"slendr now available CRAN means can install simply entering install.packages(\"slendr\") R console. like test latest features software (perhaps need bug fixes), can install devtools::install_github(\"bodkan/slendr\") (note requires R package devtools).","code":""},{"path":"https://bodkan.net/slendr/index.html","id":"traditional-non-spatial-example","dir":"","previous_headings":"","what":"Traditional, non-spatial example","title":"A Simulation Framework for Spatiotemporal Population Genetics","text":"Although primary motivation developing slendr provide easy interface encoding geographically-explicit population genetic models, turned amazing tool program traditional Wright-Fisher population genetic models. instance, ’s quick demonstration little R code needed generate 100 Mb sequence simple model Neanderthal Denisovan introgression. want read aspect slendr, please take look vignette.  Note final outcome simulation tree sequence (produced slendr’s simulation engine written msprime), makes trivial compute nearly conceivable population genetic statistic directly R (demonstrated ).","code":"library(slendr) init_env()  anc_all <- population(\"ancestor_all\", time = 700e3, N = 10000, remove = 640e3) afr <- population(\"AFR\", parent = anc_all, time = 650e3, N = 10000) anc_arch <- population(\"ancestor_archaics\", parent = anc_all, time = 650e3, N = 10000, remove = 390e3) nea <- population(\"NEA\", parent = anc_arch, time = 400e3, N = 2000, remove = 30e3) den <- population(\"DEN\", parent = anc_arch, time = 400e3, N = 2000, remove = 30e3) nonafr <- population(\"nonAFR\", parent = afr, time = 100e3, N = 3000, remove = 39e3) eur <- population(\"EUR\", parent = nonafr, time = 45e3, N = 5000) pap <- population(\"PAP\", parent = nonafr, time = 45e3, N = 5000)  gf <- list(   gene_flow(from = nea, to = nonafr, rate = 0.02, start = 55000, end = 50000),   gene_flow(from = den, to = pap, rate = 0.05, start = 35000, end = 30000) )  model <- compile_model(   populations = list(anc_all, afr, anc_arch, nea, den, nonafr, eur, pap),   gene_flow = gf,   generation_time = 30 )  plot_model(   model, proportions = TRUE,   order = c(\"AFR\", \"EUR\", \"nonAFR\", \"PAP\", \"ancestor_all\",             \"DEN\", \"ancestor_archaics\", \"NEA\") ) ts <- msprime(model, sequence_length = 100e6, recombination_rate = 1e-8)"},{"path":"https://bodkan.net/slendr/index.html","id":"spatial-simulation-example","dir":"","previous_headings":"","what":"Spatial simulation example","title":"A Simulation Framework for Spatiotemporal Population Genetics","text":"brief demonstration kind spatial model slendr originally designed simulate data . note example shows specify simulate model R. doesn’t show compute population genetic statistics simulated tree sequences (important feature demonstrated tutorial).","code":""},{"path":"https://bodkan.net/slendr/index.html","id":"id_1-setup-the-spatial-context","dir":"","previous_headings":"Spatial simulation example","what":"1. Setup the spatial context","title":"A Simulation Framework for Spatiotemporal Population Genetics","text":"Imagine wanted simulate spatio-temporal genomic data toy model history modern humans West Eurasia Africa migration. First, define spatial context simulation. represent “world” occupied populations model. can visualize defined world map using function plot_map provided package.  Although example use real Earth landscape, map can completely abstract (either blank user-defined landscape features continents, islands, corridors barriers).","code":"library(slendr)  # this sets up internal Python environment and needs to be ran only once! # (do not put this in your R scripts, run this command in the R console # after you (re-)install slendr) setup_env()  # activate the internal Python environment needed for simulation and # tree-sequence processing init_env()  map <- world(   xrange = c(-13, 70), # min-max longitude   yrange = c(18, 65),  # min-max latitude   crs = \"EPSG:3035\"    # coordinate reference system (CRS) for West Eurasia ) plot_map(map)"},{"path":"https://bodkan.net/slendr/index.html","id":"id_2-define-broader-geographic-regions","dir":"","previous_headings":"Spatial simulation example","what":"2. Define broader geographic regions","title":"A Simulation Framework for Spatiotemporal Population Genetics","text":"order make definitions population ranges () easier, can define smaller regions map using function region. Note coordinates slendr specified geographic coordinate system (.e., degrees longitude latitude), internally represented projected CRS (case, EPSG 3035 specified ). makes easier us define spatial features simply reading coordinates regular map internal projected CRS makes simulations accurate (distances shapes distorted can use CRS tailored region world working ). projected CRS takes care projection part world ’re interested three-dimensional Earth surface two-dimensional map. , can use generic plot_map function visualize objects, making sure specified correctly:","code":"africa <- region(   \"Africa\", map,   polygon = list(c(-18, 20), c(38, 20), c(30, 33),                  c(20, 33), c(10, 38), c(-6, 35)) ) europe <- region(   \"Europe\", map,   polygon = list(     c(-8, 35), c(-5, 36), c(10, 38), c(20, 35), c(25, 35),     c(33, 45), c(20, 58), c(-5, 60), c(-15, 50)   ) ) anatolia <- region(   \"Anatolia\", map,   polygon = list(c(28, 35), c(40, 35), c(42, 40),                  c(30, 43), c(27, 40), c(25, 38)) ) plot_map(africa, europe, anatolia)"},{"path":"https://bodkan.net/slendr/index.html","id":"id_3-define-demographic-history-and-population-boundaries","dir":"","previous_headings":"Spatial simulation example","what":"3. Define demographic history and population boundaries","title":"A Simulation Framework for Spatiotemporal Population Genetics","text":"important function slendr package population(), used define names, split times, sizes spatial ranges populations. , specify times years present, distances kilometers. makes sense models, times can also given forward direction. also note functions move() expand_range() designed take slendr population object schedule spatial dynamics appropriate times model simulation (happen later step). Note order make example executable reasonable time extremely old laptop, decreased sizes populations unrealistic levels. speed SLiM simulation later step. can use function plot_map get “compressed” overview spatio-temporal range dynamics encoded model far (prior simulation ).","code":"afr <- population( # African ancestral population   \"AFR\", time = 52000, N = 3000, map = map, polygon = africa )  ooa <- population( # population of the first migrants out of Africa   \"OOA\", parent = afr, time = 51000, N = 500, remove = 25000,   center = c(33, 30), radius = 400e3 ) %>%   move(     trajectory = list(c(40, 30), c(50, 30), c(60, 40)),     start = 50000, end = 40000, snapshots = 20   )  ehg <- population( # Eastern hunter-gatherers   \"EHG\", parent = ooa, time = 28000, N = 1000, remove = 6000,   polygon = list(     c(26, 55), c(38, 53), c(48, 53), c(60, 53),     c(60, 60), c(48, 63), c(38, 63), c(26, 60)) )  eur <- population( # European population   name = \"EUR\", parent = ehg, time = 25000, N = 2000,   polygon = europe )  ana <- population( # Anatolian farmers   name = \"ANA\", time = 28000, N = 3000, parent = ooa, remove = 4000,   center = c(34, 38), radius = 500e3, polygon = anatolia ) %>%   expand_range( # expand the range by 2.500 km     by = 2500e3, start = 10000, end = 7000,     polygon = join(europe, anatolia), snapshots = 20   )  yam <- population( # Yamnaya steppe population   name = \"YAM\", time = 7000, N = 500, parent = ehg, remove = 2500,   polygon = list(c(26, 50), c(38, 49), c(48, 50),                  c(48, 56), c(38, 59), c(26, 56)) ) %>%   move(trajectory = list(c(15, 50)), start = 5000, end = 3000, snapshots = 10) plot_map(afr, ooa, ehg, eur, ana, yam)"},{"path":"https://bodkan.net/slendr/index.html","id":"id_4-define-gene-flow-events","dir":"","previous_headings":"Spatial simulation example","what":"4. Define gene-flow events","title":"A Simulation Framework for Spatiotemporal Population Genetics","text":"default, populations slendr mix even overlapping. order schedule gene-flow event two populations, can use function gene_flow. want specify multiple events , can collect events simple R list:","code":"gf <- list(   gene_flow(from = ana, to = yam, rate = 0.5, start = 6500, end = 6400, overlap = FALSE),   gene_flow(from = ana, to = eur, rate = 0.5, start = 8000, end = 6000),   gene_flow(from = yam, to = eur, rate = 0.75, start = 4000, end = 3000) )"},{"path":"https://bodkan.net/slendr/index.html","id":"id_5-compile-the-model-to-a-set-of-configuration-files","dir":"","previous_headings":"Spatial simulation example","what":"5. Compile the model to a set of configuration files","title":"A Simulation Framework for Spatiotemporal Population Genetics","text":"run simulation, compile individual model components (population objects gene-flow events) single R object, specifying additional model parameters. Additionally, performs internal consistency checks, making sure model parameters (split times, gene flow times, etc.) make sense (potentially quite computationally costly) simulation even run. Compiled model kept R object can passed different functions. example, simulate data slim() engine (also run simulation coalescent engine via msprime() function).","code":"model <- compile_model(   populations = list(afr, ooa, ehg, eur, ana, yam), # populations defined above   gene_flow = gf,   generation_time = 30,   resolution = 10e3,                   # resolution in meters per pixel   competition = 130e3, mating = 100e3, # spatial interaction parameters   dispersal = 70e3,                    # how far can offspring end up from their parents )"},{"path":"https://bodkan.net/slendr/index.html","id":"id_6-visualize-the-model","dir":"","previous_headings":"Spatial simulation example","what":"6. Visualize the model","title":"A Simulation Framework for Spatiotemporal Population Genetics","text":"package provides R shiny-based browser app explore_model() checking model dynamics interactively visually. complex models, much better static spatial plots one showed step 2 : function two modes: Plotting (“playing”) spatial map dynamics:  Displaying demographic history graph (splits gene-flow events) embedded specified model:","code":"explore_model(model)"},{"path":"https://bodkan.net/slendr/index.html","id":"id_7-run-the-model-in-slim","dir":"","previous_headings":"Spatial simulation example","what":"7. Run the model in SLiM","title":"A Simulation Framework for Spatiotemporal Population Genetics","text":"Finally, can execute compiled model SLiM. run simulation batch mode, also run SLiMgui setting method = \"gui\". allow us inspect spatial simulation happens real time. slim function generates complete SLiM script tailored run spatial model defined . saves , user, tremendous amount time, don’t write new SLiM code every time design new demographic model. output simulation run slendr model always tree sequence, loaded object ts_slim. specified , slendr’s SLiM backend simulate 10 Mb sequence individual, produce tree sequence output simulation run can analysed many built-population genetic functions. default, individuals living end simulation recorded samples tree sequence. specific set samples (ancient modern) needed, can defined accordingly using dedicated function. Note although defined spatial model, just easily simulated standard, non-spatial data running model slendr’s msprime() back end without need make changes: point, either compute population genetic statistics interest perhaps analyse spatial features genealogies simulated model.","code":"ts_slim <- slim(model, sequence_length = 10e6, recombination_rate = 1e-8,                 method = \"batch\", random_seed = 314159) ts_msprime <- msprime(model, sequence_length = 10e6, recombination_rate = 1e-8)"},{"path":"https://bodkan.net/slendr/index.html","id":"further-information","dir":"","previous_headings":"","what":"Further information","title":"A Simulation Framework for Spatiotemporal Population Genetics","text":"example provides brief incomplete overview full functionality slendr package. much slendr demonstrated . instance: can tweak parameters influencing dispersal dynamics (“clumpy” populations , far can offspring migrate parents, etc.) define change time. instance, can see animation , African population forms single “blob” really isn’t spread across entire population range. Tweaking dispersal parameters show vignette helps avoid . can use slendr program non-spatial models, means conceivable traditional, random-mating demographic model can simulated lines R code. can learn vignette (detail vignette). SLiM simulations can often quite slow compared coalescent counterparts, also provide functionality allowing simulate slendr models (without change!) using built-msprime back end script. See vignette tutorial works. can extend traditional, non-spatial SLiM-based slendr models customized SLiM code simulate various selection scenarios supported SLiM still leveraging slendr’s easy--use interface programming demographic models. can build complex spatial models still abstract (assuming real geographic location), including traditional simulations demes lattice structure. complete example shown vignette. slendr & SLiM save data tree-sequence file format, thanks R package reticulate interfacing Python code, full power tskit pyslim manipulating tree-sequence data right fingertips, within convenient environment R. extended example can found vignette. spatially explicit population models, slendr package automatically converts simulated output data format makes possible analyse many available R packages geospatial data analysis. brief description functionality can found vignette. can find complete reproducible code behind examples paper dedicated R vignette .","code":""},{"path":"https://bodkan.net/slendr/reference/animate_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Animate the simulated population dynamics — animate_model","title":"Animate the simulated population dynamics — animate_model","text":"Animate simulated population dynamics","code":""},{"path":"https://bodkan.net/slendr/reference/animate_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Animate the simulated population dynamics — animate_model","text":"","code":"animate_model(model, file, steps, gif = NULL, width = 800, height = 560)"},{"path":"https://bodkan.net/slendr/reference/animate_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Animate the simulated population dynamics — animate_model","text":"model Compiled slendr_model model object file Path table saved individual locations steps many frames animation ? gif Path output GIF file (animation object returned default) width, height Dimensions animation pixels","code":""},{"path":"https://bodkan.net/slendr/reference/animate_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Animate the simulated population dynamics — animate_model","text":"gif = NULL, return gganimate animation object. Otherwise GIF file saved value returned.","code":""},{"path":"https://bodkan.net/slendr/reference/area.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the area covered by the given slendr object — area","title":"Calculate the area covered by the given slendr object — area","text":"Calculate area covered given slendr object","code":""},{"path":"https://bodkan.net/slendr/reference/area.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the area covered by the given slendr object — area","text":"","code":"area(x)"},{"path":"https://bodkan.net/slendr/reference/area.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the area covered by the given slendr object — area","text":"x Object class slendr","code":""},{"path":"https://bodkan.net/slendr/reference/area.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the area covered by the given slendr object — area","text":"Area covered input object. slendr_pop given, table population range area time point returned. slendr_region slendr_world object specified, total area covered object's spatial boundary returned.","code":""},{"path":"https://bodkan.net/slendr/reference/area.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the area covered by the given slendr object — area","text":"","code":"region_a <- region(\"A\", center = c(20, 50), radius = 20) region_b <- region(\"B\", polygon = list(c(50, 40), c(70, 40), c(70, 60), c(50, 60))) plot_map(region_a, region_b)   # note that area won't be *exactly* equal to pi*r^2: #   https://stackoverflow.com/a/65280376 area(region_a) #> [1] 1256.063  area(region_b) #> [1] 400"},{"path":"https://bodkan.net/slendr/reference/as.phylo.slendr_phylo.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert an annotated slendr_phylo object to a phylo object — as.phylo.slendr_phylo","title":"Convert an annotated slendr_phylo object to a phylo object — as.phylo.slendr_phylo","text":"function servers workaround around ggtree error: Error UseMethod(\".phylo\") :     applicable method '.phylo' applied object class     \"c('phylo', 'slendr_phylo')\"","code":""},{"path":"https://bodkan.net/slendr/reference/as.phylo.slendr_phylo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert an annotated slendr_phylo object to a phylo object — as.phylo.slendr_phylo","text":"","code":"# S3 method for class 'slendr_phylo' as.phylo(x, ...)"},{"path":"https://bodkan.net/slendr/reference/as.phylo.slendr_phylo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert an annotated slendr_phylo object to a phylo object — as.phylo.slendr_phylo","text":"x Tree object class slendr_phylo ... Additional (unused) arguments .phylo S3 method","code":""},{"path":"https://bodkan.net/slendr/reference/as.phylo.slendr_phylo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert an annotated slendr_phylo object to a phylo object — as.phylo.slendr_phylo","text":"Standard phylogenetic tree object implemented R package ape","code":""},{"path":"https://bodkan.net/slendr/reference/check_dependencies.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that the required dependencies are available for slendr to work — check_dependencies","title":"Check that the required dependencies are available for slendr to work — check_dependencies","text":"Check required dependencies available slendr work","code":""},{"path":"https://bodkan.net/slendr/reference/check_dependencies.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that the required dependencies are available for slendr to work — check_dependencies","text":"","code":"check_dependencies(python = FALSE, slim = FALSE, quit = FALSE)"},{"path":"https://bodkan.net/slendr/reference/check_dependencies.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that the required dependencies are available for slendr to work — check_dependencies","text":"python slendr Python environment required? slim SLiM required? quit R interpreter quit required slendr dependencies missing? option (turned default, set FALSE) used mainly avoiding running slendr man page examples machines lack dependencies. set TRUE, logical value returned.","code":""},{"path":"https://bodkan.net/slendr/reference/check_dependencies.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check that the required dependencies are available for slendr to work — check_dependencies","text":"quit = TRUE, values returned, quit = FALSE, scalar logical value returned indicating whether dependencies present.","code":""},{"path":"https://bodkan.net/slendr/reference/check_env.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that the active Python environment is setup for slendr — check_env","title":"Check that the active Python environment is setup for slendr — check_env","text":"function inspects Python environment activated reticulate package prints versions slendr Python dependencies console.","code":""},{"path":"https://bodkan.net/slendr/reference/check_env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that the active Python environment is setup for slendr — check_env","text":"","code":"check_env(verbose = TRUE)"},{"path":"https://bodkan.net/slendr/reference/check_env.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that the active Python environment is setup for slendr — check_env","text":"verbose log message printed? FALSE, logical value returned (invisibly).","code":""},{"path":"https://bodkan.net/slendr/reference/check_env.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check that the active Python environment is setup for slendr — check_env","text":"Either TRUE (slendr Python environment present) FALSE (slendr Python environment present).","code":""},{"path":"https://bodkan.net/slendr/reference/check_env.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check that the active Python environment is setup for slendr — check_env","text":"","code":"init_env() #> The interface to all required Python modules has been activated. check_env() #> Summary of the currently active Python environment: #>  #> Python binary: /Users/mp/Library/r-miniconda-arm64/envs/Python-3.12_msprime-1.3.4_tskit-0.6.4_pyslim-1.1.0_tspop-0.0.2/bin/python  #> Python version: 3.12.12 | packaged by conda-forge | (main, Oct 22 2025, 23:34:53) [Clang 19.1.7 ]  #>  #> slendr requirements: #>  - tskit: version 0.6.4 ✓  #>  - msprime: version 1.3.4 ✓  #>  - pyslim: version 1.1.0 ✓  #>  - tspop: present ✓"},{"path":"https://bodkan.net/slendr/reference/clear_env.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove the automatically created slendr Python environment — clear_env","title":"Remove the automatically created slendr Python environment — clear_env","text":"Remove automatically created slendr Python environment","code":""},{"path":"https://bodkan.net/slendr/reference/clear_env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove the automatically created slendr Python environment — clear_env","text":"","code":"clear_env(force = FALSE, all = FALSE)"},{"path":"https://bodkan.net/slendr/reference/clear_env.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove the automatically created slendr Python environment — clear_env","text":"force Ask deleting environment? (present past) slendr Python environments removed (default FALSE) just current environment?","code":""},{"path":"https://bodkan.net/slendr/reference/clear_env.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove the automatically created slendr Python environment — clear_env","text":"return value, called side effects","code":""},{"path":"https://bodkan.net/slendr/reference/compile_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Compile a slendr demographic model — compile_model","title":"Compile a slendr demographic model — compile_model","text":"First, compiles vectorized population spatial maps series binary raster PNG files, format SLiM understands uses define population boundaries. extracts demographic model defined user (.e. population divergences gene flow events) series tables later used built-SLiM script program timing simulation events.","code":""},{"path":"https://bodkan.net/slendr/reference/compile_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compile a slendr demographic model — compile_model","text":"","code":"compile_model(   populations,   generation_time,   gene_flow = list(),   direction = NULL,   simulation_length = NULL,   serialize = TRUE,   path = NULL,   overwrite = FALSE,   force = FALSE,   description = \"\",   time_units = NULL,   resolution = NULL,   competition = NULL,   mating = NULL,   dispersal = NULL,   extension = NULL )"},{"path":"https://bodkan.net/slendr/reference/compile_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compile a slendr demographic model — compile_model","text":"populations Object(s) slendr_pop class (multiple objects need specified list) generation_time Generation time (model time units) gene_flow Gene flow events generated gene_flow function (either list data.frame objects format defined gene_flow function, single data.frame) direction Intended direction time. normal circumstances parameter inferred model need set manually. simulation_length Total length simulation (required forward time models, optional models specified backward time units default run \"present time\") serialize model files serialized disk? , R model object returned files created. speeds simulation msprime prevents using SLiM back end. path Output directory model configuration files loaded backend SLiM script. NULL, model configuration files saved temporary directory. overwrite Completely delete specified directory, case already exists, create new one? force Force deletion model directory already present? Useful non-interactive uses. interactive mode, user asked confirm deletion manually. description Optional short description model time_units Units time model event times interpreted. specified generation_time set 1, set \"generations\", otherwise value \"model time units\". resolution many distance units per pixel? competition, mating Maximum spatial competition mating choice distance dispersal Standard deviation normal distribution parent-offspring distance extension Path SLiM script used extending slendr's built-SLiM simulation engine. can either file snippet Eidos code, string containing code directly. Regardless, provided snippet appended contents bundled slendr SLiM script.","code":""},{"path":"https://bodkan.net/slendr/reference/compile_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compile a slendr demographic model — compile_model","text":"Compiled slendr_model model object encapsulates information specified model (populations involved, much gene flow occur, spatial resolution map, spatial dispersal mating parameters used SLiM simulation, applicable)","code":""},{"path":"https://bodkan.net/slendr/reference/compile_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compile a slendr demographic model — compile_model","text":"","code":"# spatial definitions -----------------------------------------------------  # create a blank abstract world 1000x1000 distance units in size map <- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = \"blank\")  # create a circular population with the center of a population boundary at # [200, 800] and a radius of 100 distance units, 1000 individuals at time 1 # occupying a map just specified pop1 <- population(\"pop1\", N = 1000, time = 1,                    map = map, center = c(200, 800), radius = 100)  # printing a population object to a console shows a brief summary pop1 #> slendr 'population' object  #> --------------------------  #> name: pop1  #> habitat: terrestrial #>  #> number of spatial maps: 1  #> map: abstract spatial landscape with custom features #> stays until the end of the simulation #>  #> population history overview: #>   - time 1: created as an ancestral population (N = 1000)  # create another population occupying a polygon range, splitting from pop1 # at a given time point (note that specifying a map is not necessary because # it is \"inherited\" from the parent) pop2 <- population(\"pop2\", N = 100, time = 50, parent = pop1,                         polygon = list(c(100, 100), c(320, 30), c(500, 200),                                   c(500, 400), c(300, 450), c(100, 400)))  pop3 <- population(\"pop3\", N = 200, time = 80, parent = pop2,                    center = c(800, 800), radius = 200)  # move \"pop1\" to another location along a specified trajectory and saved the # resulting object to the same variable (the number of intermediate spatial # snapshots can be also determined automatically by leaving out the # `snapshots = ` argument) pop1_moved <- move(pop1, start = 100, end = 200, snapshots = 6,                    trajectory = list(c(600, 820), c(800, 400), c(800, 150))) pop1_moved #> slendr 'population' object  #> --------------------------  #> name: pop1  #> habitat: terrestrial #>  #> number of spatial maps: 10  #> map: abstract spatial landscape with custom features #> stays until the end of the simulation #>  #> population history overview: #>   - time 1: created as an ancestral population (N = 1000) #>   - time 100-200: movement across a landscape  # many slendr functions are pipe-friendly, making it possible to construct # pipelines which construct entire history of a population pop1 <- population(\"pop1\", N = 1000, time = 1,                    map = map, center = c(200, 800), radius = 100) %>%   move(start = 100, end = 200, snapshots = 6,        trajectory = list(c(400, 800), c(600, 700), c(800, 400), c(800, 150))) %>%   set_range(time = 300, polygon = list(     c(400, 0), c(1000, 0), c(1000, 600), c(900, 400), c(800, 250),     c(600, 100), c(500, 50))   )  # population ranges can expand by a given distance in all directions pop2 <- expand_range(pop2, by = 200, start = 50, end = 150, snapshots = 3)  # we can check the positions of all populations interactively by plotting their # ranges together on a single map plot_map(pop1, pop2, pop3)   # gene flow events --------------------------------------------------------  # individual gene flow events can be saved to a list gf <- list(   gene_flow(from = pop1, to = pop3, start = 150, end = 200, rate = 0.15),   gene_flow(from = pop1, to = pop2, start = 300, end = 330, rate = 0.25) ) #> Warning: The argument `rate` is about to be deprecated because of its confusing #> naming and behavior. If you want to specify the rate of migration per #> unit of time, please use the new argument `migration_rate`. If you want #> to specify the total amount of ancestry which the `to` population should #> received from the `from` population, use the new argument `proportion` #> (this corresponds to the original interpretation of the deprecated `rate` #> argument, and a simple replacement of `rate` with `proportion` will thus #> retain the original meaning of your code all). #> Warning: The argument `rate` is about to be deprecated because of its confusing #> naming and behavior. If you want to specify the rate of migration per #> unit of time, please use the new argument `migration_rate`. If you want #> to specify the total amount of ancestry which the `to` population should #> received from the `from` population, use the new argument `proportion` #> (this corresponds to the original interpretation of the deprecated `rate` #> argument, and a simple replacement of `rate` with `proportion` will thus #> retain the original meaning of your code all).  # compilation -------------------------------------------------------------  # compile model components in a serialized form to dist, returning a single # slendr model object (in practice, the resolution should be smaller) model <- compile_model(   populations = list(pop1, pop2, pop3), generation_time = 1,   resolution = 100, simulation_length = 500,   competition = 5, mating = 5, dispersal = 1 )"},{"path":"https://bodkan.net/slendr/reference/distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the distance between a pair of spatial boundaries — distance","title":"Calculate the distance between a pair of spatial boundaries — distance","text":"Calculate distance pair spatial boundaries","code":""},{"path":"https://bodkan.net/slendr/reference/distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the distance between a pair of spatial boundaries — distance","text":"","code":"distance(x, y, measure, time = NULL)"},{"path":"https://bodkan.net/slendr/reference/distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the distance between a pair of spatial boundaries — distance","text":"x, y Objects class slendr measure measure distance? can either 'border' (distance borders x y) 'center' (distance centroids). time Time closest spatial maps x y represent slendr_pop population boundaries (ignored general slendr_region objects)","code":""},{"path":"https://bodkan.net/slendr/reference/distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the distance between a pair of spatial boundaries — distance","text":"coordinate reference system specified, distance projected units (.e. meters) returned. Otherwise function returns normal Euclidean distance.","code":""},{"path":"https://bodkan.net/slendr/reference/distance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the distance between a pair of spatial boundaries — distance","text":"","code":"# create two regions on a blank abstract landscape region_a <- region(\"A\", center = c(20, 50), radius = 20) region_b <- region(\"B\", center = c(80, 50), radius = 20) plot_map(region_a, region_b)   # compute the distance between the centers of both population ranges distance(region_a, region_b, measure = \"center\") #> [1] 60  # compute the distance between the borders of both population ranges distance(region_a, region_b, measure = \"border\") #> [1] 20"},{"path":"https://bodkan.net/slendr/reference/expand_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand the population range — expand_range","title":"Expand the population range — expand_range","text":"Expands spatial population range specified distance given time-window","code":""},{"path":"https://bodkan.net/slendr/reference/expand_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand the population range — expand_range","text":"","code":"expand_range(   pop,   by,   end,   start,   overlap = 0.8,   snapshots = NULL,   polygon = NULL,   lock = FALSE,   verbose = TRUE )"},{"path":"https://bodkan.net/slendr/reference/expand_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expand the population range — expand_range","text":"pop Object class slendr_pop many units distance expand ? start, end expansion start/end? overlap Minimum overlap subsequent spatial boundaries snapshots number intermediate snapshots (overrides overlap parameter) polygon Geographic region restrict expansion lock Maintain density individuals. FALSE (default), number individuals population change. TRUE, number individuals simulated changed (increased decreased) appropriately, match new population range area. verbose Report progress generating intermediate spatial boundaries?","code":""},{"path":"https://bodkan.net/slendr/reference/expand_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expand the population range — expand_range","text":"Object class slendr_pop, contains population parameters name, time appearance simulation, parent population (), spatial parameters map spatial boundary.","code":""},{"path":"https://bodkan.net/slendr/reference/expand_range.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Expand the population range — expand_range","text":"Note slendr models accomodate SLiM msprime back ends, population sizes times events rounded nearest integer value.","code":""},{"path":"https://bodkan.net/slendr/reference/expand_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expand the population range — expand_range","text":"","code":"# spatial definitions -----------------------------------------------------  # create a blank abstract world 1000x1000 distance units in size map <- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = \"blank\")  # create a circular population with the center of a population boundary at # [200, 800] and a radius of 100 distance units, 1000 individuals at time 1 # occupying a map just specified pop1 <- population(\"pop1\", N = 1000, time = 1,                    map = map, center = c(200, 800), radius = 100)  # printing a population object to a console shows a brief summary pop1 #> slendr 'population' object  #> --------------------------  #> name: pop1  #> habitat: terrestrial #>  #> number of spatial maps: 1  #> map: abstract spatial landscape with custom features #> stays until the end of the simulation #>  #> population history overview: #>   - time 1: created as an ancestral population (N = 1000)  # create another population occupying a polygon range, splitting from pop1 # at a given time point (note that specifying a map is not necessary because # it is \"inherited\" from the parent) pop2 <- population(\"pop2\", N = 100, time = 50, parent = pop1,                         polygon = list(c(100, 100), c(320, 30), c(500, 200),                                   c(500, 400), c(300, 450), c(100, 400)))  pop3 <- population(\"pop3\", N = 200, time = 80, parent = pop2,                    center = c(800, 800), radius = 200)  # move \"pop1\" to another location along a specified trajectory and saved the # resulting object to the same variable (the number of intermediate spatial # snapshots can be also determined automatically by leaving out the # `snapshots = ` argument) pop1_moved <- move(pop1, start = 100, end = 200, snapshots = 6,                    trajectory = list(c(600, 820), c(800, 400), c(800, 150))) pop1_moved #> slendr 'population' object  #> --------------------------  #> name: pop1  #> habitat: terrestrial #>  #> number of spatial maps: 10  #> map: abstract spatial landscape with custom features #> stays until the end of the simulation #>  #> population history overview: #>   - time 1: created as an ancestral population (N = 1000) #>   - time 100-200: movement across a landscape  # many slendr functions are pipe-friendly, making it possible to construct # pipelines which construct entire history of a population pop1 <- population(\"pop1\", N = 1000, time = 1,                    map = map, center = c(200, 800), radius = 100) %>%   move(start = 100, end = 200, snapshots = 6,        trajectory = list(c(400, 800), c(600, 700), c(800, 400), c(800, 150))) %>%   set_range(time = 300, polygon = list(     c(400, 0), c(1000, 0), c(1000, 600), c(900, 400), c(800, 250),     c(600, 100), c(500, 50))   )  # population ranges can expand by a given distance in all directions pop2 <- expand_range(pop2, by = 200, start = 50, end = 150, snapshots = 3)  # we can check the positions of all populations interactively by plotting their # ranges together on a single map plot_map(pop1, pop2, pop3)   # gene flow events --------------------------------------------------------  # individual gene flow events can be saved to a list gf <- list(   gene_flow(from = pop1, to = pop3, start = 150, end = 200, rate = 0.15),   gene_flow(from = pop1, to = pop2, start = 300, end = 330, rate = 0.25) ) #> Warning: The argument `rate` is about to be deprecated because of its confusing #> naming and behavior. If you want to specify the rate of migration per #> unit of time, please use the new argument `migration_rate`. If you want #> to specify the total amount of ancestry which the `to` population should #> received from the `from` population, use the new argument `proportion` #> (this corresponds to the original interpretation of the deprecated `rate` #> argument, and a simple replacement of `rate` with `proportion` will thus #> retain the original meaning of your code all). #> Warning: The argument `rate` is about to be deprecated because of its confusing #> naming and behavior. If you want to specify the rate of migration per #> unit of time, please use the new argument `migration_rate`. If you want #> to specify the total amount of ancestry which the `to` population should #> received from the `from` population, use the new argument `proportion` #> (this corresponds to the original interpretation of the deprecated `rate` #> argument, and a simple replacement of `rate` with `proportion` will thus #> retain the original meaning of your code all).  # compilation -------------------------------------------------------------  # compile model components in a serialized form to dist, returning a single # slendr model object (in practice, the resolution should be smaller) model <- compile_model(   populations = list(pop1, pop2, pop3), generation_time = 1,   resolution = 100, simulation_length = 500,   competition = 5, mating = 5, dispersal = 1 )"},{"path":"https://bodkan.net/slendr/reference/explore_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Open an interactive browser of the spatial model — explore_model","title":"Open an interactive browser of the spatial model — explore_model","text":"Open interactive browser spatial model","code":""},{"path":"https://bodkan.net/slendr/reference/explore_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Open an interactive browser of the spatial model — explore_model","text":"","code":"explore_model(model)"},{"path":"https://bodkan.net/slendr/reference/explore_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Open an interactive browser of the spatial model — explore_model","text":"model Compiled slendr_model model object","code":""},{"path":"https://bodkan.net/slendr/reference/explore_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Open an interactive browser of the spatial model — explore_model","text":"return value, called order start interactive browser-based interface explore dynamics slendr model","code":""},{"path":"https://bodkan.net/slendr/reference/extract_parameters.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract information from a compiled model or a simulated tree sequence — extract_parameters","title":"Extract information from a compiled model or a simulated tree sequence — extract_parameters","text":"function extract slendr model parameters used compile given model object simulate tree sequence","code":""},{"path":"https://bodkan.net/slendr/reference/extract_parameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract information from a compiled model or a simulated tree sequence — extract_parameters","text":"","code":"extract_parameters(data)"},{"path":"https://bodkan.net/slendr/reference/extract_parameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract information from a compiled model or a simulated tree sequence — extract_parameters","text":"data Either object class slendr_ts slendr_model","code":""},{"path":"https://bodkan.net/slendr/reference/extract_parameters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract information from a compiled model or a simulated tree sequence — extract_parameters","text":"list data frames containing parameters model used compiling model object","code":""},{"path":"https://bodkan.net/slendr/reference/extract_parameters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract information from a compiled model or a simulated tree sequence — extract_parameters","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model and simulate a tree sequence from it model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\")) ts <- msprime(model, sequence_length = 1e5, recombination_rate = 0)  # extract model parameters from a compiled model object as a list of data frames extract_parameters(model) #> $splits #>   pop parent    N    time remove #> 1  CH   <NA>   10 6500000     NA #> 2 AFR     CH   10 6000000     NA #> 3 NEA    AFR   10  600000  40000 #> 4 EUR    AFR 5000   70000     NA #>  #> $gene_flows #>   from  to start   end proportion #> 1  NEA EUR 55000 45000       0.03 #>   # the function can also extract parameters of a model which simulated a # tree sequence extract_parameters(ts) #> $splits #>   pop parent    N    time remove #> 1  CH   <NA>   10 6500000     NA #> 2 AFR     CH   10 6000000     NA #> 3 NEA    AFR   10  600000  40000 #> 4 EUR    AFR 5000   70000     NA #>  #> $gene_flows #>   from  to start   end proportion #> 1  NEA EUR 55000 45000       0.03 #>"},{"path":"https://bodkan.net/slendr/reference/gene_flow.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a gene-flow event between two populations — gene_flow","title":"Define a gene-flow event between two populations — gene_flow","text":"Define gene-flow event two populations","code":""},{"path":"https://bodkan.net/slendr/reference/gene_flow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a gene-flow event between two populations — gene_flow","text":"","code":"gene_flow(   from,   to,   start,   end,   proportion = NULL,   migration_rate = NULL,   overlap = TRUE,   rate = NULL )"},{"path":"https://bodkan.net/slendr/reference/gene_flow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a gene-flow event between two populations — gene_flow","text":", Objects class slendr_pop start, end Start end gene-flow event proportion Scalar value range (0, 1] specifying total proportion ancestry receiving population come source population entire gene-flow time window migration_rate Scalar value specifying rate gene flow per unit time given gene-flow time window overlap Require spatial overlap admixing populations?  (default TRUE) rate DEPRECATED (Old name now proportion argument)","code":""},{"path":"https://bodkan.net/slendr/reference/gene_flow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a gene-flow event between two populations — gene_flow","text":"Object class data.frame containing parameters specified gene-flow event.","code":""},{"path":"https://bodkan.net/slendr/reference/gene_flow.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define a gene-flow event between two populations — gene_flow","text":"","code":"# spatial definitions -----------------------------------------------------  # create a blank abstract world 1000x1000 distance units in size map <- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = \"blank\")  # create a circular population with the center of a population boundary at # [200, 800] and a radius of 100 distance units, 1000 individuals at time 1 # occupying a map just specified pop1 <- population(\"pop1\", N = 1000, time = 1,                    map = map, center = c(200, 800), radius = 100)  # printing a population object to a console shows a brief summary pop1 #> slendr 'population' object  #> --------------------------  #> name: pop1  #> habitat: terrestrial #>  #> number of spatial maps: 1  #> map: abstract spatial landscape with custom features #> stays until the end of the simulation #>  #> population history overview: #>   - time 1: created as an ancestral population (N = 1000)  # create another population occupying a polygon range, splitting from pop1 # at a given time point (note that specifying a map is not necessary because # it is \"inherited\" from the parent) pop2 <- population(\"pop2\", N = 100, time = 50, parent = pop1,                         polygon = list(c(100, 100), c(320, 30), c(500, 200),                                   c(500, 400), c(300, 450), c(100, 400)))  pop3 <- population(\"pop3\", N = 200, time = 80, parent = pop2,                    center = c(800, 800), radius = 200)  # move \"pop1\" to another location along a specified trajectory and saved the # resulting object to the same variable (the number of intermediate spatial # snapshots can be also determined automatically by leaving out the # `snapshots = ` argument) pop1_moved <- move(pop1, start = 100, end = 200, snapshots = 6,                    trajectory = list(c(600, 820), c(800, 400), c(800, 150))) pop1_moved #> slendr 'population' object  #> --------------------------  #> name: pop1  #> habitat: terrestrial #>  #> number of spatial maps: 10  #> map: abstract spatial landscape with custom features #> stays until the end of the simulation #>  #> population history overview: #>   - time 1: created as an ancestral population (N = 1000) #>   - time 100-200: movement across a landscape  # many slendr functions are pipe-friendly, making it possible to construct # pipelines which construct entire history of a population pop1 <- population(\"pop1\", N = 1000, time = 1,                    map = map, center = c(200, 800), radius = 100) %>%   move(start = 100, end = 200, snapshots = 6,        trajectory = list(c(400, 800), c(600, 700), c(800, 400), c(800, 150))) %>%   set_range(time = 300, polygon = list(     c(400, 0), c(1000, 0), c(1000, 600), c(900, 400), c(800, 250),     c(600, 100), c(500, 50))   )  # population ranges can expand by a given distance in all directions pop2 <- expand_range(pop2, by = 200, start = 50, end = 150, snapshots = 3)  # we can check the positions of all populations interactively by plotting their # ranges together on a single map plot_map(pop1, pop2, pop3)   # gene flow events --------------------------------------------------------  # individual gene flow events can be saved to a list gf <- list(   gene_flow(from = pop1, to = pop3, start = 150, end = 200, rate = 0.15),   gene_flow(from = pop1, to = pop2, start = 300, end = 330, rate = 0.25) ) #> Warning: The argument `rate` is about to be deprecated because of its confusing #> naming and behavior. If you want to specify the rate of migration per #> unit of time, please use the new argument `migration_rate`. If you want #> to specify the total amount of ancestry which the `to` population should #> received from the `from` population, use the new argument `proportion` #> (this corresponds to the original interpretation of the deprecated `rate` #> argument, and a simple replacement of `rate` with `proportion` will thus #> retain the original meaning of your code all). #> Warning: The argument `rate` is about to be deprecated because of its confusing #> naming and behavior. If you want to specify the rate of migration per #> unit of time, please use the new argument `migration_rate`. If you want #> to specify the total amount of ancestry which the `to` population should #> received from the `from` population, use the new argument `proportion` #> (this corresponds to the original interpretation of the deprecated `rate` #> argument, and a simple replacement of `rate` with `proportion` will thus #> retain the original meaning of your code all).  # compilation -------------------------------------------------------------  # compile model components in a serialized form to dist, returning a single # slendr model object (in practice, the resolution should be smaller) model <- compile_model(   populations = list(pop1, pop2, pop3), generation_time = 1,   resolution = 100, simulation_length = 500,   competition = 5, mating = 5, dispersal = 1 )"},{"path":"https://bodkan.net/slendr/reference/get_python.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a path to internal Python interpreter of slendr — get_python","title":"Get a path to internal Python interpreter of slendr — get_python","text":"Get path internal Python interpreter slendr","code":""},{"path":"https://bodkan.net/slendr/reference/get_python.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a path to internal Python interpreter of slendr — get_python","text":"","code":"get_python()"},{"path":"https://bodkan.net/slendr/reference/get_python.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a path to internal Python interpreter of slendr — get_python","text":"character scalar path slendr's Python binary","code":""},{"path":"https://bodkan.net/slendr/reference/init_env.html","id":null,"dir":"Reference","previous_headings":"","what":"Activate slendr's own dedicated Python environment — init_env","title":"Activate slendr's own dedicated Python environment — init_env","text":"function attempts activate dedicated slendr Miniconda Python environment previously set via setup_env.","code":""},{"path":"https://bodkan.net/slendr/reference/init_env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Activate slendr's own dedicated Python environment — init_env","text":"","code":"init_env(quiet = FALSE)"},{"path":"https://bodkan.net/slendr/reference/init_env.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Activate slendr's own dedicated Python environment — init_env","text":"quiet informative messages printed console? Default FALSE.","code":""},{"path":"https://bodkan.net/slendr/reference/init_env.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Activate slendr's own dedicated Python environment — init_env","text":"return value, called side effects","code":""},{"path":"https://bodkan.net/slendr/reference/join.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge two spatial slendr objects into one — join","title":"Merge two spatial slendr objects into one — join","text":"Merge two spatial slendr objects one","code":""},{"path":"https://bodkan.net/slendr/reference/join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge two spatial slendr objects into one — join","text":"","code":"join(x, y, name = NULL)"},{"path":"https://bodkan.net/slendr/reference/join.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge two spatial slendr objects into one — join","text":"x Object class slendr y Object class slendr name Optional name resulting geographic region. missing, name constructed function arguments.","code":""},{"path":"https://bodkan.net/slendr/reference/join.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge two spatial slendr objects into one — join","text":"Object class slendr_region encodes standard spatial object class sf several additional attributes (importantly corresponding slendr_map object, applicable).","code":""},{"path":"https://bodkan.net/slendr/reference/join.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge two spatial slendr objects into one — join","text":"","code":"# create a blank abstract world 1000x1000 distance units in size blank_map <- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = \"blank\")  # it is possible to construct custom landscapes (islands, corridors, etc.) island1 <- region(\"island1\", polygon = list(c(10, 30), c(50, 30), c(40, 50), c(0, 40))) island2 <- region(\"island2\", polygon = list(c(60, 60), c(80, 40), c(100, 60), c(80, 80))) island3 <- region(\"island3\", center = c(20, 80), radius = 10) archipelago <- island1 %>% join(island2) %>% join(island3)  custom_map <- world(xrange = c(1, 100), c(1, 100), landscape = archipelago)  # real Earth landscapes can be defined using freely-available Natural Earth # project data and with the possibility to specify an appropriate Coordinate # Reference System, such as this example of a map of Europe  real_map <- world(xrange = c(-15, 40), yrange = c(30, 60), crs = \"EPSG:3035\")"},{"path":"https://bodkan.net/slendr/reference/move.html","id":null,"dir":"Reference","previous_headings":"","what":"Move the population to a new location in a given amount of time — move","title":"Move the population to a new location in a given amount of time — move","text":"function defines displacement population along given trajectory given time frame","code":""},{"path":"https://bodkan.net/slendr/reference/move.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Move the population to a new location in a given amount of time — move","text":"","code":"move(   pop,   trajectory,   end,   start,   overlap = 0.8,   snapshots = NULL,   verbose = TRUE )"},{"path":"https://bodkan.net/slendr/reference/move.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Move the population to a new location in a given amount of time — move","text":"pop Object class slendr_pop trajectory List two-dimensional vectors (longitude, latitude) specifying migration trajectory start, end Start/end points population migration overlap Minimum overlap subsequent spatial boundaries snapshots number intermediate snapshots (overrides overlap parameter) verbose Show progress searching number sufficient snapshots?","code":""},{"path":"https://bodkan.net/slendr/reference/move.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Move the population to a new location in a given amount of time — move","text":"Object class slendr_pop, contains population parameters name, time appearance simulation, parent population (), spatial parameters map spatial boundary.","code":""},{"path":"https://bodkan.net/slendr/reference/move.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Move the population to a new location in a given amount of time — move","text":"","code":"# spatial definitions -----------------------------------------------------  # create a blank abstract world 1000x1000 distance units in size map <- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = \"blank\")  # create a circular population with the center of a population boundary at # [200, 800] and a radius of 100 distance units, 1000 individuals at time 1 # occupying a map just specified pop1 <- population(\"pop1\", N = 1000, time = 1,                    map = map, center = c(200, 800), radius = 100)  # printing a population object to a console shows a brief summary pop1 #> slendr 'population' object  #> --------------------------  #> name: pop1  #> habitat: terrestrial #>  #> number of spatial maps: 1  #> map: abstract spatial landscape with custom features #> stays until the end of the simulation #>  #> population history overview: #>   - time 1: created as an ancestral population (N = 1000)  # create another population occupying a polygon range, splitting from pop1 # at a given time point (note that specifying a map is not necessary because # it is \"inherited\" from the parent) pop2 <- population(\"pop2\", N = 100, time = 50, parent = pop1,                         polygon = list(c(100, 100), c(320, 30), c(500, 200),                                   c(500, 400), c(300, 450), c(100, 400)))  pop3 <- population(\"pop3\", N = 200, time = 80, parent = pop2,                    center = c(800, 800), radius = 200)  # move \"pop1\" to another location along a specified trajectory and saved the # resulting object to the same variable (the number of intermediate spatial # snapshots can be also determined automatically by leaving out the # `snapshots = ` argument) pop1_moved <- move(pop1, start = 100, end = 200, snapshots = 6,                    trajectory = list(c(600, 820), c(800, 400), c(800, 150))) pop1_moved #> slendr 'population' object  #> --------------------------  #> name: pop1  #> habitat: terrestrial #>  #> number of spatial maps: 10  #> map: abstract spatial landscape with custom features #> stays until the end of the simulation #>  #> population history overview: #>   - time 1: created as an ancestral population (N = 1000) #>   - time 100-200: movement across a landscape  # many slendr functions are pipe-friendly, making it possible to construct # pipelines which construct entire history of a population pop1 <- population(\"pop1\", N = 1000, time = 1,                    map = map, center = c(200, 800), radius = 100) %>%   move(start = 100, end = 200, snapshots = 6,        trajectory = list(c(400, 800), c(600, 700), c(800, 400), c(800, 150))) %>%   set_range(time = 300, polygon = list(     c(400, 0), c(1000, 0), c(1000, 600), c(900, 400), c(800, 250),     c(600, 100), c(500, 50))   )  # population ranges can expand by a given distance in all directions pop2 <- expand_range(pop2, by = 200, start = 50, end = 150, snapshots = 3)  # we can check the positions of all populations interactively by plotting their # ranges together on a single map plot_map(pop1, pop2, pop3)   # gene flow events --------------------------------------------------------  # individual gene flow events can be saved to a list gf <- list(   gene_flow(from = pop1, to = pop3, start = 150, end = 200, rate = 0.15),   gene_flow(from = pop1, to = pop2, start = 300, end = 330, rate = 0.25) ) #> Warning: The argument `rate` is about to be deprecated because of its confusing #> naming and behavior. If you want to specify the rate of migration per #> unit of time, please use the new argument `migration_rate`. If you want #> to specify the total amount of ancestry which the `to` population should #> received from the `from` population, use the new argument `proportion` #> (this corresponds to the original interpretation of the deprecated `rate` #> argument, and a simple replacement of `rate` with `proportion` will thus #> retain the original meaning of your code all). #> Warning: The argument `rate` is about to be deprecated because of its confusing #> naming and behavior. If you want to specify the rate of migration per #> unit of time, please use the new argument `migration_rate`. If you want #> to specify the total amount of ancestry which the `to` population should #> received from the `from` population, use the new argument `proportion` #> (this corresponds to the original interpretation of the deprecated `rate` #> argument, and a simple replacement of `rate` with `proportion` will thus #> retain the original meaning of your code all).  # compilation -------------------------------------------------------------  # compile model components in a serialized form to dist, returning a single # slendr model object (in practice, the resolution should be smaller) model <- compile_model(   populations = list(pop1, pop2, pop3), generation_time = 1,   resolution = 100, simulation_length = 500,   competition = 5, mating = 5, dispersal = 1 )"},{"path":"https://bodkan.net/slendr/reference/msprime.html","id":null,"dir":"Reference","previous_headings":"","what":"Run a slendr model in msprime — msprime","title":"Run a slendr model in msprime — msprime","text":"function execute built-msprime script run compiled slendr demographic model.","code":""},{"path":"https://bodkan.net/slendr/reference/msprime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run a slendr model in msprime — msprime","text":"","code":"msprime(   model,   sequence_length,   recombination_rate,   samples = NULL,   random_seed = NULL,   verbose = FALSE,   debug = FALSE,   run = TRUE,   path = NULL,   coalescent_only = TRUE )"},{"path":"https://bodkan.net/slendr/reference/msprime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run a slendr model in msprime — msprime","text":"model Model object created compile function sequence_length Total length simulated sequence (base-pairs) recombination_rate Recombination rate simulated sequence (recombinations per basepair per generation) samples data frame times given number individuals remembered tree-sequence (see schedule_sampling function can generate sampling schedule correct format). missing, individuals present end simulation recorded final tree-sequence file. random_seed Random seed (NULL, seed generated 0 maximum integer number available) verbose Write log information SLiM run console (default FALSE)? debug Write msprime's debug log console (default FALSE)? run msprime engine run? FALSE, command line msprime command printed (returned invisibly character vector) executed. path Path directory simulation result files saved. NULL, directory automatically created temporary directory. TRUE, path also returned function. string given, assumed path directory simulation results saved. case, function return path invisibly. Note tree-sequence file simulated (along files, potentially), tree-sequence file (named 'msprime.trees' default) explicitly loaded using ts_read(). coalescent_only Default TRUE, record minimum amount information necessary represent genealogical history simulated samples (.e., nodes MRCA pair samples locus genome). Setting FALSE record much information, resulting unary nodes tree sequence. parameter translates coalescing_segments_only argument underlying msprime method sim_ancestry. See Details additional information.","code":""},{"path":"https://bodkan.net/slendr/reference/msprime.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run a slendr model in msprime — msprime","text":"tree-sequence object loaded via Python-R reticulate interface function ts_read (internally represented Python object tskit.trees.TreeSequence). path argument set, return path single-element character vector.","code":""},{"path":"https://bodkan.net/slendr/reference/msprime.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run a slendr model in msprime — msprime","text":"information coalescent_only argument, please see msprime documentation, particularly section \"Recording information\" coalescing_segments_only argument method sim_ancestry() https://tskit.dev/msprime/docs/stable/ancestry.html#recording--information. https://tskit.dev/msprime/docs/stable/api.html#msprime.sim_ancestry.","code":""},{"path":"https://bodkan.net/slendr/reference/msprime.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run a slendr model in msprime — msprime","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # afr and eur objects would normally be created before slendr model compilation, # but here we take them out of the model object already compiled for this # example (in a standard slendr simulation pipeline, this wouldn't be necessary) afr <- model$populations[[\"AFR\"]] eur <- model$populations[[\"EUR\"]] chimp <- model$populations[[\"CH\"]]  # schedule the sampling of a couple of ancient and present-day individuals # given model at 20 ky, 10 ky, 5ky ago and at present-day (time 0) modern_samples <- schedule_sampling(model, times = 0, list(afr, 10), list(eur, 100), list(chimp, 1)) ancient_samples <- schedule_sampling(model, times = c(40000, 30000, 20000, 10000), list(eur, 1))  # sampling schedules are just data frames and can be merged easily samples <- rbind(modern_samples, ancient_samples)  # run a simulation using the msprime back end from a compiled slendr model object ts <- msprime(model, sequence_length = 1e5, recombination_rate = 0, samples = samples)  # simulated tree-sequence object can be saved to a file using ts_write()... ts_file <- normalizePath(tempfile(fileext = \".trees\"), winslash = \"/\", mustWork = FALSE) ts_write(ts, ts_file) # ... and, at a later point, loaded by ts_read() ts <- ts_read(ts_file, model)  summary(ts) #> ╔═══════════════════════════╗ #> ║TreeSequence               ║ #> ╠═══════════════╤═══════════╣ #> ║Trees          │          1║ #> ╟───────────────┼───────────╢ #> ║Sequence Length│    100,000║ #> ╟───────────────┼───────────╢ #> ║Time Units     │generations║ #> ╟───────────────┼───────────╢ #> ║Sample Nodes   │        230║ #> ╟───────────────┼───────────╢ #> ║Total Size     │   39.3 KiB║ #> ╚═══════════════╧═══════════╝ #> ╔═══════════╤════╤═════════╤════════════╗ #> ║Table      │Rows│Size     │Has Metadata║ #> ╠═══════════╪════╪═════════╪════════════╣ #> ║Edges      │ 470│ 14.7 KiB│          No║ #> ╟───────────┼────┼─────────┼────────────╢ #> ║Individuals│ 115│  3.2 KiB│          No║ #> ╟───────────┼────┼─────────┼────────────╢ #> ║Migrations │   0│  8 Bytes│          No║ #> ╟───────────┼────┼─────────┼────────────╢ #> ║Mutations  │   0│ 16 Bytes│          No║ #> ╟───────────┼────┼─────────┼────────────╢ #> ║Nodes      │ 471│ 12.9 KiB│          No║ #> ╟───────────┼────┼─────────┼────────────╢ #> ║Populations│   4│338 Bytes│         Yes║ #> ╟───────────┼────┼─────────┼────────────╢ #> ║Provenances│   1│  2.9 KiB│          No║ #> ╟───────────┼────┼─────────┼────────────╢ #> ║Sites      │   0│ 16 Bytes│          No║ #> ╚═══════════╧════╧═════════╧════════════╝ #>"},{"path":"https://bodkan.net/slendr/reference/overlap.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate the overlap of two slendr objects — overlap","title":"Generate the overlap of two slendr objects — overlap","text":"Generate overlap two slendr objects","code":""},{"path":"https://bodkan.net/slendr/reference/overlap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate the overlap of two slendr objects — overlap","text":"","code":"overlap(x, y, name = NULL)"},{"path":"https://bodkan.net/slendr/reference/overlap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate the overlap of two slendr objects — overlap","text":"x Object class slendr y Object class slendr name Optional name resulting geographic region. missing, name constructed function arguments.","code":""},{"path":"https://bodkan.net/slendr/reference/overlap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate the overlap of two slendr objects — overlap","text":"Object class slendr_region encodes standard spatial object class sf several additional attributes (importantly corresponding slendr_map object, applicable).","code":""},{"path":"https://bodkan.net/slendr/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"Pipe operator","code":""},{"path":"https://bodkan.net/slendr/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://bodkan.net/slendr/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://bodkan.net/slendr/reference/plot_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot slendr geographic features on a map — plot_map","title":"Plot slendr geographic features on a map — plot_map","text":"Plots objects three slendr spatial classes (slendr_map, slendr_region, slendr_pop).","code":""},{"path":"https://bodkan.net/slendr/reference/plot_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot slendr geographic features on a map — plot_map","text":"","code":"plot_map(   ...,   time = NULL,   gene_flow = FALSE,   splits = FALSE,   labels = FALSE,   arrows = TRUE,   graticules = \"original\",   intersect = TRUE,   show_map = TRUE,   title = NULL,   interpolated_maps = NULL )"},{"path":"https://bodkan.net/slendr/reference/plot_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot slendr geographic features on a map — plot_map","text":"... Objects classes slendr_map, slendr_region, slendr_pop time Plot concrete time point gene_flow Indicate gene-flow events linking demes line splits Indicate split events lines labels (starting) polygons populations labeled respective population label (default FALSE)? arrows gene-flow links also indicated arrow? graticules Plot graticules original Coordinate Reference System (longitude-latitude), internal CRS (meters)? intersect Intersect population boundaries landscape geographic boundaries (default TRUE)? show_map Show underlying world map title Title plot interpolated_maps Interpolated spatial boundaries populations time points (used plotting using explore shiny app)","code":""},{"path":"https://bodkan.net/slendr/reference/plot_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot slendr geographic features on a map — plot_map","text":"ggplot2 object visualized slendr map","code":""},{"path":"https://bodkan.net/slendr/reference/plot_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot demographic history encoded in a slendr model — plot_model","title":"Plot demographic history encoded in a slendr model — plot_model","text":"Plot demographic history encoded slendr model","code":""},{"path":"https://bodkan.net/slendr/reference/plot_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot demographic history encoded in a slendr model — plot_model","text":"","code":"plot_model(   model,   sizes = TRUE,   proportions = FALSE,   gene_flow = TRUE,   log = FALSE,   order = NULL,   file = NULL,   samples = NULL,   ... )"},{"path":"https://bodkan.net/slendr/reference/plot_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot demographic history encoded in a slendr model — plot_model","text":"model Compiled slendr_model model object sizes population size changes visualized? proportions gene flow proportions visualized (FALSE default prevent cluttering overplotting) gene_flow gene-flow arrows visualized (default TRUE). log y-axis plotted log scale? Useful models long time-scales. order Order populations along x-axis, given character vector population names. NULL (default), default plotting algorithm used, ordering populations ancestral recent using -order tree traversal. file Output file figure saved via ggsave samples Sampling schedule visualized model ... Optional argument passed ggsave","code":""},{"path":"https://bodkan.net/slendr/reference/plot_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot demographic history encoded in a slendr model — plot_model","text":"ggplot2 object visualized slendr model","code":""},{"path":"https://bodkan.net/slendr/reference/plot_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot demographic history encoded in a slendr model — plot_model","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence path <- system.file(\"extdata/models/introgression\", package = \"slendr\") model <- read_model(path)  plot_model(model, sizes = FALSE, log = TRUE)"},{"path":"https://bodkan.net/slendr/reference/population.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a population — population","title":"Define a population — population","text":"Defines parameters population (non-spatial spatial).","code":""},{"path":"https://bodkan.net/slendr/reference/population.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a population — population","text":"","code":"population(   name,   time,   N,   parent = NULL,   map = FALSE,   center = NULL,   radius = NULL,   polygon = NULL,   remove = NULL,   intersect = TRUE,   competition = NA,   mating = NA,   dispersal = NA,   dispersal_fun = NULL,   aquatic = FALSE )"},{"path":"https://bodkan.net/slendr/reference/population.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a population — population","text":"name Name population time Time population's first appearance N Number individuals time first appearance parent Parent population object NULL (indicates population ancestor, first population \"lineage\") map Object type slendr_map defines world context (created using world function). value FALSE provided, non-spatial model run. center Two-dimensional vector specifying center circular range radius Radius circular range polygon List vector pairs, defining corners polygon range geographic region class slendr_region polygon coordinates extracted (see region() function) remove Time population removed intersect Intersect population's boundaries landscape features? competition, mating Maximum spatial competition mating choice distance dispersal Standard deviation normal distribution distance offspring disperses parent dispersal_fun Distribution function governing dispersal offspring. One \"normal\", \"uniform\", \"cauchy\", \"exponential\", \"brownian\" (vertical horizontal displacements drawn normal distribution independently). aquatic species aquatic (FALSE default, .e. terrestrial species)?","code":""},{"path":"https://bodkan.net/slendr/reference/population.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a population — population","text":"Object class slendr_pop, contains population parameters name, time appearance simulation, parent population (), spatial parameters map spatial boundary.","code":""},{"path":"https://bodkan.net/slendr/reference/population.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Define a population — population","text":"four ways specify spatial boundary: ) circular range specified using center coordinate radius, ii) polygon specified list two-dimensional vector coordinates, iii) polygon ii), defined (named) using region function, iv) just world map specified (circular polygon range parameters set default NULL value), population allowed occupy entire landscape. Note slendr models accomodate SLiM msprime back ends, population sizes split times rounded nearest integer value.","code":""},{"path":"https://bodkan.net/slendr/reference/population.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define a population — population","text":"","code":"# spatial definitions -----------------------------------------------------  # create a blank abstract world 1000x1000 distance units in size map <- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = \"blank\")  # create a circular population with the center of a population boundary at # [200, 800] and a radius of 100 distance units, 1000 individuals at time 1 # occupying a map just specified pop1 <- population(\"pop1\", N = 1000, time = 1,                    map = map, center = c(200, 800), radius = 100)  # printing a population object to a console shows a brief summary pop1 #> slendr 'population' object  #> --------------------------  #> name: pop1  #> habitat: terrestrial #>  #> number of spatial maps: 1  #> map: abstract spatial landscape with custom features #> stays until the end of the simulation #>  #> population history overview: #>   - time 1: created as an ancestral population (N = 1000)  # create another population occupying a polygon range, splitting from pop1 # at a given time point (note that specifying a map is not necessary because # it is \"inherited\" from the parent) pop2 <- population(\"pop2\", N = 100, time = 50, parent = pop1,                         polygon = list(c(100, 100), c(320, 30), c(500, 200),                                   c(500, 400), c(300, 450), c(100, 400)))  pop3 <- population(\"pop3\", N = 200, time = 80, parent = pop2,                    center = c(800, 800), radius = 200)  # move \"pop1\" to another location along a specified trajectory and saved the # resulting object to the same variable (the number of intermediate spatial # snapshots can be also determined automatically by leaving out the # `snapshots = ` argument) pop1_moved <- move(pop1, start = 100, end = 200, snapshots = 6,                    trajectory = list(c(600, 820), c(800, 400), c(800, 150))) pop1_moved #> slendr 'population' object  #> --------------------------  #> name: pop1  #> habitat: terrestrial #>  #> number of spatial maps: 10  #> map: abstract spatial landscape with custom features #> stays until the end of the simulation #>  #> population history overview: #>   - time 1: created as an ancestral population (N = 1000) #>   - time 100-200: movement across a landscape  # many slendr functions are pipe-friendly, making it possible to construct # pipelines which construct entire history of a population pop1 <- population(\"pop1\", N = 1000, time = 1,                    map = map, center = c(200, 800), radius = 100) %>%   move(start = 100, end = 200, snapshots = 6,        trajectory = list(c(400, 800), c(600, 700), c(800, 400), c(800, 150))) %>%   set_range(time = 300, polygon = list(     c(400, 0), c(1000, 0), c(1000, 600), c(900, 400), c(800, 250),     c(600, 100), c(500, 50))   )  # population ranges can expand by a given distance in all directions pop2 <- expand_range(pop2, by = 200, start = 50, end = 150, snapshots = 3)  # we can check the positions of all populations interactively by plotting their # ranges together on a single map plot_map(pop1, pop2, pop3)   # gene flow events --------------------------------------------------------  # individual gene flow events can be saved to a list gf <- list(   gene_flow(from = pop1, to = pop3, start = 150, end = 200, rate = 0.15),   gene_flow(from = pop1, to = pop2, start = 300, end = 330, rate = 0.25) ) #> Warning: The argument `rate` is about to be deprecated because of its confusing #> naming and behavior. If you want to specify the rate of migration per #> unit of time, please use the new argument `migration_rate`. If you want #> to specify the total amount of ancestry which the `to` population should #> received from the `from` population, use the new argument `proportion` #> (this corresponds to the original interpretation of the deprecated `rate` #> argument, and a simple replacement of `rate` with `proportion` will thus #> retain the original meaning of your code all). #> Warning: The argument `rate` is about to be deprecated because of its confusing #> naming and behavior. If you want to specify the rate of migration per #> unit of time, please use the new argument `migration_rate`. If you want #> to specify the total amount of ancestry which the `to` population should #> received from the `from` population, use the new argument `proportion` #> (this corresponds to the original interpretation of the deprecated `rate` #> argument, and a simple replacement of `rate` with `proportion` will thus #> retain the original meaning of your code all).  # compilation -------------------------------------------------------------  # compile model components in a serialized form to dist, returning a single # slendr model object (in practice, the resolution should be smaller) model <- compile_model(   populations = list(pop1, pop2, pop3), generation_time = 1,   resolution = 100, simulation_length = 500,   competition = 5, mating = 5, dispersal = 1 )"},{"path":"https://bodkan.net/slendr/reference/print.slendr_pop.html","id":null,"dir":"Reference","previous_headings":"","what":"Print a short summary of a slendr object — print.slendr_pop","title":"Print a short summary of a slendr object — print.slendr_pop","text":"spatial objects slendr package internally represented Simple Features (sf) objects. fact hidden circumstances , goal slendr package provide functionality much higher level (population boundaries, geographic regions, instead individual polygons \"low-level\" geometric objects), without users worry low-level details involved handling spatial geometries. However, full sf object representation can always printed calling x[].","code":""},{"path":"https://bodkan.net/slendr/reference/print.slendr_pop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print a short summary of a slendr object — print.slendr_pop","text":"","code":"# S3 method for class 'slendr_pop' print(x, ...)  # S3 method for class 'slendr_region' print(x, ...)  # S3 method for class 'slendr_map' print(x, ...)  # S3 method for class 'slendr_model' print(x, ...)"},{"path":"https://bodkan.net/slendr/reference/print.slendr_pop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print a short summary of a slendr object — print.slendr_pop","text":"x Object class slendr (either slendr_pop, slendr_map, slendr_region, slendr_table) ... Additional arguments passed print","code":""},{"path":"https://bodkan.net/slendr/reference/print.slendr_pop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print a short summary of a slendr object — print.slendr_pop","text":"return value, used printing","code":""},{"path":"https://bodkan.net/slendr/reference/print.slendr_ts.html","id":null,"dir":"Reference","previous_headings":"","what":"Print tskit's summary table of the Python tree-sequence object — print.slendr_ts","title":"Print tskit's summary table of the Python tree-sequence object — print.slendr_ts","text":"Print tskit's summary table Python tree-sequence object","code":""},{"path":"https://bodkan.net/slendr/reference/print.slendr_ts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print tskit's summary table of the Python tree-sequence object — print.slendr_ts","text":"","code":"# S3 method for class 'slendr_ts' print(x, ...)"},{"path":"https://bodkan.net/slendr/reference/print.slendr_ts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print tskit's summary table of the Python tree-sequence object — print.slendr_ts","text":"x Tree object class slendr_phylo ... Additional arguments normally passed print (used case)","code":""},{"path":"https://bodkan.net/slendr/reference/print.slendr_ts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print tskit's summary table of the Python tree-sequence object — print.slendr_ts","text":"return value, simply prints tskit summary table terminal","code":""},{"path":"https://bodkan.net/slendr/reference/read_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a previously serialized model configuration — read_model","title":"Read a previously serialized model configuration — read_model","text":"Reads configuration tables model data location previously compiled compile function.","code":""},{"path":"https://bodkan.net/slendr/reference/read_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a previously serialized model configuration — read_model","text":"","code":"read_model(path)"},{"path":"https://bodkan.net/slendr/reference/read_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a previously serialized model configuration — read_model","text":"path Directory required configuration files","code":""},{"path":"https://bodkan.net/slendr/reference/read_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a previously serialized model configuration — read_model","text":"Compiled slendr_model model object encapsulates information specified model (populations involved, much gene flow occur, spatial resolution map, spatial dispersal mating parameters used SLiM simulation, applicable)","code":""},{"path":"https://bodkan.net/slendr/reference/read_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read a previously serialized model configuration — read_model","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence path <- system.file(\"extdata/models/introgression\", package = \"slendr\") model <- read_model(path)  plot_model(model, sizes = FALSE, log = TRUE)"},{"path":"https://bodkan.net/slendr/reference/region.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a geographic region — region","title":"Define a geographic region — region","text":"Creates geographic region (polygon) given map gives name. can used define objects can reused multiple places slendr script (region arguments population) without repeatedly define polygon coordinates.","code":""},{"path":"https://bodkan.net/slendr/reference/region.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a geographic region — region","text":"","code":"region(name = NULL, map = NULL, center = NULL, radius = NULL, polygon = NULL)"},{"path":"https://bodkan.net/slendr/reference/region.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a geographic region — region","text":"name Name geographic region map Object type sf defines map center Two-dimensional vector specifying center circular range radius Radius circular range polygon List vector pairs, defining corners polygon range geographic region class slendr_region polygon coordinates extracted (see region() function)","code":""},{"path":"https://bodkan.net/slendr/reference/region.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a geographic region — region","text":"Object class slendr_region encodes standard spatial object class sf several additional attributes (importantly corresponding slendr_map object, applicable).","code":""},{"path":"https://bodkan.net/slendr/reference/region.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define a geographic region — region","text":"","code":"# create a blank abstract world 1000x1000 distance units in size blank_map <- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = \"blank\")  # it is possible to construct custom landscapes (islands, corridors, etc.) island1 <- region(\"island1\", polygon = list(c(10, 30), c(50, 30), c(40, 50), c(0, 40))) island2 <- region(\"island2\", polygon = list(c(60, 60), c(80, 40), c(100, 60), c(80, 80))) island3 <- region(\"island3\", center = c(20, 80), radius = 10) archipelago <- island1 %>% join(island2) %>% join(island3)  custom_map <- world(xrange = c(1, 100), c(1, 100), landscape = archipelago)  # real Earth landscapes can be defined using freely-available Natural Earth # project data and with the possibility to specify an appropriate Coordinate # Reference System, such as this example of a map of Europe  real_map <- world(xrange = c(-15, 40), yrange = c(30, 60), crs = \"EPSG:3035\")"},{"path":"https://bodkan.net/slendr/reference/reproject.html","id":null,"dir":"Reference","previous_headings":"","what":"Reproject coordinates between coordinate systems — reproject","title":"Reproject coordinates between coordinate systems — reproject","text":"Converts coordinates compiled raster map (.e. pixel units) different Geographic Coordinate Systems (CRS).","code":""},{"path":"https://bodkan.net/slendr/reference/reproject.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reproject coordinates between coordinate systems — reproject","text":"","code":"reproject(   from,   to,   x = NULL,   y = NULL,   coords = NULL,   model = NULL,   add = FALSE,   input_prefix = \"\",   output_prefix = \"new\" )"},{"path":"https://bodkan.net/slendr/reference/reproject.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reproject coordinates between coordinate systems — reproject","text":", Either CRS code accepted GDAL, valid integer EPSG value, object class crs, value \"raster\" (converting /pixel coordinates), \"world\" (converting /whatever CRS set underlying map) x, y Coordinates two dimensions (missing, coordinates expected data.frame specified coords parameter columns \"x\" \"y\") coords data.frame-like object coordinates columns \"x\" \"y\" model Object class slendr_model add Add column coordinates input data.frame coords (coordinates otherwise returned separate object)? input_prefix, output_prefix Input output prefixes data frame columns spatial coordinates","code":""},{"path":"https://bodkan.net/slendr/reference/reproject.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reproject coordinates between coordinate systems — reproject","text":"Data.frame converted two-dimensional coordinates given input","code":""},{"path":"https://bodkan.net/slendr/reference/reproject.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reproject coordinates between coordinate systems — reproject","text":"","code":"lon_lat_df <- data.frame(x = c(30, 0, 15), y = c(60, 40, 10))  reproject(   from = \"epsg:4326\",   to = \"epsg:3035\",   coords = lon_lat_df,   add = TRUE # add converted [lon,lat] coordinates as a new column ) #> # A tibble: 3 × 4 #>       x     y     newx      newy #>   <dbl> <dbl>    <dbl>     <dbl> #> 1    30    60 5422493.  4256803. #> 2     0    40 3465349.  1934879. #> 3    15    10 4907297. -1328914."},{"path":"https://bodkan.net/slendr/reference/resize.html","id":null,"dir":"Reference","previous_headings":"","what":"Change the population size — resize","title":"Change the population size — resize","text":"Resizes population starting current value N individuals specified value","code":""},{"path":"https://bodkan.net/slendr/reference/resize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Change the population size — resize","text":"","code":"resize(pop, N, how, time, end = NULL)"},{"path":"https://bodkan.net/slendr/reference/resize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Change the population size — resize","text":"pop Object class slendr_pop N Population size change change population size (options \"step\" \"exponential\") time Time population size change end End population size change period (used exponential change events)","code":""},{"path":"https://bodkan.net/slendr/reference/resize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Change the population size — resize","text":"Object class slendr_pop, contains population parameters name, time appearance simulation, parent population (), spatial parameters map spatial boundary.","code":""},{"path":"https://bodkan.net/slendr/reference/resize.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Change the population size — resize","text":"case exponential size change, final N larger current size, population exponentially growing specified time period reaches N individuals. N smaller, population shrink exponentially. Note slendr models accomodate SLiM msprime back ends, population sizes split times rounded nearest integer value.","code":""},{"path":"https://bodkan.net/slendr/reference/resize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Change the population size — resize","text":"","code":"# spatial definitions -----------------------------------------------------  # create a blank abstract world 1000x1000 distance units in size map <- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = \"blank\")  # create a circular population with the center of a population boundary at # [200, 800] and a radius of 100 distance units, 1000 individuals at time 1 # occupying a map just specified pop1 <- population(\"pop1\", N = 1000, time = 1,                    map = map, center = c(200, 800), radius = 100)  # printing a population object to a console shows a brief summary pop1 #> slendr 'population' object  #> --------------------------  #> name: pop1  #> habitat: terrestrial #>  #> number of spatial maps: 1  #> map: abstract spatial landscape with custom features #> stays until the end of the simulation #>  #> population history overview: #>   - time 1: created as an ancestral population (N = 1000)  # create another population occupying a polygon range, splitting from pop1 # at a given time point (note that specifying a map is not necessary because # it is \"inherited\" from the parent) pop2 <- population(\"pop2\", N = 100, time = 50, parent = pop1,                         polygon = list(c(100, 100), c(320, 30), c(500, 200),                                   c(500, 400), c(300, 450), c(100, 400)))  pop3 <- population(\"pop3\", N = 200, time = 80, parent = pop2,                    center = c(800, 800), radius = 200)  # move \"pop1\" to another location along a specified trajectory and saved the # resulting object to the same variable (the number of intermediate spatial # snapshots can be also determined automatically by leaving out the # `snapshots = ` argument) pop1_moved <- move(pop1, start = 100, end = 200, snapshots = 6,                    trajectory = list(c(600, 820), c(800, 400), c(800, 150))) pop1_moved #> slendr 'population' object  #> --------------------------  #> name: pop1  #> habitat: terrestrial #>  #> number of spatial maps: 10  #> map: abstract spatial landscape with custom features #> stays until the end of the simulation #>  #> population history overview: #>   - time 1: created as an ancestral population (N = 1000) #>   - time 100-200: movement across a landscape  # many slendr functions are pipe-friendly, making it possible to construct # pipelines which construct entire history of a population pop1 <- population(\"pop1\", N = 1000, time = 1,                    map = map, center = c(200, 800), radius = 100) %>%   move(start = 100, end = 200, snapshots = 6,        trajectory = list(c(400, 800), c(600, 700), c(800, 400), c(800, 150))) %>%   set_range(time = 300, polygon = list(     c(400, 0), c(1000, 0), c(1000, 600), c(900, 400), c(800, 250),     c(600, 100), c(500, 50))   )  # population ranges can expand by a given distance in all directions pop2 <- expand_range(pop2, by = 200, start = 50, end = 150, snapshots = 3)  # we can check the positions of all populations interactively by plotting their # ranges together on a single map plot_map(pop1, pop2, pop3)   # gene flow events --------------------------------------------------------  # individual gene flow events can be saved to a list gf <- list(   gene_flow(from = pop1, to = pop3, start = 150, end = 200, rate = 0.15),   gene_flow(from = pop1, to = pop2, start = 300, end = 330, rate = 0.25) ) #> Warning: The argument `rate` is about to be deprecated because of its confusing #> naming and behavior. If you want to specify the rate of migration per #> unit of time, please use the new argument `migration_rate`. If you want #> to specify the total amount of ancestry which the `to` population should #> received from the `from` population, use the new argument `proportion` #> (this corresponds to the original interpretation of the deprecated `rate` #> argument, and a simple replacement of `rate` with `proportion` will thus #> retain the original meaning of your code all). #> Warning: The argument `rate` is about to be deprecated because of its confusing #> naming and behavior. If you want to specify the rate of migration per #> unit of time, please use the new argument `migration_rate`. If you want #> to specify the total amount of ancestry which the `to` population should #> received from the `from` population, use the new argument `proportion` #> (this corresponds to the original interpretation of the deprecated `rate` #> argument, and a simple replacement of `rate` with `proportion` will thus #> retain the original meaning of your code all).  # compilation -------------------------------------------------------------  # compile model components in a serialized form to dist, returning a single # slendr model object (in practice, the resolution should be smaller) model <- compile_model(   populations = list(pop1, pop2, pop3), generation_time = 1,   resolution = 100, simulation_length = 500,   competition = 5, mating = 5, dispersal = 1 )"},{"path":"https://bodkan.net/slendr/reference/schedule_sampling.html","id":null,"dir":"Reference","previous_headings":"","what":"Define sampling events for a given set of populations — schedule_sampling","title":"Define sampling events for a given set of populations — schedule_sampling","text":"Schedule sampling events specified times , optionally, given set locations landscape","code":""},{"path":"https://bodkan.net/slendr/reference/schedule_sampling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define sampling events for a given set of populations — schedule_sampling","text":"","code":"schedule_sampling(model, times, ..., locations = NULL, strict = FALSE)"},{"path":"https://bodkan.net/slendr/reference/schedule_sampling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define sampling events for a given set of populations — schedule_sampling","text":"model Object class slendr_model times Integer vector times (model time units) schedule remembering individuals tree-sequence ... Lists two elements (slendr_pop population object-<number individuals sample), representing populations many individuals remembered times given times locations List vector pairs, defining two-dimensional coordinates locations closest number individuals given populations sampled. NULL (default), individuals sampled randomly throughout spatial boundary. strict occurence population present given time result error? Default FALSE, meaning invalid sampling times populations quietly ignored.","code":""},{"path":"https://bodkan.net/slendr/reference/schedule_sampling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define sampling events for a given set of populations — schedule_sampling","text":"Data frame three columns: time sampling, population sample , many individuals sample","code":""},{"path":"https://bodkan.net/slendr/reference/schedule_sampling.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Define sampling events for a given set of populations — schedule_sampling","text":"times locations given, sampling scheduled specified location given time-point. Note time-, interest simplicity, sanity checks performed locations given except restriction sampling points must fall within bounding box around simulated world map. , slendr simply instruct SLiM backend script sample individuals close sampling points given possible, regardless whether points lie within population spatial boundary particular moment time. Optionally, name single sample population can given, replace generic format \"\\{population\\}_\\{number\\}\" name. See example detail.","code":""},{"path":"https://bodkan.net/slendr/reference/schedule_sampling.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define sampling events for a given set of populations — schedule_sampling","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence path <- system.file(\"extdata/models/introgression\", package = \"slendr\") model <- read_model(path)  # afr, eur, and nea objects would normally be created before slendr model # compilation, but here we take them out of the model object already compiled for # this example (in a standard slendr simulation pipeline, this wouldn't be necessary) afr <- model$populations[[\"AFR\"]] eur <- model$populations[[\"EUR\"]] nea <- model$populations[[\"NEA\"]]  # schedule the recording of 10 African and 100 European individuals from a # given model at 20 ky, 10 ky, 5ky ago and at present-day (time 0) schedule_amh <- schedule_sampling(   model, times = c(20000, 10000, 5000, 0),   list(afr, 10), list(eur, 100) ) # schedule the recording of the Vindija Neanderthal genome schedule_nea <- schedule_sampling(model, times = 40000, list(nea, 1, \"Vindija\"))  # the result of `schedule_sampling` is a simple data frame (note that the locations # of sampling locations have `NA` values because the model is non-spatial) schedule <- rbind(schedule_amh, schedule_nea) schedule #> # A tibble: 9 × 8 #>    time pop       n name    y_orig x_orig y     x     #>   <int> <chr> <int> <chr>   <lgl>  <lgl>  <lgl> <lgl> #> 1     0 AFR      10 NA      NA     NA     NA    NA    #> 2     0 EUR     100 NA      NA     NA     NA    NA    #> 3  5000 AFR      10 NA      NA     NA     NA    NA    #> 4  5000 EUR     100 NA      NA     NA     NA    NA    #> 5 10000 AFR      10 NA      NA     NA     NA    NA    #> 6 10000 EUR     100 NA      NA     NA     NA    NA    #> 7 20000 AFR      10 NA      NA     NA     NA    NA    #> 8 20000 EUR     100 NA      NA     NA     NA    NA    #> 9 40000 NEA       1 Vindija NA     NA     NA    NA     # simulate a tree sequence ts <- msprime(model, sequence_length = 1e6, recombination_rate = 1e-8, samples = schedule)  # inspect the recorded table of samples ts_samples(ts) #> # A tibble: 441 × 3 #>    name     time pop   #>    <chr>   <dbl> <chr> #>  1 Vindija 40000 NEA   #>  2 AFR_1   20000 AFR   #>  3 AFR_2   20000 AFR   #>  4 AFR_3   20000 AFR   #>  5 AFR_4   20000 AFR   #>  6 AFR_5   20000 AFR   #>  7 AFR_6   20000 AFR   #>  8 AFR_7   20000 AFR   #>  9 AFR_8   20000 AFR   #> 10 AFR_9   20000 AFR   #> # ℹ 431 more rows"},{"path":"https://bodkan.net/slendr/reference/set_dispersal.html","id":null,"dir":"Reference","previous_headings":"","what":"Change dispersal parameters — set_dispersal","title":"Change dispersal parameters — set_dispersal","text":"Changes either competition interactive distance, mating choice distance, dispersal offspring parent","code":""},{"path":"https://bodkan.net/slendr/reference/set_dispersal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Change dispersal parameters — set_dispersal","text":"","code":"set_dispersal(   pop,   time,   competition = NA,   mating = NA,   dispersal = NA,   dispersal_fun = NULL )"},{"path":"https://bodkan.net/slendr/reference/set_dispersal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Change dispersal parameters — set_dispersal","text":"pop Object class slendr_pop time Time population size change competition, mating Maximum spatial competition mating choice distance dispersal Standard deviation normal distribution distance offspring disperses parent dispersal_fun Distribution function governing dispersal offspring. One \"normal\", \"uniform\", \"cauchy\", \"exponential\", \"brownian\" (vertical horizontal displacements drawn normal distribution independently).","code":""},{"path":"https://bodkan.net/slendr/reference/set_dispersal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Change dispersal parameters — set_dispersal","text":"Object class slendr_pop, contains population parameters name, time appearance simulation, parent population (), spatial parameters map spatial boundary.","code":""},{"path":"https://bodkan.net/slendr/reference/set_dispersal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Change dispersal parameters — set_dispersal","text":"","code":"# spatial definitions -----------------------------------------------------  # create a blank abstract world 1000x1000 distance units in size map <- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = \"blank\")  # create a circular population with the center of a population boundary at # [200, 800] and a radius of 100 distance units, 1000 individuals at time 1 # occupying a map just specified pop1 <- population(\"pop1\", N = 1000, time = 1,                    map = map, center = c(200, 800), radius = 100)  # printing a population object to a console shows a brief summary pop1 #> slendr 'population' object  #> --------------------------  #> name: pop1  #> habitat: terrestrial #>  #> number of spatial maps: 1  #> map: abstract spatial landscape with custom features #> stays until the end of the simulation #>  #> population history overview: #>   - time 1: created as an ancestral population (N = 1000)  # create another population occupying a polygon range, splitting from pop1 # at a given time point (note that specifying a map is not necessary because # it is \"inherited\" from the parent) pop2 <- population(\"pop2\", N = 100, time = 50, parent = pop1,                         polygon = list(c(100, 100), c(320, 30), c(500, 200),                                   c(500, 400), c(300, 450), c(100, 400)))  pop3 <- population(\"pop3\", N = 200, time = 80, parent = pop2,                    center = c(800, 800), radius = 200)  # move \"pop1\" to another location along a specified trajectory and saved the # resulting object to the same variable (the number of intermediate spatial # snapshots can be also determined automatically by leaving out the # `snapshots = ` argument) pop1_moved <- move(pop1, start = 100, end = 200, snapshots = 6,                    trajectory = list(c(600, 820), c(800, 400), c(800, 150))) pop1_moved #> slendr 'population' object  #> --------------------------  #> name: pop1  #> habitat: terrestrial #>  #> number of spatial maps: 10  #> map: abstract spatial landscape with custom features #> stays until the end of the simulation #>  #> population history overview: #>   - time 1: created as an ancestral population (N = 1000) #>   - time 100-200: movement across a landscape  # many slendr functions are pipe-friendly, making it possible to construct # pipelines which construct entire history of a population pop1 <- population(\"pop1\", N = 1000, time = 1,                    map = map, center = c(200, 800), radius = 100) %>%   move(start = 100, end = 200, snapshots = 6,        trajectory = list(c(400, 800), c(600, 700), c(800, 400), c(800, 150))) %>%   set_range(time = 300, polygon = list(     c(400, 0), c(1000, 0), c(1000, 600), c(900, 400), c(800, 250),     c(600, 100), c(500, 50))   )  # population ranges can expand by a given distance in all directions pop2 <- expand_range(pop2, by = 200, start = 50, end = 150, snapshots = 3)  # we can check the positions of all populations interactively by plotting their # ranges together on a single map plot_map(pop1, pop2, pop3)   # gene flow events --------------------------------------------------------  # individual gene flow events can be saved to a list gf <- list(   gene_flow(from = pop1, to = pop3, start = 150, end = 200, rate = 0.15),   gene_flow(from = pop1, to = pop2, start = 300, end = 330, rate = 0.25) ) #> Warning: The argument `rate` is about to be deprecated because of its confusing #> naming and behavior. If you want to specify the rate of migration per #> unit of time, please use the new argument `migration_rate`. If you want #> to specify the total amount of ancestry which the `to` population should #> received from the `from` population, use the new argument `proportion` #> (this corresponds to the original interpretation of the deprecated `rate` #> argument, and a simple replacement of `rate` with `proportion` will thus #> retain the original meaning of your code all). #> Warning: The argument `rate` is about to be deprecated because of its confusing #> naming and behavior. If you want to specify the rate of migration per #> unit of time, please use the new argument `migration_rate`. If you want #> to specify the total amount of ancestry which the `to` population should #> received from the `from` population, use the new argument `proportion` #> (this corresponds to the original interpretation of the deprecated `rate` #> argument, and a simple replacement of `rate` with `proportion` will thus #> retain the original meaning of your code all).  # compilation -------------------------------------------------------------  # compile model components in a serialized form to dist, returning a single # slendr model object (in practice, the resolution should be smaller) model <- compile_model(   populations = list(pop1, pop2, pop3), generation_time = 1,   resolution = 100, simulation_length = 500,   competition = 5, mating = 5, dispersal = 1 )"},{"path":"https://bodkan.net/slendr/reference/set_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Update the population range — set_range","title":"Update the population range — set_range","text":"function allows manual control spatial map changes addition expand move functions","code":""},{"path":"https://bodkan.net/slendr/reference/set_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update the population range — set_range","text":"","code":"set_range(   pop,   time,   center = NULL,   radius = NULL,   polygon = NULL,   lock = FALSE )"},{"path":"https://bodkan.net/slendr/reference/set_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update the population range — set_range","text":"pop Object class slendr_pop time Time change center Two-dimensional vector specifying center circular range radius Radius circular range polygon List vector pairs, defining corners polygon range (see also region argument) geographic region class slendr_region polygon coordinates extracted lock Maintain density individuals. FALSE (default), number individuals population change. TRUE, number individuals simulated changed (increased decreased) appropriately, match new population range area.","code":""},{"path":"https://bodkan.net/slendr/reference/set_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update the population range — set_range","text":"Object class slendr_pop, contains population parameters name, time appearance simulation, parent population (), spatial parameters map spatial boundary.","code":""},{"path":"https://bodkan.net/slendr/reference/set_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update the population range — set_range","text":"","code":"# spatial definitions -----------------------------------------------------  # create a blank abstract world 1000x1000 distance units in size map <- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = \"blank\")  # create a circular population with the center of a population boundary at # [200, 800] and a radius of 100 distance units, 1000 individuals at time 1 # occupying a map just specified pop1 <- population(\"pop1\", N = 1000, time = 1,                    map = map, center = c(200, 800), radius = 100)  # printing a population object to a console shows a brief summary pop1 #> slendr 'population' object  #> --------------------------  #> name: pop1  #> habitat: terrestrial #>  #> number of spatial maps: 1  #> map: abstract spatial landscape with custom features #> stays until the end of the simulation #>  #> population history overview: #>   - time 1: created as an ancestral population (N = 1000)  # create another population occupying a polygon range, splitting from pop1 # at a given time point (note that specifying a map is not necessary because # it is \"inherited\" from the parent) pop2 <- population(\"pop2\", N = 100, time = 50, parent = pop1,                         polygon = list(c(100, 100), c(320, 30), c(500, 200),                                   c(500, 400), c(300, 450), c(100, 400)))  pop3 <- population(\"pop3\", N = 200, time = 80, parent = pop2,                    center = c(800, 800), radius = 200)  # move \"pop1\" to another location along a specified trajectory and saved the # resulting object to the same variable (the number of intermediate spatial # snapshots can be also determined automatically by leaving out the # `snapshots = ` argument) pop1_moved <- move(pop1, start = 100, end = 200, snapshots = 6,                    trajectory = list(c(600, 820), c(800, 400), c(800, 150))) pop1_moved #> slendr 'population' object  #> --------------------------  #> name: pop1  #> habitat: terrestrial #>  #> number of spatial maps: 10  #> map: abstract spatial landscape with custom features #> stays until the end of the simulation #>  #> population history overview: #>   - time 1: created as an ancestral population (N = 1000) #>   - time 100-200: movement across a landscape  # many slendr functions are pipe-friendly, making it possible to construct # pipelines which construct entire history of a population pop1 <- population(\"pop1\", N = 1000, time = 1,                    map = map, center = c(200, 800), radius = 100) %>%   move(start = 100, end = 200, snapshots = 6,        trajectory = list(c(400, 800), c(600, 700), c(800, 400), c(800, 150))) %>%   set_range(time = 300, polygon = list(     c(400, 0), c(1000, 0), c(1000, 600), c(900, 400), c(800, 250),     c(600, 100), c(500, 50))   )  # population ranges can expand by a given distance in all directions pop2 <- expand_range(pop2, by = 200, start = 50, end = 150, snapshots = 3)  # we can check the positions of all populations interactively by plotting their # ranges together on a single map plot_map(pop1, pop2, pop3)   # gene flow events --------------------------------------------------------  # individual gene flow events can be saved to a list gf <- list(   gene_flow(from = pop1, to = pop3, start = 150, end = 200, rate = 0.15),   gene_flow(from = pop1, to = pop2, start = 300, end = 330, rate = 0.25) ) #> Warning: The argument `rate` is about to be deprecated because of its confusing #> naming and behavior. If you want to specify the rate of migration per #> unit of time, please use the new argument `migration_rate`. If you want #> to specify the total amount of ancestry which the `to` population should #> received from the `from` population, use the new argument `proportion` #> (this corresponds to the original interpretation of the deprecated `rate` #> argument, and a simple replacement of `rate` with `proportion` will thus #> retain the original meaning of your code all). #> Warning: The argument `rate` is about to be deprecated because of its confusing #> naming and behavior. If you want to specify the rate of migration per #> unit of time, please use the new argument `migration_rate`. If you want #> to specify the total amount of ancestry which the `to` population should #> received from the `from` population, use the new argument `proportion` #> (this corresponds to the original interpretation of the deprecated `rate` #> argument, and a simple replacement of `rate` with `proportion` will thus #> retain the original meaning of your code all).  # compilation -------------------------------------------------------------  # compile model components in a serialized form to dist, returning a single # slendr model object (in practice, the resolution should be smaller) model <- compile_model(   populations = list(pop1, pop2, pop3), generation_time = 1,   resolution = 100, simulation_length = 500,   competition = 5, mating = 5, dispersal = 1 )"},{"path":"https://bodkan.net/slendr/reference/setup_env.html","id":null,"dir":"Reference","previous_headings":"","what":"Setup a dedicated Python virtual environment for slendr — setup_env","title":"Setup a dedicated Python virtual environment for slendr — setup_env","text":"function automatically download Python miniconda distribution dedicated R-Python interface. also create slendr-specific Python environment required Python dependencies.","code":""},{"path":"https://bodkan.net/slendr/reference/setup_env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Setup a dedicated Python virtual environment for slendr — setup_env","text":"","code":"setup_env(quiet = FALSE, agree = FALSE, pip = FALSE)"},{"path":"https://bodkan.net/slendr/reference/setup_env.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Setup a dedicated Python virtual environment for slendr — setup_env","text":"quiet informative messages printed console? Default FALSE. agree Automatically agree questions? pip pip used instead conda installing slendr's Python dependencies?","code":""},{"path":"https://bodkan.net/slendr/reference/setup_env.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Setup a dedicated Python virtual environment for slendr — setup_env","text":"return value, called side effects","code":""},{"path":"https://bodkan.net/slendr/reference/shrink_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Shrink the population range — shrink_range","title":"Shrink the population range — shrink_range","text":"Shrinks spatial population range specified distance given time-window","code":""},{"path":"https://bodkan.net/slendr/reference/shrink_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shrink the population range — shrink_range","text":"","code":"shrink_range(   pop,   by,   end,   start,   overlap = 0.8,   snapshots = NULL,   lock = FALSE,   verbose = TRUE )"},{"path":"https://bodkan.net/slendr/reference/shrink_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shrink the population range — shrink_range","text":"pop Object class slendr_pop many units distance shrink ? start, end boundary shrinking start/end? overlap Minimum overlap subsequent spatial boundaries snapshots number intermediate snapshots (overrides overlap parameter) lock Maintain density individuals. FALSE (default), number individuals population change. TRUE, number individuals simulated changed (increased decreased) appropriately, match new population range area. verbose Report progress generating intermediate spatial boundaries?","code":""},{"path":"https://bodkan.net/slendr/reference/shrink_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shrink the population range — shrink_range","text":"Object class slendr_pop, contains population parameters name, time appearance simulation, parent population (), spatial parameters map spatial boundary.","code":""},{"path":"https://bodkan.net/slendr/reference/shrink_range.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Shrink the population range — shrink_range","text":"Note slendr models accomodate SLiM msprime back ends, population sizes split times rounded nearest integer value.","code":""},{"path":"https://bodkan.net/slendr/reference/shrink_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Shrink the population range — shrink_range","text":"","code":"# spatial definitions -----------------------------------------------------  # create a blank abstract world 1000x1000 distance units in size map <- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = \"blank\")  # create a circular population with the center of a population boundary at # [200, 800] and a radius of 100 distance units, 1000 individuals at time 1 # occupying a map just specified pop1 <- population(\"pop1\", N = 1000, time = 1,                    map = map, center = c(200, 800), radius = 100)  # printing a population object to a console shows a brief summary pop1 #> slendr 'population' object  #> --------------------------  #> name: pop1  #> habitat: terrestrial #>  #> number of spatial maps: 1  #> map: abstract spatial landscape with custom features #> stays until the end of the simulation #>  #> population history overview: #>   - time 1: created as an ancestral population (N = 1000)  # create another population occupying a polygon range, splitting from pop1 # at a given time point (note that specifying a map is not necessary because # it is \"inherited\" from the parent) pop2 <- population(\"pop2\", N = 100, time = 50, parent = pop1,                         polygon = list(c(100, 100), c(320, 30), c(500, 200),                                   c(500, 400), c(300, 450), c(100, 400)))  pop3 <- population(\"pop3\", N = 200, time = 80, parent = pop2,                    center = c(800, 800), radius = 200)  # move \"pop1\" to another location along a specified trajectory and saved the # resulting object to the same variable (the number of intermediate spatial # snapshots can be also determined automatically by leaving out the # `snapshots = ` argument) pop1_moved <- move(pop1, start = 100, end = 200, snapshots = 6,                    trajectory = list(c(600, 820), c(800, 400), c(800, 150))) pop1_moved #> slendr 'population' object  #> --------------------------  #> name: pop1  #> habitat: terrestrial #>  #> number of spatial maps: 10  #> map: abstract spatial landscape with custom features #> stays until the end of the simulation #>  #> population history overview: #>   - time 1: created as an ancestral population (N = 1000) #>   - time 100-200: movement across a landscape  # many slendr functions are pipe-friendly, making it possible to construct # pipelines which construct entire history of a population pop1 <- population(\"pop1\", N = 1000, time = 1,                    map = map, center = c(200, 800), radius = 100) %>%   move(start = 100, end = 200, snapshots = 6,        trajectory = list(c(400, 800), c(600, 700), c(800, 400), c(800, 150))) %>%   set_range(time = 300, polygon = list(     c(400, 0), c(1000, 0), c(1000, 600), c(900, 400), c(800, 250),     c(600, 100), c(500, 50))   )  # population ranges can expand by a given distance in all directions pop2 <- expand_range(pop2, by = 200, start = 50, end = 150, snapshots = 3)  # we can check the positions of all populations interactively by plotting their # ranges together on a single map plot_map(pop1, pop2, pop3)   # gene flow events --------------------------------------------------------  # individual gene flow events can be saved to a list gf <- list(   gene_flow(from = pop1, to = pop3, start = 150, end = 200, rate = 0.15),   gene_flow(from = pop1, to = pop2, start = 300, end = 330, rate = 0.25) ) #> Warning: The argument `rate` is about to be deprecated because of its confusing #> naming and behavior. If you want to specify the rate of migration per #> unit of time, please use the new argument `migration_rate`. If you want #> to specify the total amount of ancestry which the `to` population should #> received from the `from` population, use the new argument `proportion` #> (this corresponds to the original interpretation of the deprecated `rate` #> argument, and a simple replacement of `rate` with `proportion` will thus #> retain the original meaning of your code all). #> Warning: The argument `rate` is about to be deprecated because of its confusing #> naming and behavior. If you want to specify the rate of migration per #> unit of time, please use the new argument `migration_rate`. If you want #> to specify the total amount of ancestry which the `to` population should #> received from the `from` population, use the new argument `proportion` #> (this corresponds to the original interpretation of the deprecated `rate` #> argument, and a simple replacement of `rate` with `proportion` will thus #> retain the original meaning of your code all).  # compilation -------------------------------------------------------------  # compile model components in a serialized form to dist, returning a single # slendr model object (in practice, the resolution should be smaller) model <- compile_model(   populations = list(pop1, pop2, pop3), generation_time = 1,   resolution = 100, simulation_length = 500,   competition = 5, mating = 5, dispersal = 1 )"},{"path":"https://bodkan.net/slendr/reference/slendr.html","id":null,"dir":"Reference","previous_headings":"","what":"A Simulation Framework for Spatiotemporal Population Genetics — slendr","title":"A Simulation Framework for Spatiotemporal Population Genetics — slendr","text":"framework simulating spatially explicit genomic data leverages real cartographic information programmatic visual encoding spatiotemporal population dynamics real geographic landscapes. Population genetic models automatically executed 'SLiM' software behind scenes, using custom built-simulation 'SLiM' script. Additionally, fully abstract spatial models tied specific geographic location supported, users can also simulate data standard, non-spatial, random-mating models. can simulated either 'SLiM' built-back-end script, using efficient coalescent population genetics simulator 'msprime' custom-built 'Python' script bundled R package. Simulated genomic data saved tree-sequence format can loaded, manipulated, summarised using tree-sequence functionality via R interface 'Python' module 'tskit'. Complete model configuration, simulation analysis pipelines can therefore constructed without need leave R environment, eliminating friction disparate tools population genetic simulations data analysis.","code":""},{"path":"https://bodkan.net/slendr/reference/slendr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A Simulation Framework for Spatiotemporal Population Genetics — slendr","text":"can find installation instructions, reference manual, tutorials https://bodkan.net/slendr.","code":""},{"path":[]},{"path":"https://bodkan.net/slendr/reference/slendr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"A Simulation Framework for Spatiotemporal Population Genetics — slendr","text":"Maintainer: Martin Petr contact@bodkan.net (ORCID)","code":""},{"path":"https://bodkan.net/slendr/reference/slim.html","id":null,"dir":"Reference","previous_headings":"","what":"Run a slendr model in SLiM — slim","title":"Run a slendr model in SLiM — slim","text":"function execute SLiM script generated compile function compilation slendr demographic model.","code":""},{"path":"https://bodkan.net/slendr/reference/slim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run a slendr model in SLiM — slim","text":"","code":"slim(   model,   sequence_length,   recombination_rate,   samples = NULL,   ts = TRUE,   path = NULL,   random_seed = NULL,   method = c(\"batch\", \"gui\"),   verbose = FALSE,   run = TRUE,   slim_path = NULL,   burnin = 0,   max_attempts = 1,   spatial = !is.null(model$world),   coalescent_only = TRUE,   locations = NULL )"},{"path":"https://bodkan.net/slendr/reference/slim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run a slendr model in SLiM — slim","text":"model Model object created compile function sequence_length Total length simulated sequence (base-pairs) recombination_rate Recombination rate simulated sequence (recombinations per basepair per generation) samples data frame times given number individuals remembered tree-sequence (see schedule_sampling function can generate sampling schedule correct format). missing, individuals present end simulation recorded final tree-sequence file. ts tree sequence simulated model? path Path directory simulation result files saved. NULL, directory automatically created temporary directory. TRUE, path also returned function. string given, assumed path directory simulation results saved. case, function return path invisibly. Note tree-sequence file simulated (along files, potentially), tree-sequence file (named 'slim.trees' default) explicitly loaded using ts_read(). random_seed Random seed (NULL, seed generated 0 maximum integer number available) method run script? (\"gui\" - open SLiMgui, \"batch\" - run command line) verbose Write log information SLiM run console (default FALSE)? run SLiM engine run? FALSE, command line SLiM command printed (returned invisibly character vector) executed. slim_path Path appropriate SLiM binary (useful slim binary $PATH). Note argument must specified function run Windows. burnin Length burnin (model's time units, .e. years) max_attempts many attempts made place offspring near one parents? Serves prevent infinite loops SLiM backend. Default value 1. spatial model executed spatial mode? default, world map specified model definition, simulation proceed spatial mode. coalescent_only initializeTreeSeq(retainCoalescentOnly =   <...>) set TRUE (default) FALSE? See \"retainCoalescentOnly\" SLiM manual detail. locations NULL, locations saved. Otherwise, path file locations individual throughout simulation saved (likely use animate_model).","code":""},{"path":"https://bodkan.net/slendr/reference/slim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run a slendr model in SLiM — slim","text":"tree-sequence object loaded via Python-R reticulate interface function ts_read (internally represented Python object tskit.trees.TreeSequence). path argument set, specifying directory results saved, function return path single-element character vector.","code":""},{"path":"https://bodkan.net/slendr/reference/slim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run a slendr model in SLiM — slim","text":"arguments sequence_length recombination_rate can omitted slendr models utilizing customized initialization genomic architecture. cases, users may either provide hard-coded values directly SLiM's initializeGenomicElement() initializeRecombinationRate() functions utilize slendr's templating functionality provided substitute() function. ts = TRUE, returning value function depends whether path argument set. user provide path output files saved, path returned (invisibly). mostly intended support simulations customized user models. path set user, assumed tree-sequence object desired sole return value function (ts = TRUE) automatically loaded simulation finishes, (ts = FALSE) customized files produced simulation, user loading files (path needed).","code":""},{"path":"https://bodkan.net/slendr/reference/slim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run a slendr model in SLiM — slim","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # afr and eur objects would normally be created before slendr model compilation, # but here we take them out of the model object already compiled for this # example (in a standard slendr simulation pipeline, this wouldn't be necessary) afr <- model$populations[[\"AFR\"]] eur <- model$populations[[\"EUR\"]] chimp <- model$populations[[\"CH\"]]  # schedule the sampling of a couple of ancient and present-day individuals # given model at 20 ky, 10 ky, 5ky ago and at present-day (time 0) modern_samples <- schedule_sampling(model, times = 0, list(afr, 5), list(eur, 5), list(chimp, 1)) ancient_samples <- schedule_sampling(model, times = c(30000, 20000, 10000), list(eur, 1))  # sampling schedules are just data frames and can be merged easily samples <- rbind(modern_samples, ancient_samples)  # run a simulation using the SLiM back end from a compiled slendr model object and return # a tree-sequence object as a result ts <- slim(model, sequence_length = 1e5, recombination_rate = 0, samples = samples)  # simulated tree-sequence object can be saved to a file using ts_write()... ts_file <- normalizePath(tempfile(fileext = \".trees\"), winslash = \"/\", mustWork = FALSE) ts_write(ts, ts_file) # ... and, at a later point, loaded by ts_read() ts <- ts_read(ts_file, model)  ts #> ╔═══════════════════════╗ #> ║TreeSequence           ║ #> ╠═══════════════╤═══════╣ #> ║Trees          │      1║ #> ╟───────────────┼───────╢ #> ║Sequence Length│100,000║ #> ╟───────────────┼───────╢ #> ║Time Units     │  ticks║ #> ╟───────────────┼───────╢ #> ║Sample Nodes   │ 10,046║ #> ╟───────────────┼───────╢ #> ║Total Size     │2.6 MiB║ #> ╚═══════════════╧═══════╝ #> ╔═══════════╤══════╤═════════╤════════════╗ #> ║Table      │Rows  │Size     │Has Metadata║ #> ╠═══════════╪══════╪═════════╪════════════╣ #> ║Edges      │18,368│574.0 KiB│          No║ #> ╟───────────┼──────┼─────────┼────────────╢ #> ║Individuals│12,885│  1.2 MiB│         Yes║ #> ╟───────────┼──────┼─────────┼────────────╢ #> ║Migrations │     0│  8 Bytes│          No║ #> ╟───────────┼──────┼─────────┼────────────╢ #> ║Mutations  │     0│  1.2 KiB│          No║ #> ╟───────────┼──────┼─────────┼────────────╢ #> ║Nodes      │18,369│665.3 KiB│         Yes║ #> ╟───────────┼──────┼─────────┼────────────╢ #> ║Populations│     4│  2.5 KiB│         Yes║ #> ╟───────────┼──────┼─────────┼────────────╢ #> ║Provenances│     1│ 43.7 KiB│          No║ #> ╟───────────┼──────┼─────────┼────────────╢ #> ║Sites      │     0│ 16 Bytes│          No║ #> ╚═══════════╧══════╧═════════╧════════════╝ #>"},{"path":"https://bodkan.net/slendr/reference/substitute_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Substitute values of parameters in a SLiM extension template — substitute_values","title":"Substitute values of parameters in a SLiM extension template — substitute_values","text":"Substitute values templated {{parameters}} given SLiM extension template","code":""},{"path":"https://bodkan.net/slendr/reference/substitute_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Substitute values of parameters in a SLiM extension template — substitute_values","text":"","code":"substitute_values(template, ...)"},{"path":"https://bodkan.net/slendr/reference/substitute_values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Substitute values of parameters in a SLiM extension template — substitute_values","text":"template Either path extension script file, string containing entire SLiM extension code ... Named function arguments interpreted key=value pairs used argument substitution","code":""},{"path":"https://bodkan.net/slendr/reference/substitute_values.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Substitute values of parameters in a SLiM extension template — substitute_values","text":"Path file saved extension script containing substituted values","code":""},{"path":"https://bodkan.net/slendr/reference/substitute_values.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Substitute values of parameters in a SLiM extension template — substitute_values","text":"file multi-line string given template contains parameters specified {{param}} \"param\" can arbitrary variable name, function substitutes templated {{parameter}} given values. modified template used extend built-slendr SLiM script, allowing customization default behavior (commonly replacing assumption neutrality non-neutral scenarios, simulations natural selection).","code":""},{"path":"https://bodkan.net/slendr/reference/subtract.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate the difference between two slendr objects — subtract","title":"Generate the difference between two slendr objects — subtract","text":"Generate difference two slendr objects","code":""},{"path":"https://bodkan.net/slendr/reference/subtract.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate the difference between two slendr objects — subtract","text":"","code":"subtract(x, y, name = NULL)"},{"path":"https://bodkan.net/slendr/reference/subtract.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate the difference between two slendr objects — subtract","text":"x Object class slendr y Object class slendr name Optional name resulting geographic region. missing, name constructed function arguments.","code":""},{"path":"https://bodkan.net/slendr/reference/subtract.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate the difference between two slendr objects — subtract","text":"Object class slendr_region encodes standard spatial object class sf several additional attributes (importantly corresponding slendr_map object, applicable).","code":""},{"path":"https://bodkan.net/slendr/reference/summary.slendr_nodes.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise the contents of a ts_nodes result — summary.slendr_nodes","title":"Summarise the contents of a ts_nodes result — summary.slendr_nodes","text":"Summarise contents ts_nodes result","code":""},{"path":"https://bodkan.net/slendr/reference/summary.slendr_nodes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise the contents of a ts_nodes result — summary.slendr_nodes","text":"","code":"# S3 method for class 'slendr_nodes' summary(object, ...)"},{"path":"https://bodkan.net/slendr/reference/summary.slendr_nodes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise the contents of a ts_nodes result — summary.slendr_nodes","text":"object Data frame produced function ts_nodes ... Additional formal arguments summary method (unused )","code":""},{"path":"https://bodkan.net/slendr/reference/summary.slendr_nodes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise the contents of a ts_nodes result — summary.slendr_nodes","text":"Used output terminal","code":""},{"path":"https://bodkan.net/slendr/reference/ts_afs.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the allele frequency spectrum (AFS) — ts_afs","title":"Compute the allele frequency spectrum (AFS) — ts_afs","text":"function computes AFS respect given set individuals nodes.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_afs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the allele frequency spectrum (AFS) — ts_afs","text":"","code":"ts_afs(   ts,   sample_sets = NULL,   mode = c(\"site\", \"branch\", \"node\"),   windows = NULL,   span_normalise = FALSE,   polarised = TRUE )"},{"path":"https://bodkan.net/slendr/reference/ts_afs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the allele frequency spectrum (AFS) — ts_afs","text":"ts Tree sequence object class slendr_ts sample_sets list (optionally named list) character vectors individual names (one vector per set). NULL, allele frequency spectrum individuals tree sequence computed. mode mode calculation (\"sites\" \"branch\") windows Coordinates breakpoints windows. first coordinate (0) last coordinate (equal ts$sequence_length) added automatically) span_normalise Argument passed tskit's allele_frequency_spectrum method polarised TRUE (default) allele frequency spectrum folded (.e. counts assume knowledge allele ancestral, derived, known simulation)","code":""},{"path":"https://bodkan.net/slendr/reference/ts_afs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the allele frequency spectrum (AFS) — ts_afs","text":"Allele frequency spectrum values given sample set. Note contents first last elements AFS might surprise . Read links description detail tskit handles things.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_afs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute the allele frequency spectrum (AFS) — ts_afs","text":"information format result dimensions, particular interpretation first last element AFS, please see tskit manual https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.allele_frequency_spectrum example section dedicated AFS https://tskit.dev/tutorials/analysing_tree_sequences.html#zeroth--final-entries---afs.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_afs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the allele frequency spectrum (AFS) — ts_afs","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk ts <- ts_read(slendr_ts, model) %>% ts_mutate(mutation_rate = 1e-8, random_seed = 42)  samples <- ts_samples(ts) %>% .[.$pop %in% c(\"AFR\", \"EUR\"), ]  # compute AFS for the given set of individuals ts_afs(ts, sample_sets = list(samples$name)) #>  [1] 1018   73   21    7    0    6    2    0    0    0   13    0    0    0    0 #> [16]    4    0    4    6   16  955"},{"path":"https://bodkan.net/slendr/reference/ts_ancestors.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract (spatio-)temporal ancestral history for given nodes/individuals — ts_ancestors","title":"Extract (spatio-)temporal ancestral history for given nodes/individuals — ts_ancestors","text":"Extract (spatio-)temporal ancestral history given nodes/individuals","code":""},{"path":"https://bodkan.net/slendr/reference/ts_ancestors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract (spatio-)temporal ancestral history for given nodes/individuals — ts_ancestors","text":"","code":"ts_ancestors(ts, x, verbose = FALSE, complete = TRUE)"},{"path":"https://bodkan.net/slendr/reference/ts_ancestors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract (spatio-)temporal ancestral history for given nodes/individuals — ts_ancestors","text":"ts Tree sequence object class slendr_ts x Either individual name integer node ID verbose Report progress ancestry path generation? complete every individual tree sequence need complete metadata recorded? TRUE, individuals/nodes complete metadata included reconstruction ancestral relationships. instance, nodes added coalescent recapitation phase included spatial information associated .","code":""},{"path":"https://bodkan.net/slendr/reference/ts_ancestors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract (spatio-)temporal ancestral history for given nodes/individuals — ts_ancestors","text":"table ancestral nodes given tree-sequence node way root tree sequence","code":""},{"path":"https://bodkan.net/slendr/reference/ts_ancestors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract (spatio-)temporal ancestral history for given nodes/individuals — ts_ancestors","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk ts <- ts_read(slendr_ts, model)  # find the complete ancestry information for a given individual ts_ancestors(ts, \"EUR_1\", verbose = TRUE) #> Collecting ancestors of EUR_1 [1/1]... #>  #> Generating data about spatial relationships of nodes... #> # A tibble: 207 × 12 #>    name  pop   node_id level child_id parent_id child_time parent_time child_pop #>    <chr> <fct>   <int> <fct>    <int>     <int>      <dbl>       <dbl> <fct>     #>  1 EUR_1 EUR        16 1           16        33          0         500 EUR       #>  2 EUR_1 EUR        16 2           33        43        500       21830 EUR       #>  3 EUR_1 EUR        16 2           33        47        500       28730 EUR       #>  4 EUR_1 EUR        16 2           33        49        500       30380 EUR       #>  5 EUR_1 EUR        16 2           33        51        500       35360 EUR       #>  6 EUR_1 EUR        16 2           33        54        500       39380 EUR       #>  7 EUR_1 EUR        16 2           33        57        500       41510 EUR       #>  8 EUR_1 EUR        16 2           33        58        500       44810 EUR       #>  9 EUR_1 EUR        16 2           33        59        500       46040 EUR       #> 10 EUR_1 EUR        16 2           33        62        500       51680 EUR       #> # ℹ 197 more rows #> # ℹ 3 more variables: parent_pop <fct>, left_pos <dbl>, right_pos <dbl>"},{"path":"https://bodkan.net/slendr/reference/ts_coalesced.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that all trees in the tree sequence are fully coalesced — ts_coalesced","title":"Check that all trees in the tree sequence are fully coalesced — ts_coalesced","text":"Check trees tree sequence fully coalesced","code":""},{"path":"https://bodkan.net/slendr/reference/ts_coalesced.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that all trees in the tree sequence are fully coalesced — ts_coalesced","text":"","code":"ts_coalesced(ts, return_failed = FALSE)"},{"path":"https://bodkan.net/slendr/reference/ts_coalesced.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that all trees in the tree sequence are fully coalesced — ts_coalesced","text":"ts Tree sequence object class slendr_ts return_failed Report back trees failed coalescence check?","code":""},{"path":"https://bodkan.net/slendr/reference/ts_coalesced.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check that all trees in the tree sequence are fully coalesced — ts_coalesced","text":"TRUE FALSE value return_failed = FALSE, otherwise vector (tskit Python 0-based) indices trees failed coalescence test","code":""},{"path":"https://bodkan.net/slendr/reference/ts_coalesced.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check that all trees in the tree sequence are fully coalesced — ts_coalesced","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk ts <- ts_read(slendr_ts, model)  ts_coalesced(ts) # is the tree sequence fully coalesced? (TRUE or FALSE) #> [1] TRUE  # returns a vector of tree sequence segments which are not coalesced not_coalesced <- ts_coalesced(ts, return_failed = TRUE)"},{"path":"https://bodkan.net/slendr/reference/ts_descendants.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract all descendants of a given tree-sequence node — ts_descendants","title":"Extract all descendants of a given tree-sequence node — ts_descendants","text":"Extract descendants given tree-sequence node","code":""},{"path":"https://bodkan.net/slendr/reference/ts_descendants.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract all descendants of a given tree-sequence node — ts_descendants","text":"","code":"ts_descendants(ts, x, verbose = FALSE, complete = TRUE)"},{"path":"https://bodkan.net/slendr/reference/ts_descendants.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract all descendants of a given tree-sequence node — ts_descendants","text":"ts Tree sequence object class slendr_ts x integer node ID ancestral node verbose Report progress ancestry path generation? complete every individual tree sequence need complete metadata recorded? TRUE, individuals/nodes complete metadata included reconstruction ancestral relationships. instance, nodes added coalescent recapitation phase included spatial information associated .","code":""},{"path":"https://bodkan.net/slendr/reference/ts_descendants.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract all descendants of a given tree-sequence node — ts_descendants","text":"table descendant nodes given tree-sequence node way leaves tree sequence","code":""},{"path":"https://bodkan.net/slendr/reference/ts_descendants.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract all descendants of a given tree-sequence node — ts_descendants","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk ts <- ts_read(slendr_ts, model)  # find the complete descendancy information for a given individual ts_descendants(ts, x = 62, verbose = TRUE) #>  #> Generating data about spatial relationships of nodes... #> # A tibble: 4 × 12 #>   name  pop   node_id level child_id parent_id child_time parent_time child_pop #>   <chr> <fct>   <dbl> <fct>    <int>     <int>      <dbl>       <dbl> <fct>     #> 1 EUR_4 EUR        62 1           22        62          0       51680 EUR       #> 2 NA    EUR        62 1           33        62        500       51680 EUR       #> 3 EUR_1 EUR        62 2           16        33          0         500 EUR       #> 4 EUR_2 EUR        62 2           18        33          0         500 EUR       #> # ℹ 3 more variables: parent_pop <fct>, left_pos <dbl>, right_pos <dbl>"},{"path":"https://bodkan.net/slendr/reference/ts_divergence.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate pairwise divergence between sets of individuals — ts_divergence","title":"Calculate pairwise divergence between sets of individuals — ts_divergence","text":"Calculate pairwise divergence sets individuals","code":""},{"path":"https://bodkan.net/slendr/reference/ts_divergence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate pairwise divergence between sets of individuals — ts_divergence","text":"","code":"ts_divergence(   ts,   sample_sets,   mode = c(\"site\", \"branch\", \"node\"),   windows = NULL,   span_normalise = TRUE )"},{"path":"https://bodkan.net/slendr/reference/ts_divergence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate pairwise divergence between sets of individuals — ts_divergence","text":"ts Tree sequence object class slendr_ts sample_sets list (optionally named list) character vectors individual names (one vector per set) mode mode calculation (\"sites\" \"branch\") windows Coordinates breakpoints windows. first coordinate (0) last coordinate (equal ts$sequence_length) specified added automatically. span_normalise Divide result span window? Default TRUE, see tskit documentation detail.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_divergence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate pairwise divergence between sets of individuals — ts_divergence","text":"pairwise calculation, either single divergence value vector divergence values (one window)","code":""},{"path":"https://bodkan.net/slendr/reference/ts_divergence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate pairwise divergence between sets of individuals — ts_divergence","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk ts <- ts_read(slendr_ts, model) %>% ts_mutate(mutation_rate = 1e-8, random_seed = 42)  # collect sampled individuals from all populations in a list sample_sets <- ts_samples(ts) %>%   split(., .$pop) %>%   lapply(function(pop) pop$name)  # compute the divergence between individuals from each sample set (list of # individual names generated in the previous step) ts_divergence(ts, sample_sets) %>% .[order(.$divergence), ] #> # A tibble: 6 × 3 #>   x     y     divergence #>   <chr> <chr>      <dbl> #> 1 AFR   EUR    0.0000736 #> 2 EUR   NEA    0.000357  #> 3 AFR   NEA    0.000384  #> 4 CH    NEA    0.00388   #> 5 CH    EUR    0.00390   #> 6 AFR   CH     0.00390"},{"path":"https://bodkan.net/slendr/reference/ts_diversity.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate diversity in given sets of individuals — ts_diversity","title":"Calculate diversity in given sets of individuals — ts_diversity","text":"Calculate diversity given sets individuals","code":""},{"path":"https://bodkan.net/slendr/reference/ts_diversity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate diversity in given sets of individuals — ts_diversity","text":"","code":"ts_diversity(   ts,   sample_sets,   mode = c(\"site\", \"branch\", \"node\"),   windows = NULL,   span_normalise = TRUE )"},{"path":"https://bodkan.net/slendr/reference/ts_diversity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate diversity in given sets of individuals — ts_diversity","text":"ts Tree sequence object class slendr_ts sample_sets list (optionally named list) character vectors individual names (one vector per set). simple vector provided, interpreted .list(sample_sets), meaning given statistic calculated individual separately. mode mode calculation (\"sites\" \"branch\") windows Coordinates breakpoints windows. first coordinate (0) last coordinate (equal ts$sequence_length) added automatically) span_normalise Divide result span window? Default TRUE, see tskit documentation detail.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_diversity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate diversity in given sets of individuals — ts_diversity","text":"set individuals either single diversity value vector diversity values (one window)","code":""},{"path":"https://bodkan.net/slendr/reference/ts_diversity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate diversity in given sets of individuals — ts_diversity","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk ts <- ts_read(slendr_ts, model) %>% ts_mutate(mutation_rate = 1e-8, random_seed = 42)  # collect sampled individuals from all populations in a list sample_sets <- ts_samples(ts) %>%   split(., .$pop) %>%   lapply(function(pop) pop$name)  # compute diversity in each population based on sample sets extracted # in the previous step ts_diversity(ts, sample_sets) %>% .[order(.$diversity), ] #> # A tibble: 4 × 2 #>   set   diversity #>   <chr>     <dbl> #> 1 CH    0         #> 2 AFR   0.0000004 #> 3 NEA   0.000008  #> 4 EUR   0.0000779"},{"path":"https://bodkan.net/slendr/reference/ts_draw.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a graphical representation of a single tree — ts_draw","title":"Plot a graphical representation of a single tree — ts_draw","text":"function first obtains SVG representation tree calling draw_svg method tskit renders bitmap image R. many optional keyword arguments draw_svg method can provided automatically passed method behind scenes.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_draw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a graphical representation of a single tree — ts_draw","text":"","code":"ts_draw(   x,   width = 1000,   height = 1000,   labels = FALSE,   sampled_only = TRUE,   title = NULL,   ... )"},{"path":"https://bodkan.net/slendr/reference/ts_draw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a graphical representation of a single tree — ts_draw","text":"x single tree extracted ts_tree width, height Pixel dimensions rendered bitmap labels Label node individual name? sampled_only individuals explicitly sampled simplification labeled? relevant situations sampled individuals can among ancestral nodes. title Optional title figure ... Keyword arguments tskit draw_svg function.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_draw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a graphical representation of a single tree — ts_draw","text":"return value, called side effects","code":""},{"path":"https://bodkan.net/slendr/reference/ts_draw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a graphical representation of a single tree — ts_draw","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk ts <- ts_read(slendr_ts, model)  # extract the first tree in the tree sequence and draw it tree <- ts_tree(ts, i = 1)  # ts_draw accepts various optional arguments of tskit.Tree.draw_svg ts_draw(tree, time_scale = \"rank\")"},{"path":"https://bodkan.net/slendr/reference/ts_edges.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract spatio-temporal edge annotation table from a given tree or tree sequence — ts_edges","title":"Extract spatio-temporal edge annotation table from a given tree or tree sequence — ts_edges","text":"Extract spatio-temporal edge annotation table given tree tree sequence","code":""},{"path":"https://bodkan.net/slendr/reference/ts_edges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract spatio-temporal edge annotation table from a given tree or tree sequence — ts_edges","text":"","code":"ts_edges(x)"},{"path":"https://bodkan.net/slendr/reference/ts_edges.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract spatio-temporal edge annotation table from a given tree or tree sequence — ts_edges","text":"x Tree object generated ts_phylo slendr tree sequence object produced ts_read, ts_recapitate, ts_simplify, ts_mutate","code":""},{"path":"https://bodkan.net/slendr/reference/ts_edges.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract spatio-temporal edge annotation table from a given tree or tree sequence — ts_edges","text":"Data frame sf type containing times nodes start-end coordinates edges across space","code":""},{"path":"https://bodkan.net/slendr/reference/ts_edges.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract spatio-temporal edge annotation table from a given tree or tree sequence — ts_edges","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk ts <- ts_read(slendr_ts, model)  # extract an annotated table with (spatio-)temporal edge information ts_edges(ts) #> # A tibble: 294 × 6 #>    child_node_id parent_node_id child_time parent_time child_pop parent_pop #>            <int>          <int>      <dbl>       <dbl> <fct>     <fct>      #>  1             0             74      70000       70040 NEA       NEA        #>  2             1             74      70000       70040 NEA       NEA        #>  3             2             55      40000       40220 NEA       NEA        #>  4             3             55      40000       40220 NEA       NEA        #>  5             4             34          0         740 AFR       AFR        #>  6             5             28          0          80 AFR       AFR        #>  7             6             26          0          20 AFR       AFR        #>  8             7             27          0          80 AFR       AFR        #>  9             8             27          0          80 AFR       AFR        #> 10             9             36          0        1160 AFR       AFR        #> # ℹ 284 more rows"},{"path":"https://bodkan.net/slendr/reference/ts_eigenstrat.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert genotypes to the EIGENSTRAT file format — ts_eigenstrat","title":"Convert genotypes to the EIGENSTRAT file format — ts_eigenstrat","text":"EIGENSTRAT data produced function can used admixr R package (https://bodkan.net/admixr/).","code":""},{"path":"https://bodkan.net/slendr/reference/ts_eigenstrat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert genotypes to the EIGENSTRAT file format — ts_eigenstrat","text":"","code":"ts_eigenstrat(ts, prefix, chrom = \"chr1\", outgroup = NULL)"},{"path":"https://bodkan.net/slendr/reference/ts_eigenstrat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert genotypes to the EIGENSTRAT file format — ts_eigenstrat","text":"ts Tree sequence object class slendr_ts prefix EIGENSTRAT trio prefix chrom name chromosome EIGENSTRAT snp file (default \"chr1\") outgroup formal, artificial outgroup added? NULL (default), outgroup added. non-NULL character name serve name outgroup ind file.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_eigenstrat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert genotypes to the EIGENSTRAT file format — ts_eigenstrat","text":"Object class EIGENSTRAT created admixr package","code":""},{"path":"https://bodkan.net/slendr/reference/ts_eigenstrat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert genotypes to the EIGENSTRAT file format — ts_eigenstrat","text":"case outgroup formally specified slendr model generated tree sequence data, possible artificially create outgroup sample name specified outgroup argument, carry ancestral alleles (.e. value \"2\" geno file position snp file).","code":""},{"path":"https://bodkan.net/slendr/reference/ts_f4ratio.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the f2, f3, f4, and f4-ratio statistics — ts_f2","title":"Calculate the f2, f3, f4, and f4-ratio statistics — ts_f2","text":"functions present R interface corresponding f-statistics methods tskit.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_f4ratio.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the f2, f3, f4, and f4-ratio statistics — ts_f2","text":"","code":"ts_f2(   ts,   A,   B,   mode = c(\"site\", \"branch\", \"node\"),   span_normalise = TRUE,   windows = NULL )  ts_f3(   ts,   A,   B,   C,   mode = c(\"site\", \"branch\", \"node\"),   span_normalise = TRUE,   windows = NULL )  ts_f4(   ts,   W,   X,   Y,   Z,   mode = c(\"site\", \"branch\", \"node\"),   span_normalise = TRUE,   windows = NULL )  ts_f4ratio(   ts,   X,   A,   B,   C,   O,   mode = c(\"site\", \"branch\"),   span_normalise = TRUE )"},{"path":"https://bodkan.net/slendr/reference/ts_f4ratio.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the f2, f3, f4, and f4-ratio statistics — ts_f2","text":"ts Tree sequence object class slendr_ts mode mode calculation (\"sites\" \"branch\") span_normalise Divide result span window? Default TRUE, see tskit documentation detail. windows Coordinates breakpoints windows. first coordinate (0) last coordinate (equal ts$sequence_length) specified added automatically. W, X, Y, Z, , B, C, O Character vectors individual names (largely following nomenclature Patterson 2021, see crucial differences tskit ADMIXTOOLS Details)","code":""},{"path":"https://bodkan.net/slendr/reference/ts_f4ratio.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the f2, f3, f4, and f4-ratio statistics — ts_f2","text":"Data frame statistics calculated given sets individuals","code":""},{"path":"https://bodkan.net/slendr/reference/ts_f4ratio.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the f2, f3, f4, and f4-ratio statistics — ts_f2","text":"Note order populations f3 statistic implemented tskit (https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.f3) different might expect ADMIXTOOLS, defined Patterson 2012 (see doi:10.1534/genetics.112.145037  heading \"three-population test introduction f-statistics\", well ADMIXTOOLS documentation https://github.com/DReichLab/AdmixTools/blob/master/README.3PopTest#L5). Specifically, widely used notation introduced Patterson assumes population triplet f3(C; , B), C \"focal\" sample (.e., either outgroup sample tested admixture). contrast, tskit implements f3(; B, C), \"focal sample\" . Although likely confuse many ADMIXTOOLS users, slendr much choice , ts_*() functions designed broadly compatible raw tskit methods.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_f4ratio.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the f2, f3, f4, and f4-ratio statistics — ts_f2","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk and add mutations to it ts <- ts_read(slendr_ts, model) %>% ts_mutate(mutation_rate = 1e-8, random_seed = 42)  # calculate f2 for two individuals in a previously loaded tree sequence ts_f2(ts, A = \"AFR_1\", B = \"EUR_1\") #> # A tibble: 1 × 3 #>   A     B           f2 #>   <chr> <chr>    <dbl> #> 1 AFR_1 EUR_1 0.000028  # calculate f2 for two sets of individuals ts_f2(ts, A = c(\"AFR_1\", \"AFR_2\"), B = c(\"EUR_1\", \"EUR_3\")) #> # A tibble: 1 × 3 #>   A           B                  f2 #>   <chr>       <chr>           <dbl> #> 1 AFR_1+AFR_2 EUR_1+EUR_3 0.0000307  # calculate f3 for two individuals in a previously loaded tree sequence ts_f3(ts, A = \"EUR_1\", B = \"AFR_1\", C = \"NEA_1\") #> # A tibble: 1 × 4 #>   A     B     C            f3 #>   <chr> <chr> <chr>     <dbl> #> 1 EUR_1 AFR_1 NEA_1 -0.000019  # calculate f3 for two sets of individuals ts_f3(ts, A = c(\"AFR_1\", \"AFR_2\", \"EUR_1\", \"EUR_2\"),           B = c(\"NEA_1\", \"NEA_2\"),           C = \"CH_1\") #> # A tibble: 1 × 4 #>   A                       B           C           f3 #>   <chr>                   <chr>       <chr>    <dbl> #> 1 AFR_1+AFR_2+EUR_1+EUR_2 NEA_1+NEA_2 CH_1  0.000157  # calculate f4 for single individuals ts_f4(ts, W = \"EUR_1\", X = \"AFR_1\", Y = \"NEA_1\", Z = \"CH_1\") #> # A tibble: 1 × 5 #>   W     X     Y     Z           f4 #>   <chr> <chr> <chr> <chr>    <dbl> #> 1 EUR_1 AFR_1 NEA_1 CH_1  0.000011  # calculate f4 for sets of individuals ts_f4(ts, W = c(\"EUR_1\", \"EUR_2\"),           X = c(\"AFR_1\", \"AFR_2\"),           Y = \"NEA_1\",           Z = \"CH_1\") #> # A tibble: 1 × 5 #>   W           X           Y     Z            f4 #>   <chr>       <chr>       <chr> <chr>     <dbl> #> 1 EUR_1+EUR_2 AFR_1+AFR_2 NEA_1 CH_1  0.0000205  # calculate f4-ratio for a given set of target individuals X ts_f4ratio(ts, X = c(\"EUR_1\", \"EUR_2\", \"EUR_4\", \"EUR_5\"),                A = \"NEA_1\", B = \"NEA_2\", C = \"AFR_1\", O = \"CH_1\") #> # A tibble: 4 × 6 #>   X     A     B     C     O      alpha #>   <chr> <chr> <chr> <chr> <chr>  <dbl> #> 1 EUR_1 NEA_1 NEA_2 AFR_1 CH_1  0.0625 #> 2 EUR_2 NEA_1 NEA_2 AFR_1 CH_1  0.170  #> 3 EUR_4 NEA_1 NEA_2 AFR_1 CH_1  0.0455 #> 4 EUR_5 NEA_1 NEA_2 AFR_1 CH_1  0"},{"path":"https://bodkan.net/slendr/reference/ts_fst.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate pairwise statistics between sets of individuals — ts_fst","title":"Calculate pairwise statistics between sets of individuals — ts_fst","text":"discussion difference \"site\", \"branch\", \"node\" options mode argument, please see tskit documentation https://tskit.dev/tskit/docs/stable/stats.html#sec-stats-mode.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_fst.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate pairwise statistics between sets of individuals — ts_fst","text":"","code":"ts_fst(   ts,   sample_sets,   mode = c(\"site\", \"branch\", \"node\"),   windows = NULL,   span_normalise = TRUE )"},{"path":"https://bodkan.net/slendr/reference/ts_fst.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate pairwise statistics between sets of individuals — ts_fst","text":"ts Tree sequence object class slendr_ts sample_sets list (optionally named list) character vectors individual names (one vector per set) mode mode calculation (\"sites\" \"branch\") windows Coordinates breakpoints windows. first coordinate (0) last coordinate (equal ts$sequence_length) specified added automatically. span_normalise Divide result span window? Default TRUE, see tskit documentation detail.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_fst.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate pairwise statistics between sets of individuals — ts_fst","text":"pairwise calculation, either single Fst value vector Fst values (one window)","code":""},{"path":"https://bodkan.net/slendr/reference/ts_fst.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate pairwise statistics between sets of individuals — ts_fst","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk ts <- ts_read(slendr_ts, model) %>% ts_mutate(mutation_rate = 1e-8, random_seed = 42)  # compute F_st between two sets of individuals in a given tree sequence ts ts_fst(ts, sample_sets = list(afr = c(\"AFR_1\", \"AFR_2\", \"AFR_3\"),                               eur = c(\"EUR_1\", \"EUR_2\"))) #> # A tibble: 1 × 3 #>   x     y       Fst #>   <chr> <chr> <dbl> #> 1 afr   eur   0.324"},{"path":"https://bodkan.net/slendr/reference/ts_genotypes.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract genotype table from the tree sequence — ts_genotypes","title":"Extract genotype table from the tree sequence — ts_genotypes","text":"Extract genotype table tree sequence","code":""},{"path":"https://bodkan.net/slendr/reference/ts_genotypes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract genotype table from the tree sequence — ts_genotypes","text":"","code":"ts_genotypes(ts, quiet = FALSE)"},{"path":"https://bodkan.net/slendr/reference/ts_genotypes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract genotype table from the tree sequence — ts_genotypes","text":"ts Tree sequence object class slendr_ts quiet messages multiallelic sites silenced? Default FALSE.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_genotypes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract genotype table from the tree sequence — ts_genotypes","text":"Data frame object class tibble containing genotypes simulated individuals columns","code":""},{"path":"https://bodkan.net/slendr/reference/ts_genotypes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract genotype table from the tree sequence — ts_genotypes","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk, recapitate it, simplify it, and mutate it ts <- ts_read(slendr_ts, model) %>%   ts_recapitate(Ne = 10000, recombination_rate = 1e-8) %>%   ts_simplify() %>%   ts_mutate(mutation_rate = 1e-8)  # extract the genotype matrix (this could take  a long time consume lots # of memory!) gts <- ts_genotypes(ts) #> 2 multiallelic sites (0.092% out of 2175 total) detected and removed"},{"path":"https://bodkan.net/slendr/reference/ts_ibd.html","id":null,"dir":"Reference","previous_headings":"","what":"Collect Identity-by-Descent (IBD) segments (EXPERIMENTAL) — ts_ibd","title":"Collect Identity-by-Descent (IBD) segments (EXPERIMENTAL) — ts_ibd","text":"function iterates tree sequence returns IBD tracts pairs individuals nodes","code":""},{"path":"https://bodkan.net/slendr/reference/ts_ibd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collect Identity-by-Descent (IBD) segments (EXPERIMENTAL) — ts_ibd","text":"","code":"ts_ibd(   ts,   coordinates = FALSE,   within = NULL,   between = NULL,   squash = FALSE,   minimum_length = NULL,   maximum_time = NULL,   sf = TRUE )"},{"path":"https://bodkan.net/slendr/reference/ts_ibd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collect Identity-by-Descent (IBD) segments (EXPERIMENTAL) — ts_ibd","text":"ts Tree sequence object class slendr_ts coordinates coordinates detected IBD tracts reported? FALSE (default), total length shared IBD segments numbers reported. TRUE, coordinates segment returned (note can massive impact memory usage). See details information. within character vector individual names integer vector node IDs indicating set nodes within look IBD segments. list lists character vectors individual names integer vectors node IDs, indicating set nodes look shared IBD segments. squash adjacent IBD segments pairs nodes squashed differ 'genealogical paths' MRCA? Default FALSE. context, see https://github.com/tskit-dev/tskit/issues/2459. option EXPERIMENTAL! minimum_length Minimum length IBD segment return results. useful reducing total amount IBD returned (see Details). maximum_time Oldest MRCA node considered IBD ancestor return IBD segment results. useful reducing total amount IBD returned. sf IBD segments spatial tree sequence analyzed, returned table spatial sf object? Default TRUE.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_ibd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Collect Identity-by-Descent (IBD) segments (EXPERIMENTAL) — ts_ibd","text":"data frame IBD results (either coordinates IBD segment shared pair nodes, summary statistics total IBD sharing pair)","code":""},{"path":"https://bodkan.net/slendr/reference/ts_ibd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Collect Identity-by-Descent (IBD) segments (EXPERIMENTAL) — ts_ibd","text":"function considered experimental. full control IBD segment detection tree-sequence data, users can (perhaps, time , ) rely tskit method ibd_segments (see https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.ibd_segments). Iternally, function leverages tskit TreeSequence method ibd_segments. However, note ts_ibd function always returns data frame IBD tracts, provide option iterate individual IBD segments shown official tskit documentation https://tskit.dev/tskit/docs/stable/ibd.html. general, R handles heavy iteration poorly, function attempt serve full wrapper ibd_segments. Unfortunately, distinction \"squashed IBD\" (many consider expected definition IBD) tskit’s IBD defined via distinct genealogical paths (see https://github.com/tskit-dev/tskit/issues/2459 discussion topic), makes meaning filtering parameter ibd_segments() method tskit minimum_length somewhat unintuitive. moment, function argument filters IBD segments tskit level, level squashed IBD segments!","code":""},{"path":"https://bodkan.net/slendr/reference/ts_ibd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Collect Identity-by-Descent (IBD) segments (EXPERIMENTAL) — ts_ibd","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk ts <- ts_read(slendr_ts, model)  # find IBD segments between specified Neanderthals and Europeans ts_ibd(   ts,   coordinates = TRUE,   between = list(c(\"NEA_1\", \"NEA_2\"), c(\"EUR_1\", \"EUR_2\")),   minimum_length = 40000 ) #> # A tibble: 32 × 13 #>    node1 node2 length  mrca node1_time node2_time tmrca   left  right name1 #>    <int> <int>  <dbl> <dbl>      <dbl>      <dbl> <dbl>  <dbl>  <dbl> <chr> #>  1     0    16  87198    82      70000          0 20001  65949 153147 NEA_1 #>  2     0    16  85735    82      70000          0 20001 221193 306928 NEA_1 #>  3     0    17  68822    82      70000          0 20001  65949 134771 NEA_1 #>  4     0    17  53084    82      70000          0 20001 227724 280808 NEA_1 #>  5     0    18  87198    82      70000          0 20001  65949 153147 NEA_1 #>  6     0    18  85735    82      70000          0 20001 221193 306928 NEA_1 #>  7     0    19  81722    82      70000          0 20001  71425 153147 NEA_1 #>  8     0    19  58054    79      70000          0  2340 227185 285239 NEA_1 #>  9     1    16  87198    82      70000          0 20001  65949 153147 NEA_1 #> 10     1    16  85735    82      70000          0 20001 221193 306928 NEA_1 #> # ℹ 22 more rows #> # ℹ 3 more variables: name2 <chr>, pop1 <fct>, pop2 <fct>"},{"path":"https://bodkan.net/slendr/reference/ts_load.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a tree sequence from a file — ts_load","title":"Read a tree sequence from a file — ts_load","text":"Deprecated function. Please use ts_read instead.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_load.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a tree sequence from a file — ts_load","text":"","code":"ts_load(file, model = NULL)"},{"path":"https://bodkan.net/slendr/reference/ts_load.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a tree sequence from a file — ts_load","text":"file path tree-sequence file (either originating slendr model standard non-slendr tree sequence). model Optional slendr_model object produced tree-sequence file. Used adding various annotation data metadata standard tskit tree-sequence object.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_metadata.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract list with tree sequence metadata saved by SLiM — ts_metadata","title":"Extract list with tree sequence metadata saved by SLiM — ts_metadata","text":"Extract list tree sequence metadata saved SLiM","code":""},{"path":"https://bodkan.net/slendr/reference/ts_metadata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract list with tree sequence metadata saved by SLiM — ts_metadata","text":"","code":"ts_metadata(ts)"},{"path":"https://bodkan.net/slendr/reference/ts_metadata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract list with tree sequence metadata saved by SLiM — ts_metadata","text":"ts Tree sequence object class slendr_ts","code":""},{"path":"https://bodkan.net/slendr/reference/ts_metadata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract list with tree sequence metadata saved by SLiM — ts_metadata","text":"List metadata fields extracted tree-sequence object","code":""},{"path":"https://bodkan.net/slendr/reference/ts_metadata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract list with tree sequence metadata saved by SLiM — ts_metadata","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk ts <- ts_read(slendr_ts, model)  # extract the list of metadata information from the tree sequence ts_metadata(ts) #> $version #> [1] \"slendr_1.3.0.9000\" #>  #> $description #> [1] \"\" #>  #> $sampling #> # A tibble: 13 × 3 #>    name   time pop   #>    <chr> <int> <chr> #>  1 NEA_1 70000 NEA   #>  2 NEA_2 40000 NEA   #>  3 AFR_1     0 AFR   #>  4 AFR_2     0 AFR   #>  5 AFR_3     0 AFR   #>  6 AFR_4     0 AFR   #>  7 AFR_5     0 AFR   #>  8 CH_1      0 CH    #>  9 EUR_1     0 EUR   #> 10 EUR_2     0 EUR   #> 11 EUR_3     0 EUR   #> 12 EUR_4     0 EUR   #> 13 EUR_5     0 EUR   #>  #> $sample_names #>  [1] \"NEA_1\" \"NEA_2\" \"AFR_1\" \"AFR_2\" \"AFR_3\" \"AFR_4\" \"AFR_5\" \"CH_1\"  \"EUR_1\" #> [10] \"EUR_2\" \"EUR_3\" \"EUR_4\" \"EUR_5\" #>  #> $subset_names #>  [1] \"NEA_1\" \"NEA_2\" \"AFR_1\" \"AFR_2\" \"AFR_3\" \"AFR_4\" \"AFR_5\" \"CH_1\"  \"EUR_1\" #> [10] \"EUR_2\" \"EUR_3\" \"EUR_4\" \"EUR_5\" #>  #> $sample_ids #> NULL #>  #> $map #> NULL #>  #> $arguments #> $arguments$BURNIN_LENGTH #> [1] 0 #>  #> $arguments$MAX_ATTEMPTS #> [1] 1 #>  #> $arguments$RECOMBINATION_RATE #> [1] 1e-08 #>  #> $arguments$SEED #> [1] 314159 #>  #> $arguments$SEQUENCE_LENGTH #> [1] 500000 #>  #> $arguments$SIMULATION_LENGTH #> [1] 216667 #>  #>"},{"path":"https://bodkan.net/slendr/reference/ts_mutate.html","id":null,"dir":"Reference","previous_headings":"","what":"Add mutations to the given tree sequence — ts_mutate","title":"Add mutations to the given tree sequence — ts_mutate","text":"Add mutations given tree sequence","code":""},{"path":"https://bodkan.net/slendr/reference/ts_mutate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add mutations to the given tree sequence — ts_mutate","text":"","code":"ts_mutate(   ts,   mutation_rate,   random_seed = NULL,   keep_existing = TRUE,   mutation_model = NULL )"},{"path":"https://bodkan.net/slendr/reference/ts_mutate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add mutations to the given tree sequence — ts_mutate","text":"ts Tree sequence object class slendr_ts mutation_rate Mutation rate used msprime simulate mutations random_seed Random seed passed msprime's mutate method (NULL, seed generated 0 maximum integer number available) keep_existing Keep existing mutations? mutation_model mutation model use? NULL (default), special mutation type used. Otherwise, mutation model matching https://tskit.dev/msprime/docs/stable/mutations.html may provided Python/reticulate object. instance, msprime$SLiMMutationModel(type=42L) add SLiM mutation mutation type 42.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_mutate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add mutations to the given tree sequence — ts_mutate","text":"Tree-sequence object class slendr_ts, serves interface point Python module tskit using slendr functions ts_ prefix.","code":""},{"path":[]},{"path":"https://bodkan.net/slendr/reference/ts_mutate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add mutations to the given tree sequence — ts_mutate","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  ts <- ts_read(slendr_ts, model) ts_mutate <- ts_mutate(ts, mutation_rate = 1e-8, random_seed = 42)  ts_mutate #> ╔═════════════════════════╗ #> ║TreeSequence             ║ #> ╠═══════════════╤═════════╣ #> ║Trees          │       68║ #> ╟───────────────┼─────────╢ #> ║Sequence Length│  500,000║ #> ╟───────────────┼─────────╢ #> ║Time Units     │    ticks║ #> ╟───────────────┼─────────╢ #> ║Sample Nodes   │       26║ #> ╟───────────────┼─────────╢ #> ║Total Size     │214.3 KiB║ #> ╚═══════════════╧═════════╝ #> ╔═══════════╤═════╤════════╤════════════╗ #> ║Table      │Rows │Size    │Has Metadata║ #> ╠═══════════╪═════╪════════╪════════════╣ #> ║Edges      │  294│ 9.2 KiB│          No║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Individuals│   71│ 8.7 KiB│         Yes║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Migrations │    0│ 8 Bytes│          No║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Mutations  │2,213│81.2 KiB│          No║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Nodes      │   85│ 4.7 KiB│         Yes║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Populations│    5│ 2.6 KiB│         Yes║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Provenances│    4│46.9 KiB│          No║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Sites      │2,210│54.0 KiB│          No║ #> ╚═══════════╧═════╧════════╧════════════╝ #>"},{"path":"https://bodkan.net/slendr/reference/ts_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract names of individuals in a tree sequence — ts_names","title":"Extract names of individuals in a tree sequence — ts_names","text":"Extract names individuals tree sequence","code":""},{"path":"https://bodkan.net/slendr/reference/ts_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract names of individuals in a tree sequence — ts_names","text":"","code":"ts_names(ts, split = NULL)"},{"path":"https://bodkan.net/slendr/reference/ts_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract names of individuals in a tree sequence — ts_names","text":"ts Tree sequence object class slendr_ts split sample names tree sequence split column (population time column)? Default NULL names samples returned single character vector. set \"pop\" \"time\", list character vectors returned, one vector unique \"pop\" \"time\" grouping.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract names of individuals in a tree sequence — ts_names","text":"vector character sample names. split specified, list vectors returned, one element list per population sampling time.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_nodes.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract combined annotated table of individuals and nodes — ts_nodes","title":"Extract combined annotated table of individuals and nodes — ts_nodes","text":"function combines information table individuals table nodes single data frame can used downstream analyses.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_nodes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract combined annotated table of individuals and nodes — ts_nodes","text":"","code":"ts_nodes(x, sf = TRUE)"},{"path":"https://bodkan.net/slendr/reference/ts_nodes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract combined annotated table of individuals and nodes — ts_nodes","text":"x Tree sequence object class slendr_ts phylo object extracted ts_phylo sf spatial data returned sf format? FALSE, spatial geometries returned simply x y columns, instead standard POINT data type.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_nodes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract combined annotated table of individuals and nodes — ts_nodes","text":"Data frame processed information tree sequence object. model generated data spatial, result returned spatial object class sf.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_nodes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract combined annotated table of individuals and nodes — ts_nodes","text":"source data (tables individuals nodes recorded tree sequence generated SLiM) combined single data frame. model generated data spatial, coordinates nodes (pixel-based default SLiM spatial simulations occur raster), coordinates automatically converted explicit spatial object sf class unless spatial = FALSE. See https://r-spatial.github.io/sf/ extensive introduction sf package ways spatial data can processed, analysed, visualised.","code":""},{"path":[]},{"path":"https://bodkan.net/slendr/reference/ts_nodes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract combined annotated table of individuals and nodes — ts_nodes","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk ts <- ts_read(slendr_ts, model)  # extract an annotated table with (spatio-)temporal node information ts_nodes(ts) #> # A tibble: 85 × 12 #>    name  pop   node_id  time time_tskit sampled remembered retained alive #>    <chr> <fct>   <int> <dbl>      <dbl> <lgl>   <lgl>      <lgl>    <lgl> #>  1 NEA_1 NEA         0 70000       2334 TRUE    TRUE       TRUE     FALSE #>  2 NEA_1 NEA         1 70000       2334 TRUE    TRUE       TRUE     FALSE #>  3 NEA_2 NEA         2 40000       1334 TRUE    TRUE       TRUE     FALSE #>  4 NEA_2 NEA         3 40000       1334 TRUE    TRUE       TRUE     FALSE #>  5 AFR_1 AFR         4     0          0 TRUE    TRUE       TRUE     TRUE  #>  6 AFR_1 AFR         5     0          0 TRUE    TRUE       TRUE     TRUE  #>  7 AFR_2 AFR         6     0          0 TRUE    TRUE       TRUE     TRUE  #>  8 AFR_2 AFR         7     0          0 TRUE    TRUE       TRUE     TRUE  #>  9 AFR_3 AFR         8     0          0 TRUE    TRUE       TRUE     TRUE  #> 10 AFR_3 AFR         9     0          0 TRUE    TRUE       TRUE     TRUE  #> # ℹ 75 more rows #> # ℹ 3 more variables: pedigree_id <dbl>, pop_id <int>, ind_id <dbl>"},{"path":"https://bodkan.net/slendr/reference/ts_phylo.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a tree in the tree sequence to an object of the class phylo — ts_phylo","title":"Convert a tree in the tree sequence to an object of the class phylo — ts_phylo","text":"Convert tree tree sequence object class phylo","code":""},{"path":"https://bodkan.net/slendr/reference/ts_phylo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a tree in the tree sequence to an object of the class phylo — ts_phylo","text":"","code":"ts_phylo(   ts,   i,   mode = c(\"index\", \"position\"),   labels = c(\"tskit\", \"pop\"),   quiet = FALSE )"},{"path":"https://bodkan.net/slendr/reference/ts_phylo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a tree in the tree sequence to an object of the class phylo — ts_phylo","text":"ts Tree sequence object class slendr_ts Position tree tree sequence. mode = \"index\", -th tree returned (zero-based indexing tskit), mode = \"position\", tree covering -th base simulated genome returned (, tskit's indexing). mode argument interpreted? Either \"index\" -th tree sequence genealogies, \"position\" along simulated genome. labels stored node labels final phylo object? Options either population name tskit integer node ID (different thing phylo class node integer index). quiet ape's internal phylo validity test printed ?","code":""},{"path":"https://bodkan.net/slendr/reference/ts_phylo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a tree in the tree sequence to an object of the class phylo — ts_phylo","text":"Standard phylogenetic tree object implemented R package ape","code":""},{"path":"https://bodkan.net/slendr/reference/ts_phylo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a tree in the tree sequence to an object of the class phylo — ts_phylo","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk ts <- ts_read(slendr_ts, model) %>%   ts_recapitate(Ne = 10000, recombination_rate = 1e-8) %>%   ts_simplify()  # extract the 1st tree from a given tree sequence, return ape object tree <- ts_phylo(ts, i = 1, mode = \"index\", quiet = TRUE) tree #>  #> Phylogenetic tree with 26 tips and 24 internal nodes. #>  #> Tip labels: #>   25 (EUR_5), 24 (EUR_5), 23 (EUR_4), 22 (EUR_4), 21 (EUR_3), 20 (EUR_3), ... #> Node labels: #>   83, 28, 27, 30, 31, 32, ... #>  #> Rooted; includes branch length(s).  # extract the tree at a 42th basepair in the given tree sequence tree <- ts_phylo(ts, i = 42, mode = \"position\", quiet = TRUE)  # because the tree is a standard ape phylo object, we can plot it easily plot(tree, use.edge.length = FALSE) ape::nodelabels()"},{"path":"https://bodkan.net/slendr/reference/ts_read.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a tree sequence from a file — ts_read","title":"Read a tree sequence from a file — ts_read","text":"function loads tree sequence file simulated given slendr model. Optionally, tree sequence can recapitated simplified.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_read.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a tree sequence from a file — ts_read","text":"","code":"ts_read(file, model = NULL)"},{"path":"https://bodkan.net/slendr/reference/ts_read.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a tree sequence from a file — ts_read","text":"file path tree-sequence file (either originating slendr model standard non-slendr tree sequence). model Optional slendr_model object produced tree-sequence file. Used adding various annotation data metadata standard tskit tree-sequence object.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_read.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a tree sequence from a file — ts_read","text":"Tree-sequence object class slendr_ts, serves interface point Python module tskit using slendr functions ts_ prefix.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_read.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read a tree sequence from a file — ts_read","text":"loading, recapitation simplification performed using Python module pyslim serves link tree sequences generated SLiM tskit module manipulation tree sequence data. steps modelled official pyslim tutorial documentation available : https://tskit.dev/pyslim/docs/latest/tutorial.html. recapitation simplification steps can also performed individually using functions ts_recapitate ts_simplify.","code":""},{"path":[]},{"path":"https://bodkan.net/slendr/reference/ts_read.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read a tree sequence from a file — ts_read","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load tree sequence generated by a given model ts <- ts_read(slendr_ts, model)  # even tree sequences generated by non-slendr models can be msprime_ts <- system.file(\"extdata/models/msprime.trees\", package = \"slendr\") ts <- ts_read(msprime_ts)  # load tree sequence and immediately simplify it only to sampled individuals # (note that the example tree sequence is already simplified so this operation # does not do anything in this case) ts <- ts_read(slendr_ts, model = model) %>% ts_simplify(keep_input_roots = TRUE)  # load tree sequence and simplify it to a subset of sampled individuals ts_small <- ts_simplify(ts, simplify_to = c(\"CH_1\", \"NEA_1\", \"NEA_2\",                                             \"AFR_1\", \"AFR_2\", \"EUR_1\", \"EUR_2\"))  # load tree sequence, recapitate it and simplify it ts <- ts_read(slendr_ts, model) %>%   ts_recapitate(recombination_rate = 1e-8, Ne = 10000, random_seed = 42) %>%   ts_simplify()  # load tree sequence, recapitate it, simplify it and overlay neutral mutations ts <- ts_read(slendr_ts, model) %>%   ts_recapitate(recombination_rate = 1e-8, Ne = 10000, random_seed = 42) %>%   ts_simplify() %>%   ts_mutate(mutation_rate = 1e-8)  ts #> ╔═════════════════════════╗ #> ║TreeSequence             ║ #> ╠═══════════════╤═════════╣ #> ║Trees          │       68║ #> ╟───────────────┼─────────╢ #> ║Sequence Length│  500,000║ #> ╟───────────────┼─────────╢ #> ║Time Units     │    ticks║ #> ╟───────────────┼─────────╢ #> ║Sample Nodes   │       26║ #> ╟───────────────┼─────────╢ #> ║Total Size     │215.3 KiB║ #> ╚═══════════════╧═════════╝ #> ╔═══════════╤═════╤════════╤════════════╗ #> ║Table      │Rows │Size    │Has Metadata║ #> ╠═══════════╪═════╪════════╪════════════╣ #> ║Edges      │  293│ 9.2 KiB│          No║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Individuals│   70│ 8.6 KiB│         Yes║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Migrations │    0│ 8 Bytes│          No║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Mutations  │2,185│80.1 KiB│          No║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Nodes      │   84│ 4.6 KiB│         Yes║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Populations│    6│ 2.7 KiB│         Yes║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Provenances│    6│50.0 KiB│          No║ #> ╟───────────┼─────┼────────┼────────────╢ #> ║Sites      │2,175│53.1 KiB│          No║ #> ╚═══════════╧═════╧════════╧════════════╝ #>"},{"path":"https://bodkan.net/slendr/reference/ts_recapitate.html","id":null,"dir":"Reference","previous_headings":"","what":"Recapitate the tree sequence — ts_recapitate","title":"Recapitate the tree sequence — ts_recapitate","text":"Recapitate tree sequence","code":""},{"path":"https://bodkan.net/slendr/reference/ts_recapitate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recapitate the tree sequence — ts_recapitate","text":"","code":"ts_recapitate(   ts,   recombination_rate,   Ne = NULL,   demography = NULL,   random_seed = NULL )"},{"path":"https://bodkan.net/slendr/reference/ts_recapitate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recapitate the tree sequence — ts_recapitate","text":"ts Tree sequence object loaded ts_read recombination_rate constant value recombination rate Ne Effective population size recapitation process demography Ancestral demography passed internally msprime.sim_ancestry() (see msprime's documentation mode detail) random_seed Random seed passed pyslim's recapitate method (NULL, seed generated 0 maximum integer number available)","code":""},{"path":"https://bodkan.net/slendr/reference/ts_recapitate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recapitate the tree sequence — ts_recapitate","text":"Tree-sequence object class slendr_ts, serves interface point Python module tskit using slendr functions ts_ prefix.","code":""},{"path":[]},{"path":"https://bodkan.net/slendr/reference/ts_recapitate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recapitate the tree sequence — ts_recapitate","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  ts <- ts_read(slendr_ts, model) %>%   ts_recapitate(recombination_rate = 1e-8, Ne = 10000, random_seed = 42)  ts #> ╔════════════════════════╗ #> ║TreeSequence            ║ #> ╠═══════════════╤════════╣ #> ║Trees          │      68║ #> ╟───────────────┼────────╢ #> ║Sequence Length│ 500,000║ #> ╟───────────────┼────────╢ #> ║Time Units     │   ticks║ #> ╟───────────────┼────────╢ #> ║Sample Nodes   │      26║ #> ╟───────────────┼────────╢ #> ║Total Size     │82.2 KiB║ #> ╚═══════════════╧════════╝ #> ╔═══════════╤════╤════════╤════════════╗ #> ║Table      │Rows│Size    │Has Metadata║ #> ╠═══════════╪════╪════════╪════════════╣ #> ║Edges      │ 294│ 9.2 KiB│          No║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Individuals│  71│ 8.7 KiB│         Yes║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Migrations │   0│ 8 Bytes│          No║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Mutations  │   0│ 1.2 KiB│          No║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Nodes      │  85│ 4.7 KiB│         Yes║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Populations│   6│ 2.7 KiB│         Yes║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Provenances│   4│48.7 KiB│          No║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Sites      │   0│16 Bytes│          No║ #> ╚═══════════╧════╧════════╧════════════╝ #>"},{"path":"https://bodkan.net/slendr/reference/ts_samples.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract names and times of individuals of interest in the current tree sequence (either all sampled individuals or those that the user simplified to) — ts_samples","title":"Extract names and times of individuals of interest in the current tree sequence (either all sampled individuals or those that the user simplified to) — ts_samples","text":"Extract names times individuals interest current tree sequence (either sampled individuals user simplified )","code":""},{"path":"https://bodkan.net/slendr/reference/ts_samples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract names and times of individuals of interest in the current tree sequence (either all sampled individuals or those that the user simplified to) — ts_samples","text":"","code":"ts_samples(ts)"},{"path":"https://bodkan.net/slendr/reference/ts_samples.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract names and times of individuals of interest in the current tree sequence (either all sampled individuals or those that the user simplified to) — ts_samples","text":"ts Tree sequence object class slendr_ts","code":""},{"path":"https://bodkan.net/slendr/reference/ts_samples.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract names and times of individuals of interest in the current tree sequence (either all sampled individuals or those that the user simplified to) — ts_samples","text":"Table individuals scheduled sampling across space time","code":""},{"path":"https://bodkan.net/slendr/reference/ts_samples.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract names and times of individuals of interest in the current tree sequence (either all sampled individuals or those that the user simplified to) — ts_samples","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk ts <- ts_read(slendr_ts, model)  # extract the table of individuals scheduled for simulation and sampling ts_samples(ts) #> # A tibble: 13 × 3 #>    name   time pop   #>    <chr> <int> <chr> #>  1 NEA_1 70000 NEA   #>  2 NEA_2 40000 NEA   #>  3 AFR_1     0 AFR   #>  4 AFR_2     0 AFR   #>  5 AFR_3     0 AFR   #>  6 AFR_4     0 AFR   #>  7 AFR_5     0 AFR   #>  8 CH_1      0 CH    #>  9 EUR_1     0 EUR   #> 10 EUR_2     0 EUR   #> 11 EUR_3     0 EUR   #> 12 EUR_4     0 EUR   #> 13 EUR_5     0 EUR"},{"path":"https://bodkan.net/slendr/reference/ts_save.html","id":null,"dir":"Reference","previous_headings":"","what":"Write a tree sequence to a file — ts_save","title":"Write a tree sequence to a file — ts_save","text":"Deprecated function. Please use ts_write instead.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_save.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write a tree sequence to a file — ts_save","text":"","code":"ts_save(ts, file)"},{"path":"https://bodkan.net/slendr/reference/ts_save.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write a tree sequence to a file — ts_save","text":"ts Tree sequence object loaded ts_read file File tree sequence saved","code":""},{"path":"https://bodkan.net/slendr/reference/ts_segregating.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the density of segregating sites for the given sets of individuals — ts_segregating","title":"Calculate the density of segregating sites for the given sets of individuals — ts_segregating","text":"Calculate density segregating sites given sets individuals","code":""},{"path":"https://bodkan.net/slendr/reference/ts_segregating.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the density of segregating sites for the given sets of individuals — ts_segregating","text":"","code":"ts_segregating(   ts,   sample_sets,   mode = c(\"site\", \"branch\", \"node\"),   windows = NULL,   span_normalise = FALSE )"},{"path":"https://bodkan.net/slendr/reference/ts_segregating.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the density of segregating sites for the given sets of individuals — ts_segregating","text":"ts Tree sequence object class slendr_ts sample_sets list (optionally named list) character vectors individual names (one vector per set). simple vector provided, interpreted .list(sample_sets), meaning given statistic calculated individual separately. mode mode calculation (\"sites\" \"branch\") windows Coordinates breakpoints windows. first coordinate (0) last coordinate (equal ts$sequence_length) added automatically) span_normalise Divide result span window? Default TRUE, see tskit documentation detail.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_segregating.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the density of segregating sites for the given sets of individuals — ts_segregating","text":"set individuals either single diversity value vector diversity values (one window)","code":""},{"path":"https://bodkan.net/slendr/reference/ts_segregating.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the density of segregating sites for the given sets of individuals — ts_segregating","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk ts <- ts_read(slendr_ts, model) %>% ts_mutate(mutation_rate = 1e-8, random_seed = 42)  # collect sampled individuals from all populations in a list sample_sets <- ts_samples(ts) %>%   split(., .$pop) %>%   lapply(function(pop) pop$name)  ts_segregating(ts, sample_sets) #> # A tibble: 4 × 2 #>   set   segsites #>   <chr>    <dbl> #> 1 AFR          1 #> 2 CH           0 #> 3 EUR        138 #> 4 NEA          6"},{"path":"https://bodkan.net/slendr/reference/ts_simplify.html","id":null,"dir":"Reference","previous_headings":"","what":"Simplify the tree sequence down to a given set of individuals — ts_simplify","title":"Simplify the tree sequence down to a given set of individuals — ts_simplify","text":"function convenience wrapper around simplify method implemented tskit, designed work tree sequence data simulated SLiM using slendr R package.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_simplify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simplify the tree sequence down to a given set of individuals — ts_simplify","text":"","code":"ts_simplify(   ts,   simplify_to = NULL,   keep_input_roots = FALSE,   keep_unary = FALSE,   keep_unary_in_individuals = FALSE,   filter_nodes = TRUE )"},{"path":"https://bodkan.net/slendr/reference/ts_simplify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simplify the tree sequence down to a given set of individuals — ts_simplify","text":"ts Tree sequence object class slendr_ts simplify_to character vector individual names. NULL, explicitly remembered individuals (.e. specified via schedule_sampling function left tree sequence simplification. keep_input_roots history ancestral MRCA samples retained tree sequence? Default FALSE. keep_unary unary nodes preserved simplification? Default FALSE. keep_unary_in_individuals unary nodes preserved simplification associated individual recorded table individuals? Default FALSE. set TRUE keep_unary also TRUE filter_nodes nodes reindexed simplification? Default TRUE. See tskit's documentation Python method simplify()","code":""},{"path":"https://bodkan.net/slendr/reference/ts_simplify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simplify the tree sequence down to a given set of individuals — ts_simplify","text":"Tree-sequence object class slendr_ts, serves interface point Python module tskit using slendr functions ts_ prefix.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_simplify.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simplify the tree sequence down to a given set of individuals — ts_simplify","text":"simplification process used remove redundant information tree sequence retains information necessary describe genealogical history set samples. information simplification works pyslim tskit, see official documentation https://tskit.dev/tskit/docs/stable/python-api.html#tskit.TreeSequence.simplify https://tskit.dev/pyslim/docs/latest/tutorial.html#simplification. clear description difference remembering retaining use techniques implement historical individuals (.e. ancient DNA samples) pyslim documentation https://tskit.dev/pyslim/docs/latest/tutorial.html#historical-individuals.","code":""},{"path":[]},{"path":"https://bodkan.net/slendr/reference/ts_simplify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simplify the tree sequence down to a given set of individuals — ts_simplify","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  ts <- ts_read(slendr_ts, model) ts #> ╔════════════════════════╗ #> ║TreeSequence            ║ #> ╠═══════════════╤════════╣ #> ║Trees          │      68║ #> ╟───────────────┼────────╢ #> ║Sequence Length│ 500,000║ #> ╟───────────────┼────────╢ #> ║Time Units     │   ticks║ #> ╟───────────────┼────────╢ #> ║Sample Nodes   │      26║ #> ╟───────────────┼────────╢ #> ║Total Size     │79.6 KiB║ #> ╚═══════════════╧════════╝ #> ╔═══════════╤════╤════════╤════════════╗ #> ║Table      │Rows│Size    │Has Metadata║ #> ╠═══════════╪════╪════════╪════════════╣ #> ║Edges      │ 294│ 9.2 KiB│          No║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Individuals│  71│ 8.7 KiB│         Yes║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Migrations │   0│ 8 Bytes│          No║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Mutations  │   0│ 1.2 KiB│          No║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Nodes      │  85│ 4.7 KiB│         Yes║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Populations│   5│ 2.6 KiB│         Yes║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Provenances│   3│46.2 KiB│          No║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Sites      │   0│16 Bytes│          No║ #> ╚═══════════╧════╧════════╧════════════╝ #>   # simplify tree sequence to sampled individuals ts_simplified <- ts_simplify(ts)  # simplify to a subset of sampled individuals ts_small <- ts_simplify(ts, simplify_to = c(\"CH_1\", \"NEA_1\", \"NEA_2\", \"AFR_1\",                                             \"AFR_2\", \"EUR_1\", \"EUR_2\"))  ts_small #> ╔════════════════════════╗ #> ║TreeSequence            ║ #> ╠═══════════════╤════════╣ #> ║Trees          │      27║ #> ╟───────────────┼────────╢ #> ║Sequence Length│ 500,000║ #> ╟───────────────┼────────╢ #> ║Time Units     │   ticks║ #> ╟───────────────┼────────╢ #> ║Sample Nodes   │      14║ #> ╟───────────────┼────────╢ #> ║Total Size     │68.1 KiB║ #> ╚═══════════════╧════════╝ #> ╔═══════════╤════╤════════╤════════════╗ #> ║Table      │Rows│Size    │Has Metadata║ #> ╠═══════════╪════╪════════╪════════════╣ #> ║Edges      │ 122│ 3.8 KiB│          No║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Individuals│  33│ 5.0 KiB│         Yes║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Migrations │   0│ 8 Bytes│          No║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Mutations  │   0│ 1.2 KiB│          No║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Nodes      │  40│ 3.1 KiB│         Yes║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Populations│   5│ 2.6 KiB│         Yes║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Provenances│   4│46.7 KiB│          No║ #> ╟───────────┼────┼────────┼────────────╢ #> ║Sites      │   0│16 Bytes│          No║ #> ╚═══════════╧════╧════════╧════════════╝ #>"},{"path":"https://bodkan.net/slendr/reference/ts_table.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the table of individuals/nodes/edges/mutations/sites from the tree sequence — ts_table","title":"Get the table of individuals/nodes/edges/mutations/sites from the tree sequence — ts_table","text":"function extracts data given tree sequence table. times converted model-specific time units tskit's \"generations backwards\" time direction.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_table.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the table of individuals/nodes/edges/mutations/sites from the tree sequence — ts_table","text":"","code":"ts_table(ts, table = c(\"individuals\", \"edges\", \"nodes\", \"mutations\", \"sites\"))"},{"path":"https://bodkan.net/slendr/reference/ts_table.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the table of individuals/nodes/edges/mutations/sites from the tree sequence — ts_table","text":"ts Tree sequence object class slendr_ts table tree sequence table return","code":""},{"path":"https://bodkan.net/slendr/reference/ts_table.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the table of individuals/nodes/edges/mutations/sites from the tree sequence — ts_table","text":"Data frame information give tree-sequence table (can either table individuals, edges, nodes, mutations).","code":""},{"path":"https://bodkan.net/slendr/reference/ts_table.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the table of individuals/nodes/edges/mutations/sites from the tree sequence — ts_table","text":"processing analyses, output function ts_nodes might useful, merges information node individual tables one table annotates useful information model configuration data.","code":""},{"path":[]},{"path":"https://bodkan.net/slendr/reference/ts_table.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the table of individuals/nodes/edges/mutations/sites from the tree sequence — ts_table","text":"","code":"# load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk and add mutations to it ts <- ts_read(slendr_ts, model) %>% ts_mutate(mutation_rate = 1e-8, random_seed = 42)  # get the 'raw' tskit table of individuals ts_table(ts, \"individuals\") #> # A tibble: 71 × 9 #>    ind_id  time pedigree_id  pop_id alive remembered retained sampled time_tskit #>     <dbl> <dbl>       <dbl> <int[1> <lgl> <lgl>      <lgl>    <lgl>    <dbl[1d]> #>  1      0   -10    16023346       0 TRUE  TRUE       TRUE     TRUE             0 #>  2      1   -10    16023350       1 TRUE  TRUE       TRUE     TRUE             0 #>  3      2   -10    16023352       1 TRUE  TRUE       TRUE     TRUE             0 #>  4      3   -10    16023353       1 TRUE  TRUE       TRUE     TRUE             0 #>  5      4   -10    16023355       1 TRUE  TRUE       TRUE     TRUE             0 #>  6      5   -10    16023359       1 TRUE  TRUE       TRUE     TRUE             0 #>  7      6   -10    16024625       3 TRUE  TRUE       TRUE     TRUE             0 #>  8      7   -10    16025081       3 TRUE  TRUE       TRUE     TRUE             0 #>  9      8   -10    16025520       3 TRUE  TRUE       TRUE     TRUE             0 #> 10      9   -10    16026684       3 TRUE  TRUE       TRUE     TRUE             0 #> # ℹ 61 more rows  # get the 'raw' tskit table of edges ts_table(ts, \"edges\") #> # A tibble: 294 × 5 #>       id child parent   left  right #>    <dbl> <int>  <int>  <dbl>  <dbl> #>  1     0     6     26      0 500000 #>  2     1    13     26      0 500000 #>  3     2     7     27      0 500000 #>  4     3     8     27      0 500000 #>  5     4    12     27      0 500000 #>  6     5     5     28      0 500000 #>  7     6    10     28      0 500000 #>  8     7    11     29 306056 500000 #>  9     8    26     29 306056 500000 #> 10     9    27     30      0 500000 #> # ℹ 284 more rows  # get the 'raw' tskit table of nodes ts_table(ts, \"nodes\") #> # A tibble: 85 × 5 #>    node_id    ind_id pop_id  time time_tskit #>      <int> <int[1d]>  <int> <dbl>      <dbl> #>  1       0        24      2 70010       2334 #>  2       1        24      2 70010       2334 #>  3       2        41      2 40010       1334 #>  4       3        41      2 40010       1334 #>  5       4         1      1   -10          0 #>  6       5         1      1   -10          0 #>  7       6         2      1   -10          0 #>  8       7         2      1   -10          0 #>  9       8         3      1   -10          0 #> 10       9         3      1   -10          0 #> # ℹ 75 more rows  # get the 'raw' tskit table of mutations ts_table(ts, \"mutations\") #> # A tibble: 2,213 × 5 #>       id  site  node     time time_tskit #>    <dbl> <int> <int>    <dbl>      <dbl> #>  1     0     0    81  588320.     19611. #>  2     1     1    82 5259704.    175324. #>  3     2     2    82  757010.     25234. #>  4     3     3    81  241423.      8048. #>  5     4     4    32 3622571.    120753. #>  6     5     5    32  104626.      3488. #>  7     6     6    82 5179605.    172654. #>  8     7     7    82 5212483.    173750. #>  9     8     8    82 2373328.     79111. #> 10     9     9    32 1159112.     38637. #> # ℹ 2,203 more rows  # get the 'raw' tskit table of sites ts_table(ts, \"sites\") #> # A tibble: 2,210 × 3 #>       id position ancestral_state #>    <dbl>    <dbl> <chr>           #>  1     0      572 C               #>  2     1      782 T               #>  3     2     1609 C               #>  4     3     2033 G               #>  5     4     2316 A               #>  6     5     2469 T               #>  7     6     2614 G               #>  8     7     2752 T               #>  9     8     2879 A               #> 10     9     3192 G               #> # ℹ 2,200 more rows"},{"path":"https://bodkan.net/slendr/reference/ts_tajima.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Tajima's D for given sets of individuals — ts_tajima","title":"Calculate Tajima's D for given sets of individuals — ts_tajima","text":"discussion difference \"site\" \"branch\" options mode argument, please see tskit documentation https://tskit.dev/tskit/docs/stable/stats.html#sec-stats-mode","code":""},{"path":"https://bodkan.net/slendr/reference/ts_tajima.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Tajima's D for given sets of individuals — ts_tajima","text":"","code":"ts_tajima(ts, sample_sets, mode = c(\"site\", \"branch\", \"node\"), windows = NULL)"},{"path":"https://bodkan.net/slendr/reference/ts_tajima.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Tajima's D for given sets of individuals — ts_tajima","text":"ts Tree sequence object class slendr_ts sample_sets list (optionally named list) character vectors individual names (one vector per set). simple vector provided, interpreted .list(sample_sets), meaning given statistic calculated individual separately. mode mode calculation (\"sites\" \"branch\") windows Coordinates breakpoints windows. first coordinate (0) last coordinate (equal ts$sequence_length) added automatically)","code":""},{"path":"https://bodkan.net/slendr/reference/ts_tajima.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Tajima's D for given sets of individuals — ts_tajima","text":"set individuals either single Tajima's D value vector Tajima's D values (one window)","code":""},{"path":"https://bodkan.net/slendr/reference/ts_tajima.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Tajima's D for given sets of individuals — ts_tajima","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk ts <- ts_read(slendr_ts, model) %>% ts_mutate(mutation_rate = 1e-8, random_seed = 42)  # calculate Tajima's D for given sets of individuals in a tree sequence ts ts_tajima(ts, list(eur = c(\"EUR_1\", \"EUR_2\", \"EUR_3\", \"EUR_4\", \"EUR_5\"),                    nea = c(\"NEA_1\", \"NEA_2\"))) #> # A tibble: 2 × 2 #>   set       D #>   <chr> <dbl> #> 1 eur   -1.00 #> 2 nea    2.16"},{"path":"https://bodkan.net/slendr/reference/ts_tracts.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract ancestry tracts from a tree sequence (EXPERIMENTAL) — ts_tracts","title":"Extract ancestry tracts from a tree sequence (EXPERIMENTAL) — ts_tracts","text":"Extract data frame coordinates ancestry tracts given tree sequence.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_tracts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract ancestry tracts from a tree sequence (EXPERIMENTAL) — ts_tracts","text":"","code":"ts_tracts(   ts,   census,   squashed = TRUE,   source = NULL,   target = NULL,   quiet = FALSE )"},{"path":"https://bodkan.net/slendr/reference/ts_tracts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract ancestry tracts from a tree sequence (EXPERIMENTAL) — ts_tracts","text":"ts Tree sequence object class slendr_ts census Census time. See documentation linked Details information. slendr-specific tree sequence provided ts, census time expected given slendr model-specific time units, must correspond gene-flow event encoded model. squashed ancestry tracts squashed (.e., continuous tracts can traced different ancestral nodes merged)? Default TRUE. FALSE, effectively continuous ancestry tracts split individual segments, assigned specific ancestral node ID (recorded column ancestor_id). source source population extract tracts ? NULL (default), ancestry tracts populations contributing gene flow census time reported. Otherwise, ancestry tracts specified source populations extracted. Note option ignored non-slendr tree sequences! target Similar purpose source , except filters tracts discovered target population(s) quiet default summary output tspop Python package silenced? Default FALSE.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_tracts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract ancestry tracts from a tree sequence (EXPERIMENTAL) — ts_tracts","text":"data frame containing coordinates ancestry tracts","code":""},{"path":"https://bodkan.net/slendr/reference/ts_tracts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract ancestry tracts from a tree sequence (EXPERIMENTAL) — ts_tracts","text":"function implements R-friendly interface algorithm extracting ancestry tracts provided Python module tspop https://tspop.readthedocs.io/en/latest/ developed Georgia Tsambos. Please make sure cite paper describes algorithm detail: doi:10.1093/bioadv/vbad163 . technical details, see also tutorial : https://tspop.readthedocs.io/en/latest/basicusage.html. general, using function slendr-generated tree sequence, please aware output changes slightly get running pure tspop.get_pop_ancestry() Python. First, ts_tracts() populates output data frame additional metadata (names individuals populations). Additionally, slendr models, specifically designed return ancestry tracts originating ancestral population contributed ancestry gene-flow event started specific time (.e., scheduled model via gene_flow()) function. return every single ancestry tracts present tree sequence every single sample node (every single potential ancestry population) tspop.get_pop_ancestry() Python method. said, run tree sequence originate slendr simulation, behavior ts_tracts() identical underlying tspop.get_pop_ancestry(). current version slendr, ts_tracts() works slendr/msprime sequences slendr/SLiM tree sequences. Support slendr-generated SLiM tree sequences development. Tracts tree sequences originating non-slendr msprime SLiM simulations restricted way , mentioned previous paragraph, ts_tracts() situation effectively reduces standard tspop.get_pop_ancestry() call.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_tracts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract ancestry tracts from a tree sequence (EXPERIMENTAL) — ts_tracts","text":"","code":"init_env(quiet = TRUE)  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_msprime.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk ts <- ts_read(file = slendr_ts, model = model)  # extract Neanderthal ancestry tracts (i.e. those corresponding to the # census event at the gene-flow time at 55000 kya as scheduled by # the simulation which produced the tree sequence) nea_tracts <- ts_tracts(ts, census = 55000, source = \"NEA\") #>  #> PopAncestry summary #> Number of ancestral populations: \t4 #> Number of sample chromosomes: \t\t26 #> Number of ancestors: \t\t\t187 #> Total length of genomes: \t\t26000000.000000 #> Ancestral coverage: \t\t\t24000000.000000 #>  nea_tracts #> # A tibble: 0 × 10 #> # ℹ 10 variables: name <chr>, haplotype <int>, time <dbl>, pop <chr>, #> #   source_pop <fct>, left <dbl>, right <dbl>, length <dbl>, #> #   source_pop_id <dbl>, node_id <dbl>"},{"path":"https://bodkan.net/slendr/reference/ts_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a tree from a given tree sequence — ts_tree","title":"Get a tree from a given tree sequence — ts_tree","text":"information optional keyword arguments see tskit documentation: https://tskit.dev/tskit/docs/stable/python-api.html#-treesequence-class","code":""},{"path":"https://bodkan.net/slendr/reference/ts_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a tree from a given tree sequence — ts_tree","text":"","code":"ts_tree(ts, i, mode = c(\"index\", \"position\"), ...)"},{"path":"https://bodkan.net/slendr/reference/ts_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a tree from a given tree sequence — ts_tree","text":"ts Tree sequence object class slendr_ts Position tree tree sequence. mode = \"index\", -th tree returned (zero-based indexing tskit), mode = \"position\", tree covering -th base simulated genome returned (, tskit's indexing). mode argument interpreted? Either \"index\" -th tree sequence genealogies, \"position\" along simulated genome. ... Additional keyword arguments accepted tskit.TreeSequence.tskit.TreeSequence.at_index methods","code":""},{"path":"https://bodkan.net/slendr/reference/ts_tree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a tree from a given tree sequence — ts_tree","text":"Python-reticulate-based object class tskit.trees.Tree","code":""},{"path":"https://bodkan.net/slendr/reference/ts_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a tree from a given tree sequence — ts_tree","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree-sequence object from disk ts <- ts_read(slendr_ts, model)  # extract the zero-th tree in the tree sequence tree <- ts_tree(ts, i = 0)  # extract the tree at a position in the tree sequence tree <- ts_tree(ts, i = 100000, mode = \"position\")"},{"path":"https://bodkan.net/slendr/reference/ts_vcf.html","id":null,"dir":"Reference","previous_headings":"","what":"Save genotypes from the tree sequence as a VCF file — ts_vcf","title":"Save genotypes from the tree sequence as a VCF file — ts_vcf","text":"function writes VCF file diploid genotypes given tree sequence.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_vcf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save genotypes from the tree sequence as a VCF file — ts_vcf","text":"","code":"ts_vcf(   ts,   path,   chrom = \"chr1\",   individuals = NULL,   position_transform = \"lambda x: np.fmax(1, x)\" )"},{"path":"https://bodkan.net/slendr/reference/ts_vcf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save genotypes from the tree sequence as a VCF file — ts_vcf","text":"ts Tree sequence object class slendr_ts path Path VCF file chrom Chromosome name written CHROM column VCF (default value \"chr1\"). individuals vector individuals tree sequence extract genotypes . missing, individuals present tree sequence saved. slendr-based tree sequence character vector individual names expected. non-slendr tree sequences, numeric vector IDs individuals expected. position_transform transform coordinates tree sequence coordinates VCF file? default, site coordinate 0 converted position 1 ensure resulting VCF file adheres VCF specification. Setting NULL disable ","code":""},{"path":"https://bodkan.net/slendr/reference/ts_vcf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Save genotypes from the tree sequence as a VCF file — ts_vcf","text":"return value, called side effects","code":""},{"path":"https://bodkan.net/slendr/reference/ts_vcf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Save genotypes from the tree sequence as a VCF file — ts_vcf","text":"Users note , many tskit-based slendr functions, ts_vcf intended provide convenient defaults. instance, even non-slendr tree sequences, name individual genotype columns integer IDs. words, individuals function argument given c(1, 42, 123), individuals named \"ind_1\", \"ind_42\", \"ind_123\", instead \"tsk_0\", \"tsk_1\", \"tsk_2\". said, reticulate-based Python interface slendr allows calling write_vcf function tskit directly! default, simulating tree sequence msprime exporting genotypes VCF can cause issues downstream software VCF specification allow sites position 0. default ts_vcf automatically transforms site zero coordinate coordinate 1. Setting position_transform NULL disable , tsv_vcf save coordinates original form. See discussion detail: https://github.com/tskit-dev/tskit/issues/2838#issuecomment-1931796988, well relevant topics tskit documentation issue, like : https://tskit.dev/tskit/docs/latest/export.html#modifying-coordinates.","code":""},{"path":"https://bodkan.net/slendr/reference/ts_write.html","id":null,"dir":"Reference","previous_headings":"","what":"Save a tree sequence to a file — ts_write","title":"Save a tree sequence to a file — ts_write","text":"Save tree sequence file","code":""},{"path":"https://bodkan.net/slendr/reference/ts_write.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save a tree sequence to a file — ts_write","text":"","code":"ts_write(ts, file)"},{"path":"https://bodkan.net/slendr/reference/ts_write.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save a tree sequence to a file — ts_write","text":"ts Tree sequence object loaded ts_read file File tree sequence saved","code":""},{"path":"https://bodkan.net/slendr/reference/ts_write.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Save a tree sequence to a file — ts_write","text":"return value, called side effects","code":""},{"path":"https://bodkan.net/slendr/reference/ts_write.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Save a tree sequence to a file — ts_write","text":"","code":"init_env() #> The interface to all required Python modules has been activated.  # load an example model with an already simulated tree sequence slendr_ts <- system.file(\"extdata/models/introgression_slim.trees\", package = \"slendr\") model <- read_model(path = system.file(\"extdata/models/introgression\", package = \"slendr\"))  # load the tree sequence ts <- ts_read(slendr_ts, model)  # save the tree-sequence object to a different location another_file <- paste(tempfile(), \".trees\") ts_write(ts, another_file)"},{"path":"https://bodkan.net/slendr/reference/world.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a world map for all spatial operations — world","title":"Define a world map for all spatial operations — world","text":"Defines either abstract geographic landscape (blank containing user-defined landscape) using real Earth cartographic data Natural Earth project (https://www.naturalearthdata.com).","code":""},{"path":"https://bodkan.net/slendr/reference/world.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a world map for all spatial operations — world","text":"","code":"world(   xrange,   yrange,   landscape = \"naturalearth\",   crs = NULL,   scale = c(\"small\", \"medium\", \"large\") )"},{"path":"https://bodkan.net/slendr/reference/world.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a world map for all spatial operations — world","text":"xrange Two-dimensional vector specifying minimum maximum horizontal range (\"longitude\" using real Earth cartographic data) yrange Two-dimensional vector specifying minimum maximum vertical range (\"latitude\" using real Earth cartographic data) landscape Either \"blank\" (blank abstract geography), \"naturalearth\" (real Earth geography) object class sf defining abstract geographic features world crs EPSG code coordinate reference system use spatial operations. CRS assumed default (NULL), implying abstract landscape tied real-world geographic region (landscape = \"blank\" landscape custom-defined geographic landscape), implying WGS-84 (EPSG 4326) coordinate system real Earth landscape defined (landscape =   \"naturalearth\"). scale Natural Earth geographic data used (.e. landscape =   \"naturalearth\"), parameter determines resolution data used. value \"small\" corresponds 1:110m data provided package, values \"medium\" \"large\" correspond 1:50m 1:10m respectively downloaded internet. Default value \"small\".","code":""},{"path":"https://bodkan.net/slendr/reference/world.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a world map for all spatial operations — world","text":"Object class slendr_map, encodes standard spatial object class sf additional slendr-specific attributes requested x-range y-range.","code":""},{"path":"https://bodkan.net/slendr/reference/world.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define a world map for all spatial operations — world","text":"","code":"# create a blank abstract world 1000x1000 distance units in size blank_map <- world(xrange = c(0, 1000), yrange = c(0, 1000), landscape = \"blank\")  # it is possible to construct custom landscapes (islands, corridors, etc.) island1 <- region(\"island1\", polygon = list(c(10, 30), c(50, 30), c(40, 50), c(0, 40))) island2 <- region(\"island2\", polygon = list(c(60, 60), c(80, 40), c(100, 60), c(80, 80))) island3 <- region(\"island3\", center = c(20, 80), radius = 10) archipelago <- island1 %>% join(island2) %>% join(island3)  custom_map <- world(xrange = c(1, 100), c(1, 100), landscape = archipelago)  # real Earth landscapes can be defined using freely-available Natural Earth # project data and with the possibility to specify an appropriate Coordinate # Reference System, such as this example of a map of Europe  real_map <- world(xrange = c(-15, 40), yrange = c(30, 60), crs = \"EPSG:3035\")"},{"path":"https://bodkan.net/slendr/news/index.html","id":"slendr-development-version","dir":"Changelog","previous_headings":"","what":"slendr (development version)","title":"slendr (development version)","text":"Two new arguments gene_flow() specifying magnitude migration implemented, clarifying confusion original implementation (see #99 example): migration_rate specifies rate gene flow per unit time given gene-flow time window; proportion specifies total amount ancestry received population given source population time span gene-flow event (, effectively, rate argument meant point, somewhat confusingly unless user looked manpage gene_flow() function). far original argument rate concerned, setting value argument gene_flow() call now issue informative warning message deprecation future major release. However, old code remain working without change foreseeable future. Furthermore, gene_flow() now includes guard given migration_rate potentially resulting proportion ancestry higher 1.0 (aggregated total span gene-flow window), meaning users’ code run hidden bugs even eventual deprecation rate. (PR #188) Due issues user’s system Python 3.13 binary installed conda (related built-pyexpat module), slendr now reverted Python 3.12. far can tell, related either broken Python 3.13 distributed conda architectures, issue reticulate’s interaction Python version. Either way, downgrading Python 3.12 affect functionality slendr worth defensive measure case users future run similar problem. (#b2e5c6)","code":""},{"path":"https://bodkan.net/slendr/news/index.html","id":"slendr-130","dir":"Changelog","previous_headings":"","what":"slendr 1.3.0","title":"slendr 1.3.0","text":"CRAN release: 2025-11-11 order minimize dependency burden users even , packages shiny shinyWidgets now installed default. function explore_model() function now checks packages present upon calling . , user informed install packages first. (#60fbdf) plot_map() now option arrows instructs function whether (arrows = TRUE) (arrows = FALSE) “spatial gene-flow links” demes feature arrowheads. intended help visualizations many spatial demes, models dense spatial deme lattices. end, sf / ggplot2 layout produced plot_map() also tweaked accordingly. (#ebbaad) internal dependencies slendr upgraded. SLiM v5.1 now required; init_env() instruct users new Python environment needs created setup_env() update pyslim v1.1.0. Additionally, (though rather inconsequential slendr users), Python environment now utilizes Python 3.13. (issue #186).","code":""},{"path":"https://bodkan.net/slendr/news/index.html","id":"slendr-120","dir":"Changelog","previous_headings":"","what":"slendr 1.2.0","title":"slendr 1.2.0","text":"CRAN release: 2025-07-31 Due new issues related conda activating environments incorrect path started pop (possibly due misfeature reticulate package), activating procedure slendr reverted slower, apparently robust approach. unfortunately make running massively parallelized simulations Windows problematic due suspected--hard--detect race condition conda Windows, manifested executing many parallel environment activations (one simulation process) platform. time , users advised execute big parallelized simulations (’re talking thousands simulations ABC setting) unix systems. (PR #182) slendr now allows recording specific singular samples unique names. See documentation schedule_sampling() example. (PR #181) dependency rnaturalearth introduced low-level changes required minor tweaks slendr’s spatial internals. Thanks @PMassicotte kind help fixing ! (PR #180) Fixed issue setting lock = TRUE set_range() function (issue #176 reported @Sgornard – thank !). (#6d01e407) non-spatial population created spatial parent population, slendr gives informative error message. (#6bb646) plot_model() now uses color population ranges population labels. (#c54632e5) plot_map() can now optionally visualize splits spatial setting (#4664388c) plot_model() now plots y-axis time using readable integer scale. (#6b0e7fcc)","code":""},{"path":"https://bodkan.net/slendr/news/index.html","id":"slendr-110","dir":"Changelog","previous_headings":"","what":"slendr 1.1.0","title":"slendr 1.1.0","text":"CRAN release: 2025-06-03 relatively modest release, mostly pushed keep slendr step recent release SLiM 5.0 new releases msprime tskit. result, slendr’s SLiM-based functionality (particularly new “SLiM extension” mechanism) requires SLiM 5.0 SLiM 5 now required run slim() simulations slendr. Similarly, tskit msprime upgraded versions 0.6.4 1.3.4, respectively. (PR #173) schedule_sampling() now checks sampled populations actually present compiled model (#97abf75) Data frames produced ts_tracts() slendr-produced tree sequences now include time recorded sample carrying given tract (#a28b264) user-friendly haplotype number (#9c4724) tract belongs (.e., either number 1 2, depending respective chromosome simulated individual). ts_vcf() now robust (useful) handling slendr non-slendr tree sequences. However, please take note potentially problematic situations involved tskit VCF conversion method, solutions discussed . resolve, consider ts_vcf() current form rather experimental. Also, reminder, note can always use Python tskit functionality functionality directly R, using reticulate interface. (#c26907) default, ts_vcf() now automatically transforms site coordinate 0 1. done make sure produced VCF file adheres VCF specification. See relevant discussion tskit repository information. (#3a8c7a) get_python() now replaces get_env() function introduced earlier release. function returns full path Python binary part slendr virtual Python environment. , can directly ran command line, resulting Python session slendr Python dependencies (tskit, msprime, etc.) available import. (#a76d3f) new option quiet = now controls whether ts_genotypes() write message multiallelic sites encountered conversion tree-sequence object. (#9260c6)","code":""},{"path":"https://bodkan.net/slendr/news/index.html","id":"slendr-100","dir":"Changelog","previous_headings":"","what":"slendr 1.0.0","title":"slendr 1.0.0","text":"CRAN release: 2024-11-22 massive update introducing possibility simulating non-neutral slendr models slim() introduced. update big describe changelog – information motivation, see description associated PR, new extensive vignette topic. (PR #155) Implementing changes v1.0 release (particularly support non-neutral models) required changing slendr internals low level across whole codebase. Feedback functionality, missing features, bug reports highly appreciated! changes: behavior previously implemented via output = ts = arguments slim() (msprime()) changed facilitate straightforward handling output paths user-defined SLiM extensions packages leveraging slendr inference. slim() msprime() function interfaces now simplified following way: slim(): ts argument now logical. TRUE switches tree-sequence recording, FALSE switches . tree-sequence recording (default setting), function automatically returns tree-sequence R object. users want save custom location, use function ts_write() returned tree-sequence object. customized output files produced via user-defined extension scripts, scripts can use slendr/SLiM constant PATH, always available built-SLiM script can set R via slim(..., path = <path directory>). case, slim() function always returns path back. Crucially, case slim() return tree sequence object, object can loaded ts_read(\"<path directory>/slim.trees\"). words, nothing changes usual SLiM-based slendr workflow, models generating custom output files, small amount work needed load tree sequence – tree-sequence file outputs therefore treated exactly way non-tree-sequence user-defined output files. result changes, slim() longer accepts load = TRUE|FALSE argument. implemented PR #157. ts_genotypes() now works even non-slendr tree sequences, slendr individual names samples ts_nodes() output. (#d348ec) Due frequent issues installation Python dependencies slendr completely platform independent way (latest instance conda installation pyslim crashing M-architecture Macs), setup_env() now uses conda install msprime tskit – pyslim tspop always installed via pip regardless whether setup_env(pip = FALSE) (default) setup_env(pip = TRUE) used. (#408948) new function extract_parameters() can extract parameters either compiled slendr model object tree sequence simulated slendr model. can useful particularly simulation-based inferences model parameters often drawn random distributions ’s need know parameters model (split times, gene-flow rates, etc.) drawn. (#3632bd0) compile_model() now allows specify description time units used scheduling slendr model events. purely descriptive purpose – particular, units used model plotting functions, etc. (#9b5b7ea0) slim_script argument compile_model() replaced extension argument, allows users provide custom-designed SLiM snippets extending behavior slendr’s SLiM simulation engine. (#d11ac7) sim_length argument compile_model() removed following long period deprecatiaon. (#12da50) named list samples used X input ts_f4ratio(), name element used X column resulting data frame. (#0571a6) ts_table() can now extract “sites” tskit table ts_table(ts, \"sites\"). (#e708f2) applied slendr tree sequences, ts_recapitate() longer issues warning: TimeUnitsMismatchWarning: initial_state time_units=ticks time measured generations msprime. may lead significant discrepancies timescales. wish suppress warning, can use, e.g., warnings.simplefilter('ignore', msprime.TimeUnitsMismatchWarning). slendr tree sequences, ticks thing generations anyway. (#43c45083) Running slim(..., method = \"gui\") broken due recent changes make slendr work Windows. path generated SLiM script executed SLiMgui incorrectly normalized. Non-SLiMgui runs affected. (#ccae1df)","code":""},{"path":"https://bodkan.net/slendr/news/index.html","id":"slendr-091","dir":"Changelog","previous_headings":"","what":"slendr 0.9.1","title":"slendr 0.9.1","text":"CRAN release: 2024-02-21 new helper function get_env() now returns name built-slendr Python environment (without activating ). (#162ccc) clear_env() now new argument = (TRUE|FALSE) allows deleting slendr Python environments. Previously, function always removed recent environment, lead accumulation potentially large number slendr environments time. (#8707b9) plot_model() new optional argument samples = – set result sampling schedule created schedule_sampling() – visualize counts samples recorded given time-point. (#d72ac5) msprime dependency slendr updated version 1.3.1. result, setup_env() re-run update internal slendr Python environment. (#dcb83d)","code":""},{"path":"https://bodkan.net/slendr/news/index.html","id":"slendr-090","dir":"Changelog","previous_headings":"","what":"slendr 0.9.0","title":"slendr 0.9.0","text":"CRAN release: 2024-02-08 full support running SLiM msprime simulations slendr analyzing tree sequences using tskit interface implemented. Please note Windows support still rather experimental – internal slendr test suite currently assumes SLiM installed using msys2 system described section 2.3.1 SLiM manual means installing SLiM (via conda) might require additional adjustments. fallback option form slim_path= argument slim() function can used non-standard SLiM installation circumstances. convenience, please add path directory containing slim.exe binary PATH variable editing C:/Users/<username>/Documents/.Renviron file accordingly. See relevant section Windows installation slendr documentation additional information. Feedback Windows functionality bug reports highly appreciated via GitHub issues! Many thanks @GKresearch @rdinnager huge help making Windows port happen! (PR #149) trivial change made slendr’s SLiM back-end script fixing issue introduced SLiM 4.1 upgrade (see changelog version 0.8.1 ). expected lead different simulation outputs two versions slendr (0.8.2 vs 0.8.1) SLiM (4.1 vs 4.0.1) used. (PR #148) msprime internal dependency slendr updated 1.3.0, Python 3.12. result, loading slendr, users prompted re-run setup_env() make sure dedicated slendr Python environment fully updated. time, prevents failing installation (least) M1 macOS using pip. (#5ce212, #a210d4)","code":""},{"path":"https://bodkan.net/slendr/news/index.html","id":"slendr-081","dir":"Changelog","previous_headings":"","what":"slendr 0.8.1","title":"slendr 0.8.1","text":"CRAN release: 2024-01-15 Fixed issue apparent contradiction time direction models range expansion scheduled within time interval together associated “locked-” changes population size time interval. (#d2a29e) introduction tspop installable via pip (see changelog previous version) caused GLIBCXX-related errors conda pip dependencies related pandas Python package. work around issue, setup_env() longer installs pandas conda regardless setting pip = TRUE|FALSE parameter. Instead, pandas installed via pip single step tspop installed. (#cbe960) WARNING: SLiM 4.1 just released includes couple backwards incompatible changes related implementation spatial maps prevent current version slendr’s slim() function working correctly. rely functionality provided slim() function, use SLiM 4.0. (Note want multiple versions SLiM system, can either use slim_path = argument slim() specify $PATH required version SLiM ~/.Renviron file just like normal circumstances). Porting slendr SLiM 4.1 worked .","code":""},{"path":"https://bodkan.net/slendr/news/index.html","id":"slendr-080","dir":"Changelog","previous_headings":"","what":"slendr 0.8.0","title":"slendr 0.8.0","text":"CRAN release: 2023-12-07 order support new ts_tracts() function backed tspop module (see item ), new slendr Python environment required. , users run setup_env() get required Python dependencies now installed internal virtual environment named Python-3.11_msprime-1.2.0_tskit-0.5.6_pyslim-1.0.4_tspop-0.0.2. (#b5330c) Experimental support tspop link-ancestors algorithm detection ancestry tracts form new slendr function ts_tracts(). works slendr-generated msprime tree sequences “pure” msprime SLiM tree sequences (slendr-generated SLiM tree sequences), tested toy models. Note: tspop Python module published conda. order set new slendr Python environment, run setup_env(pip = TRUE) make sure Python dependencies installed pip instead conda. (PR #145) Updated Python dependencies (bugfix pyslim release v1.0.4 tskit v0.5.6, latter due broken jsonschema dependency tskit). (#001ee5) Experimental support manually created spatial tree sequences. (PR #144)","code":""},{"path":"https://bodkan.net/slendr/news/index.html","id":"slendr-072","dir":"Changelog","previous_headings":"","what":"slendr 0.7.2","title":"slendr 0.7.2","text":"CRAN release: 2023-08-08 new function ts_names() added, avoiding need extremely frequent (, unfortunately, cumbersome) trick getting named lists individual symbolic names ts_samples(ts) %>% split(., .[[split]]) %>% lapply([[, \"name\") confusing experienced R users. (#7db6ea) Fixed broken concatenation symbolic sample names tree-sequence statistic functions, provided unnamed single-element lists character vectors. (#b3c650) plot_model() now argument file =, making possible save visualization model without actually opening plotting device. can useful particularly working remote server, order avoid often slow X11 rendering. (#e60078) plot_model() now argument order = allowing override default -order ordering populations along x-axis. (#7a10ea)","code":""},{"path":"https://bodkan.net/slendr/news/index.html","id":"slendr-071","dir":"Changelog","previous_headings":"","what":"slendr 0.7.1","title":"slendr 0.7.1","text":"CRAN release: 2023-07-14 Starting release, *spatial* simulation data analysis functionality slendr conditional presence R geospatial packages sf, stars, rnaturalearth system. means users able install slendr (use non-spatial functionality) even without R packages installed. said, nothing really changes practice: spatial features slendr just one install.packages(c(\"sf\", \"stars\", \"rnaturalearth\")) away! difference slendr doesn’t try installation, users instructed (needed) package loaded. (#7a10ea) spatial dependencies present spatial slendr function called regardless (world(), move(), etc.), error message printed information install spatial dependencies via install.packages() . ? ’s true main reason slendr’s existence ability simulate spatio-temporal data realistic landscapes via SLiM. However, practice, “average” uses slendr wild (classrooms!) rely traditional, non-spatial interface, spatial features used comparatively rarely moment (except cutting-edge exploratory research). Given setting spatial dependencies can bit hurdle, decided make dependencies optional, rather force every user go process installation whether need spatial features . function check_dependencies() now exported can used check whether slendr Python environment () SLiM () present. useful software building upon slendr, normal users can freely ignore . (#6ae6ce) path file tree sequence loaded now tracked internally via attr(<tree sequence>, \"path\") attribute. Note implemented purposes clean large-scale simulation studies (facilitated demografr) mostly internal feature, considered experimental. (#f181a2) Attempts resize population right time split (led issues simulations) now prevented. (#f181a2) Fix minor issue preventing sampling msprime population right time creation. (#aea231)","code":""},{"path":"https://bodkan.net/slendr/news/index.html","id":"slendr-070","dir":"Changelog","previous_headings":"","what":"slendr 0.7.0","title":"slendr 0.7.0","text":"CRAN release: 2023-06-26 emergency upgrade match latest pyslim 1.0.3 due serious bug recapitation. See extensive discussion process identification bug eventual fix. brief summary practical consequences bug, see thread pyslim’s developer formal announcement . change require re-run setup_env() order update slendr’s Python internals creating new internal Python virtual environment. (#45539a) potential issue parent population scheduled removal daughter population splits now caught moment daughter population() call rather simulation slim() run. (#0791b5) function plot_model() new argument gene_flow=<TRUE|FALSE> determines whether gene-flow arrows visualized . (#104aa6) possibility perform recapitation, simplification, mutation tree sequence right inside call ts_read() (providing recapitate = TRUE, simplify = TRUE, mutate = TRUE, together arguments) now removed. motivation change realization benefit things like ts_read(\"<path>\", recapitate = TRUE, Ne = ..., recombination_rate = ...) ts_read(\"<path>\") %>% ts_recapitate(Ne = ..., recombination_rate = ...), frequent confusion recapitate = TRUE switches forgotten user. slendr teaching material actively used research codebases know use latter, explicit, pipeline approach anyway, one example reduncancy harm good. (#ad82ee) Note: Loading library(slendr) prompt message “legacy packages maptools, rgdal, rgeos, underpinning sp package, just loaded, retire October 2023. […].” internal business packages used slendr unfortunately silenced slendr’s side. ’s reason panic, can safely ignore . Apologies unnecessary noise.","code":""},{"path":"https://bodkan.net/slendr/news/index.html","id":"slendr-060","dir":"Changelog","previous_headings":"","what":"slendr 0.6.0","title":"slendr 0.6.0","text":"CRAN release: 2023-06-07 relatively large update, unfortunately released haste due retirement rgdal package – significant dependency entire spatial R ecosystem phased effort move towards modern low-level geospatial architecture. Although slendr depend rgdal, many dependencies used (won’t short term, hence push remove rgdal dependency). significant update addition IBD functionality tskit, described . However, large part functionality extensively tested considered extremely experimental stage. like use , might safer either wait later release IBD functionality stable, use underlying, battle-tested Python implementation tskit. ts_ibd() now returns ID number MRCA node pair nodes sharing given IBD segment, well TMRCA node. (#7e2825) Trivial parameter errors caught population() calls rather simulation (solving minor issues discovered via big simulation runs development demografr). (#e33373) Fix error plotting exponential resizes last “present”. (#4c49a4) ts_ibd() longer gives obscure error = provided named list individuals’ names (instead expected unnamed list). names list elements used way, error happens somewhere deeply R->Python translation layer inside reticulate ’s need users concern . (#7965e4) Population size parameters times now explicitly converted integer numbers. internal, formal change (conversion happening implicitly inside SLiM engine anyway) now explicitly stated, also documentation relevant function. (#b7e89e) Population names now restricted strings also valid Python identifiers. Although restriction needed msprime back end slendr (SLiM), makes sense keep things tidy unified. fixes msprime crashing ValueError: population name must valid Python identifier. (#4ef518) layout algorithm plot_model() improved significantly. (PR #135). new optional argument run = added slim() msprime(). set TRUE (default), engines operate usual way. set FALSE, simulation run functions simply print command-line command execute engine question (returning CLI command invisibly). (#2e5b85) following start-note longer shown upon calling library(slendr): Users call init_env() manually activate Python environment slendr (see note version 0.5.0 extended explanation). ts_simplify() now accepts optional arguments keep_unary keep_unary_in_individuals (see official tskit docs detail) (#1b2112) Fix ts_read() failing load slendr-produced tree sequences simplified smaller set sampled individuals (reported ). issue caused incompatible sizes sampling table (always form used simulation) table individuals stored tree sequence simplification (potentially containing smaller set individuals original sampling table). fix , slendr tree sequence objects now track information individuals regarded “samples” (.e. symbolic names) maintained simplification, serialization loading, used slendr’s internal machinery join operations. (PR #137) Metadata summary ts_nodes() results longer printed whenever typed R console. Instead, summary can obtained explicit call summary() ts_nodes() tables. (#01af51 ts_tree() ts_phylo() now extract trees based tskit’s zero-based indexing #554e13. ts_simplify() now accepts filter_nodes = TRUE|FALSE, behavior tskit’s method #f07ffed.","code":"NOTE: Due to Python setup issues on some systems which have been     causing trouble particularly for novice users, calling library(slendr)     no longer activates slendr's Python environment automatically.     In order to use slendr's msprime back end or its tree-sequence     functionality, users must now activate slendr's Python environment     manually by executing init_env() after calling library(slendr).     (This note will be removed in the next major version of slendr.)"},{"path":"https://bodkan.net/slendr/news/index.html","id":"slendr-051","dir":"Changelog","previous_headings":"","what":"slendr 0.5.1","title":"slendr 0.5.1","text":"CRAN release: 2023-03-09 minor release implements emergency fix CRAN warning suddenly popped latest CRAN checks. (#5600a4) new function ts_ibd() added, representing R interface tskit method TreeSequence.ibd_segments(). However, note ts_ibd() returns IBD results data frame (optionally, spatially annotated sf data frame). function operate around iteration, Python counterpart tskit. next major version slendr, function considered experimental. (PR #123)","code":""},{"path":"https://bodkan.net/slendr/news/index.html","id":"slendr-050","dir":"Changelog","previous_headings":"","what":"slendr 0.5.0","title":"slendr 0.5.0","text":"CRAN release: 2023-02-02 Minor breaking change! Python environments slendr longer automatically activated upon calling library(slendr)! Using coalescent msprime back end slendr’s tree-sequence functions now requires making explicit call new function init_env() library(slendr) executed. (PR #102) Motivation change: small proportion users experiencing issues broken conda environments various issues Python virtual environments general. ’s hard guess frequent , experience workshops courses suggests perhaps 1 20 users experiencing Python issues hindered ability use slendr .(Fun fact: first user-submitted GitHub issue upon releasing first version slendr R package … Python virtual environment issue). Explanation: Activating Python environments automatically upon calling library(slendr) popular feature hid away complexities R-Python interface powers slendr’s tree-sequence functionality. particularly convenient many slendr users, particularly experience Python . Unfortunately, cases Python virtual environments tskit/msprime/pyslim user’s system ended corrupted (anything else Python level got broken), automatic Python environment activation performed library(slendr) call failed slendr even loaded. Sadly, completely pulled rug slendr nothing done perspective (issue happened low-level layer embedded-Python slendr ’ve loaded R). Solving issues difficult experienced users, many slendr users experience Python , never used conda, don’t understand concept “Python virtual environments” R-Python interface works. ! , slendr R package. Splitting Python virtual environment activation step init_env() function means library(slendr) now always succeeds (regardless potential underlying Python issues user’s sytem), making much easier diagnose fix Python problems R package loaded. , recap: library(slendr) longer activates slendr’s isolated Python virtual environment. order simulate tree sequences analyse using interface tskit, necessary call init_env(). function performs Python-activation steps library(slendr) used call automagically earlier slendr versions. change scripts necessary. Related previous point: slendr now requires Python 3.11, msprime 1.2.0, tskit 0.5.4, pyslim 1.0.1, keep recent releases Python dependencies. , presents hassle user, thing required re-running setup_env(). (PR #112). named list provided sample_sets = argument oneway statistic function, names used set column resulting data frame even single samples used. (#2a6781) now possible non-spatial populations otherwise spatial model. course, plotting models map, spatial components model plotted slendr give warning. absolutely sure users intends , slendr also give warning running compile_model() models like . Please consider option experimental time-hard predict edge cases might break (unit tests documentation tests passing though). Feedback welcome. (PR #112). now possible label groups samples slendr’s tskit interface functions make data frames statistics results readable. example, running ts_f3(ts, = c(\"p1_1\", \"p1_2\", \"p1_3\"), B = c(\"p2_1\", \"p2_3\"), C = c(\"p3_1\", \"p3_2\", \"p3_\")) resulted following data-frame output: gets unwieldy rather quickly, especially dozens hundreds samples grouped together populations. new syntax allows following shortcut via customised group names leveraging standard named list functionality R: readable line tskit-interface functions slendr used functionality via sample_sets = argument (ts_divergence(), ts_diversity(), etc.). (#ac5e484) default state parent = argument population() now NULL instead \"ancestor\". prevents silly surprising clashes situation population’s name really “ancestor”. change internally populations ancestral, splits data frame element slendr model object includes population carries formal “ancestral parent population” \"__pop_is_ancestor\" instead just \"ancestor\". Note internal implementation detail something particularly involve user. Still, somehow using slendr’s internal data structures, keep mind. (#f8a39a2)","code":"> ts_f3(ts, A = c(\"p1_1\", \"p1_2\", \"p1_3\", \"p1_4\", \"p1_5\"),             B = c(\"p2_1\", \"p2_2\", \"p2_3\"),             C = c(\"p3_1\", \"p3_2\", \"p3_3\", \"p3_4\"))  # A tibble: 1 × 4   A                        B              C                         f3   <chr>                    <chr>          <chr>                  <dbl> 1 p1_1+p1_2+p1_3+p1_4+p1_5 p2_1+p2_2+p2_3 p3_1+p3_2+p3_3+p3_4 0.000130 > ts_f3(ts, A = list(group_one = c(\"p1_1\", \"p1_2\", \"p1_3\", \"p1_4\", \"p1_5\")),             B = list(group_two = c(\"p2_1\", \"p2_2\", \"p2_3\")),             C = list(group_three = c(\"p3_1\", \"p3_2\", \"p3_3\", \"p3_4\"))) # A tibble: 1 × 4   A         B         C                 f3   <chr>     <chr>     <chr>          <dbl> 1 group_one group_two group_three 0.000130"},{"path":"https://bodkan.net/slendr/news/index.html","id":"slendr-040","dir":"Changelog","previous_headings":"","what":"slendr 0.4.0","title":"slendr 0.4.0","text":"CRAN release: 2022-09-30 msprime() function now makes sure given slendr model can fully coalesce single common ancestor population. Previously, multiple ancestral populations created parent = \"ancestor\" cause infinite simulation plugged msprime() backend. (#095b124) initial size population emerges split another population now printed population history summary R console. (#6525bf3) couple fixes support loading, processing, plotting “manually” created tree sequences implemented (see ). sure practically useful, ’s important able load even “pure” tree sequences simulators SLiM msprime. set unit tests added, making sure minimalist nodes & edges table can loaded, well nodes & edges & individuals, plus tables populations sites & mutations. PRs extensive unit tests bug reports tree sequences failing load appreciated! code handling cases “manually-created” tree sequences missing individual table, missing populations table, etc. seems especially brittle moment (#79adf14). -1 value missing value indicator used tskit now replaced R-like NA various tree-sequence tables (annotated slendr original tskit ) (#79adf14). Relative paths now expanded ts_write() (#382e0b7). slendr models can now optionally compiled without serialization disk. works msprime() coalescent back end much faster cases huge number simulations needs run non-serialized models, msprime() now calls back end engine directly R-Python interface (rather command line) output tree sequences saved disk, rather passed Python-R interface directly memory (PR #112). Deprecated argument sampling = functions slim() msprime() now permanently removed favour samples = argument (#0757b6e). Avoid unnecessary array type tskit results returned via reticulate. Numeric vectors (columns data frames numerical results) obtained way simple R numeric vector (#5101b39). One-way multi-way statistics results now returned simple numerical vectors. Previously, results returned type array despite “looking” vectors (values returned R reticulate-Python layer), caused unnecessary annoyances type-conversions R side things even intended (#403df3b). Computing population genetic statistics named samples present tree sequence (likely typos) now correctly caught reported error (#da7e0bb).","code":""},{"path":"https://bodkan.net/slendr/news/index.html","id":"slendr-030","dir":"Changelog","previous_headings":"","what":"slendr 0.3.0","title":"slendr 0.3.0","text":"CRAN release: 2022-08-19 SLiM 4.0 now required running simulations slim() engine. want run slendr simulations SLiM (spatial non-spatial), need upgrade SLiM installation. SLiM 3.7.1 version longer supported upcoming new slendr spatial features depend SLiM 4.x maintaining two functionally identical yet syntactically different back ends feasible (PR #104). time SLiM 4.0 release, new versions Python modules msprime, tskit pyslim also released. fact, able work SLiM 4.0 tree sequences properly, Python modules must upgraded well. Next time load library(slendr), prompted setup new updated Python environment can easily running setup_env(). Experimental support running coalescent msprime simulations analysing tree-sequence data using tskit Windows platform now implemented (PR #102).","code":""},{"path":"https://bodkan.net/slendr/news/index.html","id":"slendr-020","dir":"Changelog","previous_headings":"","what":"slendr 0.2.0","title":"slendr 0.2.0","text":"CRAN release: 2022-08-09 slendr now CRAN! Big changes way tree-sequence outputs handled slendr default. See comment extended description examples change. (PR #100). Briefly, simulation functions slim() msprime() now return tree-sequence object default (can switched setting load = FALSE), avoiding need always run ts <- ts_read(model) previously. time, parameter output = can now used slim() msprime() specify location tree-sequence file saved (temporary file default). slendr’s tree-sequence R interface tskit Python module generalized load, process, analyze tree sequences non-slendr models!** means users can use slendr R package even analyzing tree sequences coming standard msprime SLiM scripts, including spatial capabilities available slendr tree sequences far. Please note generalization still rather experimental might corner cases tree sequence msprime SLiM script load properly leads errors. happens, please open GitHub issue script question attached. (PR #91) Removed functions function arguments originally deprecated renaming phase pre-preprint refactoring. affects compile, boundary, dispersal, expand, geneflow, plot.slendr, plot_graph, read, sampling, shrink. Similarly, deprecated dir argument compile_model now path, geneflow argument compile_model now gene_flow, _dist suffix removed competition_dist, mate_dist, dispersal_dist. get error missing function function argument code used work ancient version slendr, . (#985b451) setting isolated Python environment using setup_env(), slendr now makes decision whether install Python dependencies using pip (critical osx-arm64 conda msprime/tskit unfortunately currently broken) conda (every platform). can still influenced user using pip = <TRUE|FALSE> argument, now change default behavior ARM64 Mac. (#54a413d) name default slendr Python environment now shortened even , redundant _pandas prefix now dropped. Users notified upon calling library(slendr) new environment created. OK, ’s bug. (#54a413d) format default slendr Python environment now msprime-<version>_tskit-<version>_pyslim-<version>_pandas, dropping slendr_ prefix. paves way towards future non-slendr tskit R package, share Python environment slendr (R packages go hand hand). isn’t really user-facing change, except calling setup_env() suggests creating new Python environment library(slendr) appear slendr environment yet present. Calling setup_env() creating new Python environment scratch solve problem. (#eb05180) xrange yrange parameters world() now enforced two-dimensional numeric vectors, avoiding unnecessary issues misspecified longitude/latitude (#df95369) argument sampling = slim() msprime() now renamed samples = (#adf4e0d). automated setup_env() function creating dedicated mini Python environments slendr now installs packages using pip default. Reason: rate conda failures dependency conflicts (even trivial case installing nothing msprime + tskit + pyslim + pandas) high rely . option use conda package installations setup_env() still , users must explicitly call setup_env(pip = FALSE) get behavior. Note conda still used means install Python ! change affects way Python modules installed dedicated slendr Python environment, installation Python . (#81be1a7) name automatically created slendr-specific Python environment now composed names versions Python modules installed. makes possible naturally upgrade slendr Python dependencies case tskit / msprime / pyslim folks upgrade packages. case, slendr user upgrades slendr package (new version requires newer versions Python modules), slendr simply recommend create new Python environment without additional effort part. (#81be1a7) code setup_env() simplified bare essentials. Now serves way auto-setup dedicated, isolated Python installation slendr environment. interface install Python modules custom-defined Python environment created outside R removed functionality necessary – custom environments can easily activated calling reticulate::use_virtualenv reticulate::use_condaenv. (#30f24b9) Python users want use custom Python environments msprime, tskit, pyslim, can silence suggestion use setup_env() printed library(slendr) call setting options(slendr.custom_env = TRUE). (#30f24b9) argument sim_length = now renamed simulation_length =. accepted moment using old name simply inform user future deprecation. (#56491fb) Extensive set runnable examples including figures built-pre-compiled example model added documentation. (#395df62c)","code":""},{"path":"https://bodkan.net/slendr/news/index.html","id":"slendr-010","dir":"Changelog","previous_headings":"","what":"slendr 0.1.0","title":"slendr 0.1.0","text":"First numbered version slendr celebrate bioRxiv preprint! 🥳 🎉","code":""}]
