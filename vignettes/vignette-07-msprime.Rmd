---
title: "Simulating slendr models with msprime"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Spatially annotated tree sequences}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#>",
  fig.width = 6,
  fig.height = 4,
  dpi = 80,
  eval = TRUE
)

# for some reason knitr/reticulate sets this to default, sabotaging
# our efforts to make reticulate use our custom environment -- this
# appears to solve the problem
Sys.unsetenv("RETICULATE_PYTHON")

devtools::load_all(".")

RANDOM_SEED <- 314159L
set.seed(RANDOM_SEED)
```

The main purpose of the *slendr* R package is to allow programming of complex spatial population models using the SLiM forward population genetic simulator as a backend engine. However, sometimes we might want to evaluate the same model in a non-spatial setting, perhaps to see the effect that various spatial parameters might have on some statistics of interest compared to a standard model of random mating. This is why *slendr* supports even non-spatial SLiM models, which can be executed by *slendr* simply by excluding the map component from a SLiM simulation (briefly discussed in [this vignette]()).

In some cases, the forward nature of a SLiM simulation and the fact that many individuals need to be tracked in each generation could make some simulations a little slower than might be desirable. For instance, running an Approximate Bayesian Computation (ABC) analysis often requires running tens, hundreds, or sometimes even millions of simulations.

For these cases, the *slendr* package also provides an alternative backend for simulating non-spatial population models using the Python simulation framework [*msprime*](https://tskit.dev/msprime/docs/stable/intro.html). Unlike forward time simulators, coalescent simulations such as *msprime* only reconstruct the genealogical history of a sample of individuals of interest backwards in time, which makes it much more computational efficient (at the expense of lower flexibility).

The goal of this vignette is to demonstrate that a single *slendr* model configuration can be run using the built-in SLiM and msprime backend engines _without any change_!

Let's load the *slendr* package and instruct *reticulate* where to look for a Python environment with the tskit/pyslim/msprime and numpy modules that we are going to need for the analysis below:

```{r}
library(slendr)
library(dplyr)
library(ggplot2)

reticulate::use_virtualenv("~/.venvs/retipy", required = TRUE)
```

## Defining a model

First, let's set up a simple *non-spatial* model of Neanderthal introgression using *slendr.* This is essentially the same procedure which we have shown in another vignette introducing [non-spatial *slendr* models](vignette-04-nonspatial-models.html). Again, note that this is no different from how we would normally specify a spatial model, except that we left out the `map` argument in calling `population()`.

```{r}
# create the ancestor of everyone and a chimpanzee outgroup
# (we set both N = 1 to reduce the computational time for this model)
outgroup <- population("OUT", time = 6.5e6, N = 1)

# two populations of anatomically modern humans: Africans and Europeans
afr <- population("AFR", parent = outgroup, time = 6e6, N = 10000)
eur <- population("EUR", parent = afr, time = 70e3, N = 10000)
asn <- population("ASN", parent = eur, time = 45e3, N = 10000)

# Neanderthal population splitting at 600 ky ago from modern humans
# (becomes extinct by 40 ky ago)
nea <- population("NEA", parent = afr, time = 600e3, N = 1000, remove = 35e3)

# 3% Neanderthal introgression into Europeans between 55-50 ky ago
gf <- list(
  geneflow(from = nea, to = eur, rate = 0.3, start = 55000, end = 50000),
  geneflow(from = nea, to = asn, rate = 0.02, start = 41000, end = 40000)
)

model <- compile(
  populations = list(outgroup, nea, afr, eur, asn), geneflow = gf,
  generation_time = 30,
  dir = "~/Desktop/test", overwrite = TRUE
)
```

```{r}
nea_samples <- sampling(model, times = c(70000, 40000), list(nea, 1))

present_samples <- sampling(model, times = 0, list(outgroup, 1), list(afr, 1),
                                              list(eur, 20), list(asn, 20))

samples <- rbind(nea_samples, present_samples)
```

Let's execute the model with the SLiM backend:

```{r}
slim(
  model, sequence_length = 1e6, recombination_rate = 1e-8,
  sampling = samples, method = "batch", verbose = TRUE, seed = RANDOM_SEED
)
```

And then with the msprime backend:

```{r}
msprime(
  model, sequence_length = 50e6, recombination_rate = 1e-8,
  sampling = samples, verbose = TRUE, seed = RANDOM_SEED, debug=T
)

reticulate::repl_python()
```

```{python}
import os

import msprime
import tskit
import pyslim
import numpy

ts_msp = tskit.load(os.path.expanduser(r.model["path"] + "/output_msprime.trees"))
ts_msp = msprime.sim_mutations(ts_msp, rate=1e-8, keep=True, random_seed=r.RANDOM_SEED)

pop_lookup = { pop.metadata["name"] : pop.id for pop in ts_msp.populations() }

def pair_nodes(lst):
  return [(lst[i], lst[i + 1]) for i in range(int(len(lst) / 2))]

chimp_nodes = pair_nodes(ts_msp.samples(population=pop_lookup["CH"]))
nea_nodes = pair_nodes(ts_msp.samples(population=pop_lookup["NEA"]))
afr_nodes = pair_nodes(ts_msp.samples(population=pop_lookup["AFR"]))
eur_nodes = pair_nodes(ts_msp.samples(population=pop_lookup["EUR"]))
asn_nodes = pair_nodes(ts_msp.samples(population=pop_lookup["ASN"]))

# numerators of the f4-ratio
eur_msp_f4_num = numpy.array([
  float(ts_msp.f4([nea_nodes[0], chimp_nodes[0], x, afr_nodes[0]]))
  for x in eur_nodes
])
asn_msp_f4_num = numpy.array([
  float(ts_msp.f4([nea_nodes[0], chimp_nodes[0], x, afr_nodes[0]]))
  for x in asn_nodes
])
# denominator of the f4-ratio
msp_f4_den = ts_msp.f4([nea_nodes[0], chimp_nodes[0], nea_nodes[1], afr_nodes[0]])

(1 - eur_msp_f4_num / msp_f4_den).mean(), (1 - asn_msp_f4_num / msp_f4_den).mean()
```
(Not that we are using exactly the same model configuration object in both simulation runs! In fact, even the function interface looks nearly exactly the same.)

Because *slendr* saves all output files directly to the model directory by default, we can detect two distinct tree sequence output files, one generated by *slendr*'s SLiM backend, another by its msprime backend:

```{r}
system(paste("cd", model$path, "; ls -l *.trees"))
```

However, note that the files have very different sizes. In particular, the `output_msprime.ts` file which is saved by msprime is much, much smaller. This is because being a coalescent simulator, msprime only saves information about nodes which are coalescent nodes somewhere (and some time) in the tree sequence.

## Comparing the outputs of msprime and SLiM runs of a *slendr* model

Having run our simple Neanderthal introgression model with the two simulation backend, let's load both tree sequence outputs and check their contents.

First, we will load the tree sequences generated by msprime and *slendr*/SLiM into Python. We can load the SLiM tree sequence output using [dedicated tskit functionality]() in R (and we do so below) but we thought it might be instructive to show how to analyse these outputs using Python only. Moreover, *slendr* cannot yet load msprime tree sequence data (although it will soon), so we need to do some Python programming in order to compare the *slendr* simulation results produced by its SLiM and msprime backends.

```{r, echo = FALSE, eval = FALSE}
RANDOM_SEED <- 314159L
devtools::load_all()
model <- read("~/Desktop/test")
reticulate::use_virtualenv("~/.venvs/retipy", required = TRUE)
```

```{r, eval = FALSE}
# open a Python repl in our R session, for convenience
reticulate::repl_python()
```

Below, we can access R objects in the Python session using the prefix `r.`:

```{python}
import os

import msprime
import tskit
import pyslim
import numpy

ts_msp = tskit.load(os.path.expanduser(r.model["path"] + "/output_msprime.trees"))
ts_slim = pyslim.load(os.path.expanduser(r.model["path"] + "/output_ts.trees"))
```

Because the loaded SLiM tree sequence contains much more data than we want, let's simplify it only to the individuals/nodes that we explicitly scheduled for remembering:

```{python}
# get indices of individuals which have been remembered
ind_indices = ts_slim.tables.individuals.flags & pyslim.INDIVIDUAL_REMEMBERED
remembered_inds = numpy.where(ind_indices != 0)[0]

# collect nodes of remembered individuals
remembered_nodes = []
for i in remembered_inds:
    remembered_nodes.extend(ts_slim.individual(i).nodes)

# recapitate the tree sequence, and simplify it only to remembered individuals
ts_slim = ts_slim \
  .recapitate(recombination_rate=1e-8, Ne=10000, random_seed=r.RANDOM_SEED) \
  .simplify(sorted(remembered_nodes))
```

We also want to add mutations to the tree sequence genealogies in order to calculate a couple of population genetic statistics:

```{python}
ts_slim = msprime.sim_mutations(ts_slim, rate=1e-8, keep=True, random_seed=r.RANDOM_SEED)
ts_msp = msprime.sim_mutations(ts_msp, rate=1e-8, keep=True, random_seed=r.RANDOM_SEED)
```

Now that the processing of the tree sequence data is finished, we can see that both tree sequence objects contain the same number of sample nodes:

```{python}
print(ts_slim)
print(ts_msp)
```

Now let's also load and process the SLiM tree sequence with *slendr*'s' own R interface:

```{r}
ts <- ts_load(
  model, recapitate = TRUE, simplify = TRUE,
  Ne = 10000, recombination_rate = 1e-8, mutation_rate = 1e-8,
  random_seed = RANDOM_SEED
)

ts
```

As we can see, *slendr*'s `ts_load()` function gives exactly the same result as what we did manually in Python above. This is not surprising at all, given that `ts_load()` (and many other `ts_*()` functions in *slendr*) are actually implemented using tskit/pyslim functions, but still a comforting sanity check.

## Comparing results of population genetics statistics

Having loaded both msprime and SLiM tree sequences generated by the same model, let's see if we can get comparable results when we calculate some statistics of interest.

We begin by extracting the table of remembered individuals and their nodes. The tskit Python interface works with numeric node IDs which can be a little challenging to work with when we want to calculate popgen statistics between individuals or populations. Having a table of nodes annotated with individual names and populations will make data exploration a bit easier:

```{r}
samples <- ts_data(ts, remembered = TRUE) %>%
  select(name, pop, node_id, time, pedigree_id) %>%
  as.data.frame() # lets strip away some slendr-specific information

head(samples)
```

```{r}
# first get a table of simulated African and European individuals in the tree-sequence
inds <- ts_samples(ts) %>% filter(pop %in% c("EUR", "ASN"))

# estimate the amounts of Neanderthal ancestry in these individuals and add
# these values to the table
inds$ancestry <- ts_f4ratio(ts, X = inds$name, "NEA_1", "NEA_2", "AFR_1", "CH_1")$alpha
```

```{r}
ggplot(inds, aes(pop, ancestry)) +
  geom_boxplot(aes(fill = pop)) +
  geom_jitter()
```

Now let's switch to Python REPL and repeat the same analysis on an msprime tree sequence from Python:

```{r}
reticulate::repl_python()
```

We can leverage the data frame with node IDs and other annotation data that we created above in R to collect the node IDs of individuals needed for calculating the statistic:

```{python}
# generate mapping between original individual/node IDs before/after
# simplification using pedigree_id as a "primary key" (we have to do this
# because pyslim simplification "reshuffles" individual/node IDs during, but we
# need to retain identity and times of remembered individuals -- slendr does
# this automatically, tskit/pyslim doesn't)
id_mapping = {}
for ind in ts_slim.individuals():
  if ind.flags & pyslim.INDIVIDUAL_REMEMBERED:
    id = ind.metadata["pedigree_id"]
    id_mapping[id] = list(ind.nodes)

# for id in r.samples.pedigree_id.unique():
#   print(id, list(r.samples.query(f"pedigree_id == {id}").node_id),
#         id_mapping[id])

def get_node_ids_slim(name):
  # get the pedigree_id of the individual
  pedigree_id = r.samples.query(f"name == '{name}'").pedigree_id.unique()[0]
  # return the node IDs of the individual after simplification
  return id_mapping[pedigree_id]

chimp_nodes = get_node_ids_slim("CH_1")
afr1_nodes = get_node_ids_slim("AFR_1")
nea1_nodes = get_node_ids_slim("NEA_1")
nea2_nodes = get_node_ids_slim("NEA_2")

# nodes of individuals for which we want to estimate Neanderthal ancestry
eur_nodes = [get_node_ids_slim(i) for i in r.inds.name]
```

Now let's calculate the $f_4-ratio$ statistic on the SLiM tree sequence in Python:

```{python}
slim_f4_num = numpy.array([
  float(ts_slim.f4([nea1_nodes, chimp_nodes, x, afr1_nodes]))
  for x in eur_nodes
])
slim_f4_den = ts_slim.f4([nea1_nodes, chimp_nodes, nea2_nodes, afr1_nodes])

r.inds = r.inds.assign(ancestry_tskit_slim = slim_f4_num / slim_f4_den)
```

And the same statistic on the msprime tree sequence:

```{python}
pop_lookup = { pop.metadata["name"] : pop.id for pop in ts_msp.populations() }

def pair_nodes(lst):
  return [(lst[i], lst[i + 1]) for i in range(int(len(lst) / 2))]

chimp_nodes = pair_nodes(ts_msp.samples(population=pop_lookup["CH"]))
nea_nodes = pair_nodes(ts_msp.samples(population=pop_lookup["NEA"]))
afr_nodes = pair_nodes(ts_msp.samples(population=pop_lookup["AFR"]))
eur_nodes = pair_nodes(ts_msp.samples(population=pop_lookup["EUR"]))
asn_nodes = pair_nodes(ts_msp.samples(population=pop_lookup["ASN"]))

numpy.array([ts_msp.f4([afr_nodes[0], eur_nodes[i], nea_nodes[0], chimp_nodes[0]]) for i in range(len(eur_nodes))]).mean()

numpy.array([ts_msp.f4([afr_nodes[0], asn_nodes[i], nea_nodes[0], chimp_nodes[0]]) for i in range(len(eur_nodes))]).mean()

numpy.array([ts_msp.f4([eur_nodes[i], asn_nodes[i], nea_nodes[0], chimp_nodes[0]]) for i in range(len(eur_nodes))]).mean()

# numerators of the f4-ratio
eur_msp_f4_num = numpy.array([
  float(ts_msp.f4([nea_nodes[0], chimp_nodes[0], x, afr_nodes[0]]))
  for x in eur_nodes
])
asn_msp_f4_num = numpy.array([
  float(ts_msp.f4([nea_nodes[0], chimp_nodes[0], x, afr_nodes[0]]))
  for x in asn_nodes
])
# denominator of the f4-ratio
msp_f4_den = ts_msp.f4([nea_nodes[0], chimp_nodes[0], nea_nodes[1], afr_nodes[0]])

(1 - eur_msp_f4_num / msp_f4_den).mean(), (1 - asn_msp_f4_num / msp_f4_den).mean()

#r.inds = r.inds.assign(ancestry_tskit_msprime = 1 - eur_msp_f4_num / msp_f4_den)
```

```{r}
ggplot(inds, aes(ancestry, ancestry_tskit_slim)) +
  geom_point() +
  geom_abline(slope = 1, linetype = 2, alpha = 0.5) +
  coord_cartesian(xlim = c(0, 0.1), ylim = c(0, 0.1))
```

```{r}
ggplot(inds, aes(ancestry_tskit_msprime, ancestry_tskit_slim)) +
  geom_point() +
  geom_abline(slope = 1, linetype = 2, alpha = 0.5) +
  coord_cartesian(xlim = c(0, 0.1), ylim = c(0, 0.1))
```


## FAQ: Can I load tree sequences generated by msprime backend with *slendr*?

The `ts_load()` and other *slendr* functions for working with tree sequences currently assume that the data was generated by SLiM. As such, loading and handling msprime tree sequences is not supported (yet -- it will be soon).
