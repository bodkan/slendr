---
title: "Non-neutral simulations"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Non-neutral simulations}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#>",
  fig.width = 6,
  fig.height = 4,
  dpi = 60,
  eval = slendr::check_dependencies(python = TRUE, slim = TRUE, quit = FALSE) 
)
```

## Introduction

_slendr_ has been designed specifically for the purpose of making it as easy as possible to program population genetic simulations of spatio-temporal demographic histories using SLiM. Our primary goal was to have the means to simulate arbitrarily complex spatial scenarios and simulate data which could be used for development of new spatial inference population genetic methods (and benchmarking of current methods). This functionality is briefly described in [vignette #1]() and in more detail in [vignette #6]().

After the spatial simulation features have been implemented, it turned out to be trivial to support also "traditional", non-spatial demographic models, such as those described in [vignette #4]() and [vignette #5]() -- tree-like models with population divergences, gene-flow events, and popularion resize events, like you can see in any evolutionary biology textbook. Because non-spatial models can be often implemented (and executed) more efficient in a coalescent setting, we added the possibility to run any compiled _slendr_ model not through SLiM but through a back-end script implemented in _msprime_, hidden behind the _slendr_ function `msprime()`.

Throughout all this time, _slendr_ models were purely neutral, without much planning to extend simulations toward non-neutral scenarios. However, **with the easy specification of non-spatial demographic models and their simulation with the _slendr_/SLiM engine, many users have been asking about the possibility to simulate non-neutral scenarios or, more generally, customization of the simplified genome architecture assumed by _slendr_ by default (a single chromosome with uniform recombination and purely neutral mutations).** 

This vignette describes how this can be done with _slendr_.

**Why even do this if SLiM can do these things on its own? Fair question!** After all, SLiM can obviously simulate nearly any kind of conceivable evolutionary model.

One motivation for supporting non-neutral customized genomic architecture and mutation models in _slendr_ is from users who find it easier to program complex "base" demographic models in R (such as models with complex history of population divergences, gene-flow events, resizes), let _slendr_ take care of demographic history . You only have to provide custom SLiM code for non-neutral evolution.**

## Disclaimers and caveats

If you want to use the _slendr_/SLiM extension functionality described in this vignette, you should be aware of the following:

- The [built-in SLiM engine of _slendr_](https://github.com/bodkan/slendr/blob/main/inst/scripts/script.slim) stays unmodified. Any extension _SLiM_ code customization snippets will be added on top of it. In particular, this includes customizing mutation types, genomic element types, recombination maps, etc. Functionality involving demographic events (splits, gene-flow, etc.) will stay in place as it is, unchanged and will be handled by _slendr_ itself.

- Related to the above point -- _slendr_ models assume (and will always assume) Wright-Fisher (WF) dynamics. Although perhaps not necessarily a problem for simulating non-spatial selection models (i.e. _slendr_ models which don't include a map), adding selection to spatial models in SLiM WF setting is unlikely to lead to very meaningful results. 

- The built-in SLiM engine of _slendr_ provides several utility Eidos functions which make it easy to extend the engine with custom callbacks. See the list in the section below.

## _slendr_ / SLiM "API"

Let's first load all required R libraries:

```{r, collapse = TRUE, message = FALSE}
library(slendr)
init_env()

library(dplyr)
library(ggplot2)


seed <- 42
set.seed(seed)
```

### Referring to populations: `population()` Eidos function

As a recap, when we program a _slendr_ model, we can refer to populations using symbolic names such as "AFR", "EUR", etc. in our R scripts in the following way:

```{r, eval=FALSE}
afr <- population("AFR", time = 100000, N = 20000)
eur <- population("EUR", time = 60000, N = 2000, parent = afr)

# <... compile model and simulate a tree sequence `ts` ...>
```

When we then want to analyze the tree-sequence output of _slendr_ models, we can refer to populations (or individuals sampled from those populations) using the same symbolic names like this (not with integer node IDs internally used by _tskit_):

```{r, eval=FALSE}
# compute heterozygosity in the individual "EUR"
ts_diversity(ts, "EUR_1")

# compute genetic divergence between selected Africans and Europeans
afr_samples <- c("AFR_1", "AFR_2", "AFR_3")
eur_samples <- c("EUR_1", "EUR_2", "EUR_3")
ts_divergence(ts, list(afr = afr_samples, eur = eur_samples))
```

Along the same lines, when you're customizing a _slendr_/SLiM simulation, you can get a `Subpopulation` SLiM object corresponding to a symbolic name of a _slendr_ population (as used by the R side of things) using the Eidos function `population()`. For instance, let's assume we compiled a toy model of human demography from the [vignette #4]() and ran it in the SLiMgui using `slim(..., method = "gui"). We can then open an Eidos console in the GUI and type the following:

```
> // get a SLiM object corresponding to the "AFR" population
> population("AFR")
Subpopulation<p0>
> 
> // get the number of genomes in the population
> length(population("AFR").genomes)
6000
> 
> // get both "AFR" and "OOA" subpopulation objects
> population(c("AFR", "OOA"))
Subpopulation<p0> Subpopulation<p1>
```

The `population()` Eidos function servers as a convenience shortcut for poking into _slendr_ internals from SLiM (internally it uses the standard vectorized filtering of the `sim.subpopulations` list), as it provides some helpful error checking. For instance, if we try to get a SLiM `Subpopulation` object corresponding to a _slendr_ population which will exist at some point but doesn't yet exist in a running SLiM simulation at a particular time, we will get an informative error:

```
> population("YAM")
The following populations not present in tick 81 (slendr model time 97600): YAM
```

If we make a typo and try to access a population which doesn't exist in a _slendr_ model at all, we get another informative error message:

```
> population("asdf")
Not all provided population identifiers are present in the model.
Check your code to make sure that all of these are defined: asdf
```

**Why is this function useful?** Because the purpose of this vignette is to show how to extend _slendr_ to non-neutral scenarios, we could for instance select a random chromosome from a given population using the `population()` function like this (maybe to add a beneficial mutation):

```
target_genome = sample(population("AFR").genomes, 1);

target_genome.addNewMutation(m0, selectionCoeff = 0.05, position = 1000000);
```


### Referring to times: `tick()` Eidos function

Another useful feature of _slendr_ is its ability to use arbitrary time units in model definition. For instance, when creating a "EUR" population in the snippet above, we wrote this:

```{r, eval=FALSE}
afr <- population("AFR", time = 100000, N = 20000)
eur <- population("EUR", time = 60000, N = 2000, parent = afr)
```

The numbers 100000 and 60000 in the split time are not meaningful by themselves, but if we compile the _slendr_ model like this:

```{r, eval=FALSE}
model <- compile_model(populations = list(afr, eur), generation_time = 30, ...)
```

We can then interpret 100000 and 60000 as "years before present", which can be quite convenient when we're building models using radiocarbon-dated or fossil-dated ages, rather than using traditional units of generations (forward in time as in SLiM, backwards in time as in _msprime). Any time we later refer to a particular time, either in a model visualization or during tree-sequence, we can use these "natural units" without having to convert years before present into generations forward in time.

Similarly to referring to _slendr_ population symbolic names in a consistent way between R and SLiM itself, we can also refer to times of events using _slendr_-specific time units using the function `tick()`. This function takes in a time in _slendr_ time units -- years before present, generations backwards in time, whatever you used in your _slendr_ R script, and translates those to SLiM's "ticks". For instance, in our example model of modern human history, we could get the tick number corresponding to the time of 40 thousand years ago by calling:

```
> tick(40000)
401
```

Similarly to the consistency check performed by the `population()` Eidos function, `tick()` also makes sure that the time given lies within the time window expected for the running simulation. For instance, our example model only starts at 100 thousand years ago, so if we try to get the tick number corresponding to a million years ago, we get this:

```
> tick(1e6)
Some of the times fall outside of the range of the slendr model:
  - oldest possible event: 100000
  - youngest possible event: 0

The offending times were: 1000000
```

Indeed, the tick-based time boundaries of the model are:

```
> // the very first time point of the simulation
> tick(90e3)
1
> // the very last time point of the simulation
> tick(0)
3001
```

As with `population()`, we can also perform the _slendr_-time-to-tick conversion in a vectorized manner:

```
> tick(c(90000, 0))
1 3001
```

Naturally, if our model does not use any special time units (for instance, if all times are encoded in generations, even forward in time), the `tick()` function becomes an identity function:

```{r, eval=FALSE}
pop <- population("pop", time = 1, N = 1000)
model <- compile_model(pop, generation_time = 1, simulation_length = 1000)

slim(model, sequence_length = 1e6, recombination_rate = 1e-8, method = "gui")
```

Indeed, if we pop up the Eidos console in SLiMgui for this model, we can verify this:

```
> // no conversion needed for models using times of generations
> tick(c(1, 1001))
1 1001
```

Still, the `tick()` function can be useful even for _slendr_ models which use the same time units as SLiM itself (generations forward in time) because it provides useful boundary checking. For instance, this is what happens if we try to get the tick number in a model above (which only runs from generation 1 to generation 1 + 1000):

```
> tick(c(0, 1e6))
Some of the times fall outside of the range of the slendr model:
  - oldest possible event: 1
  - youngest possible event: 1001

The offending times were: 0, 1000000
```

Additionally, **the `tick()` function automatically takes care of offsetting the tick count when a burn-in period was specified for the simulation.**

Below we'll see that thanks to the possibility of using arbitrary integer expressions in SLiM 4.2, we can use the `tick()` Eidos function for easy and straightforward scheduling of custom callbacks.

### Referring to model times: `model_time()` Eidos function

This function is an inverse to the `tick()` function. For instance, if we want to write out an output with a time stamp using times of the _slendr_ model (like years before present) and not tick numbers.

As an example, this gives us the model time (in years ago) corresponding to the first tick:

```
> model_time(1)
90000
```

This gives us model time corresponding to the very last tick of the simulation (i.e. the present-day at "0 years before present"):

```
> model_time(3001)
0
```

### Logging: `log_output()` Eidos function

`log_output()` is a tiny helper function provided by _slendr_'s SLiM back-end script which serves to print out a given string to the SLiM log output together with the appropriate tick number at that time. This produces output of the following kind:

```
> log_output("hello from the current event")
tick 696: hello from the current event
```

### Saving and re-starting simulation state: `save_state()` and `reset_state()`

Whenever we're dealing with the simulation of, say, beneficial allele frequency trajectories, we usually have to take care of situations in which the allele of interest gets lost before the simulation finishes running. In this case, we often want to reset the simulation to a state just before the mutation was added and try again. Section 9.2 of the venerable SLiM manual ("Making sweeps conditional on fixation") is a great example on how to solve this with base SLiM.

Although it would be quite easy to use the same approach in the _slendr_/SLiM extension snippets described here, there's one issue with this approach: `sim.outputFull()` and `sim.readFromPopulationFile()` do not preserve some important _slendr_ tags which are assigned using `<Subpopulation>.{set,get}Value()` methods. Doing so would require poking into _slendr_'s SLiM codebase, which would be confusing for any user.

To circumvent the problem, _slendr_'s SLiM back-end script provides these two functions:

- `save_state()`: saves the full state of the SLiM simulation (just as `sim.outputFull()` does), while also saving those few _slendr_-specific values;
- `reset_state()`: restores the full SLiM simulation state (including _slendr_ specific tags and values), and **chooses a new random seed**. The latter is performed because restarting a simulation using the `save_state()` - `reset_state()` tandem is practically always done in order to change the outcome of a simulation.


As an example, let's say that we want to add a beneficial mutation to the "EUR" population at time 15 ky ago. We could utilize the few bits of Eidos code introduced so far, to define the following _slendr_ extension snippet:

```
function (void) add_mutation(s pop_name) {
  // sample one target carrier of the new mutation...
  target = sample(population(pop_name).genomes, 1);
  // ... and add the mutation to it
  target.addNewDrawnMutation(m0, position = asInteger(SEQUENCE_LENGTH / 2));
  
  log_output("added beneficial mutation at 15 kya");
}

tick(15000) late() { /* Add a beneficial mutation at 15 thousand years ago*/
    // save simulation state in case we need to restart if the mutation is lost
  save_state();
  
  add_mutation("EUR");
}

tick(15000):SIMULATION_END late() {
  segregating = sim.countOfMutationsOfType(m0) > 0;
  fixed = sum(sim.substitutions.mutationType == m0) == 1;
  
  // the mutation is not segregating and is not fixed either -- we must restart
  if (!segregating & !fixed) {
    log_output("mutation lost -- restarting");
    
    reset_state();
    
    add_mutation("EUR");
  }
}
```

**Note that we're using an advanced new feature of SLiM 4.2 for direct specification of callback timing described in the third item of the [SLiM changelog](https://github.com/MesserLab/SLiM/releases/tag/v4.2). This features makes customization of _slendr_ / SLiM simulations inifinitely easier, so make sure you read about it in the SLiM manual!**

### Global constants

By inspecting the built-in SLiM simulation script of _slendr_, you will find that it contains a number of global constants. Most of them should be considered internal and users shouldn't rely on them in their code. However, one useful contant which you can see being used in the snippet above is `SEQUENCE_LENGTH` -- this is the total amount of sequence simulated (i.e., the number passed as `slim(<model>, sequence_length = <SEQUENCE_LENGTH>, ...)` in your R code).


## Putting it all together: running a customized _slendr_ simulation 

The above examples show how you can refer to a _slendr_ population with its symbolic name on the SLiM side using the `population()` Eidos function provided by the _slendr_ built-in SLiM script, and how you can convert _slendr_-specific time units into SLiM's internal ticks using the `tick()` function. You've also learned how to save and reset SLiM state using provided functions `save_state()` and `reset_state()` and how to log outputs using the function `log_output()`. We demonstrated all this by defining a customized snippet of SLiM code which we now want to use in a full _slendr_ simulation run. Of course, the example we've chosen is extremely trivial -- you could, in principle, use any feature available for SLiM (as long as it's compatible with Wright-Fisher models, which _slendr_ currently assumes as a basis for its models).

How do we use this customization in practice? One way to do this would be to edit the built-in _slendr_ SLiM script and manually add your own SLiM code, but that would be brittle and not very reproducible. There's a much better way to do this that's directly supported by _slendr_'s R interface.

Let's say that we defined the following model of modern human demographic history in slendr. This is exactly the same example as the one we show in [vignette #4]():

```{r, model_plot}
devtools::load_all()
library(slendr)

init_env()

# African ancestral population
afr <- population("AFR", time = 90000, N = 3000)

# first migrants out of Africa
ooa <- population("OOA", parent = afr, time = 60000, N = 500, remove = 23000) %>%
  resize(N = 2000, time = 40000, how = "step")

# Eastern hunter-gatherers
ehg <- population("EHG", parent = ooa, time = 28000, N = 1000, remove = 6000)

# European population
eur <- population("EUR", parent = ehg, time = 25000, N = 5000)

# Anatolian farmers
ana <- population("ANA", time = 28000, N = 3000, parent = ooa, remove = 4000)

# Yamnaya steppe population
yam <- population("YAM", time = 8000, N = 500, parent = ehg, remove = 2500)

# define gene-flow events
gf <- list(
  gene_flow(from = ana, to = yam, rate = 0.4, start = 7900, end = 7800),
  gene_flow(from = ana, to = eur, rate = 0.5, start = 6000, end = 5000),
  gene_flow(from = yam, to = eur, rate = 0.65, start = 4000, end = 3500)
)
```

```{r model_for_plot, echo=FALSE}
model_for_plot <- compile_model(
  populations = list(afr, ooa, ehg, eur, ana, yam),
  gene_flow = gf, generation_time = 30
)

plot_model(model_for_plot, order = c("EUR", "EHG", "YAM", "ANA", "OOA", "AFR"), proportions = TRUE)
```

So far so good. Let's also assume we have the following "SLiM snippet file":

```{r}
extension_path <- system.file("extdata", "extension1.txt", package = "slendr")
```

```{r, echo=FALSE}
Sys.setenv(EXTENSION1 = extension_path)
```

```{bash, echo = FALSE, comment = ""}
less ${EXTENSION1}
```

We can include the extension snippet into the standard _slendr_ engine SLiM script by providing a path to it in `compile_model()`:

```{r}
model <- compile_model(
  populations = list(afr, ooa, ehg, eur, ana, yam),
  gene_flow = gf, generation_time = 30,
  slim_extension = extension_path  # <--- include the SLiM extension snippet
)
```

You can check that the extension snippet was really appended to the built-in SLiM engine script by running `slim()` function and setting `method = "gui"` (look towards the end of the script!):

```{r, eval=FALSE}
slim(model, sequence_length = 1e6, recombination_rate = 0, method = "gui")
```

```{r}
extension_path <- system.file("extdata", "extension2.txt", package = "slendr")

model <- compile_model(
  populations = list(afr, ooa, ehg, eur, ana, yam),
  gene_flow = gf, generation_time = 30,
  slim_extension = extension_path  # <--- include the SLiM extension snippet
)
```

```{r}
arguments <- list(
  output_file = "~/Desktop/output.tsv",
  target_pop = "AFR",
  onset_time = 90000,
  s = 0.15
)

slim(model, sequence_length = 1e6, recombination_rate = 0, arguments = arguments, verbose = TRUE, random_seed = 42)
```

```{r}
x = read.table("~/Desktop/output.tsv", header = TRUE)
ggplot(x) + geom_line(aes(time, frequency))
```


```{r}
library(ggplot2)

trajectory <- read.table("~/Desktop/output.tsv", header = TRUE)

ggplot(trajectory) + geom_line(aes(generation, frequency))
```


```{r}
arguments <- list(
  output_file = "~/Desktop/output.tsv",
  target_pop = "EUR",
  onset_time = 15000,
  s = 0.1
)

slim(model, sequence_length = 1e6, recombination_rate = 0, arguments = arguments)
```

```{r}
library(ggplot2)

trajectory <- read.table("~/Desktop/output.tsv", header = TRUE)

ggplot(trajectory) + geom_line(aes(generation, frequency))
```









```{r, eval=FALSE}
devtools::load_all()
init_env(quiet = TRUE)

pop <- population("pop", time = 1, N = 1000)

extension_path <- system.file("extdata", "extension3.txt", package = "slendr")

extension <- substitute(
  extension_path,
  s = 0.1, onset_time = 250, target_pop = "pop",
  output_dir = "~/Desktop/"
)

model <- compile_model(pop, generation_time = 1, simulation_length = 1000, extension = extension)

slim(model, output = FALSE, method = "gui")

trajectory <- read.table("~/Desktop/traj_pop.tsv", header = TRUE)

head(trajectory)
tail(trajectory)

plot(trajectory$time, trajectory$frequency, type = "l")
```












```{r, eval=FALSE}
extension_path <- system.file("extdata", "extension3.txt", package = "slendr")

extension <- substitute(
  extension_path,
  s = 0.1, onset_time = 15000, target_pop = "EUR",
  output_dir = "~/Desktop/"
)

model <- compile_model(
  populations = list(afr, ooa, ehg, eur, ana, yam),
  gene_flow = gf, generation_time = 30,
  extension = extension 
)

slim(model, sequence_length = 1e6, recombination_rate = 1e-8, output = FALSE)

trajectory <- read.table("~/Desktop/traj_EUR.tsv", header = TRUE)
plot(-trajectory$time, trajectory$frequency, type = "l", xlim = c(-15e3, 0))

trajectory <- read.table("~/Desktop/traj_ANA.tsv", header = TRUE)
plot(-trajectory$time, trajectory$frequency, type = "l", xlim = c(-15e3, 0))
```






Alternatively, thanks to the multiline string support implemented in R 4.2, we can specify the SLiM extension code directly as an R string. Including the SLiM code directly in an R script in this way makes it a little easier to iterate during development by eliminating the need to edit multiple files:

```{r}
# extension "template" provided as a single string (this contains
# the same code as the script used just above, except specified directly
# in R)
extension_template <- r"(
// Because we want to simulate non-neutral evolution, we have to provide a
// custom initialization callback -- slendr will use it to replace its default
// neutral genomic architecture. Note that we can refer to slendr's constants
// SEQUENCE_LENGTH and RECOMBINATION_RATE, which will carry values passed
// through from the slim() R function.
initialize() {
    initializeMutationType("m1", 0.5, "f", 0.0);

    initializeGenomicElementType("g1", m1, 1.0);
    initializeGenomicElement(g1, 0, SEQUENCE_LENGTH - 1);

    initializeMutationRate(0);
    initializeRecombinationRate(RECOMBINATION_RATE);
}

// Define model constants (to be substituted) all in one place
// (each {{placeholder}} will be replaced by a value passed from R)
initialize() {
    defineConstant("s", {{s}});
    defineConstant("onset_time", {{onset_time}});
    defineConstant("target_pop", "{{target_pop}}");
    defineConstant("output_file", "{{output_dir}}" + "/" + "traj_" + target_pop + ".tsv");
}

function (void) add_mutation(s pop_name, f selection_coef) {
    // sample one target carrier of the new mutation...
    target = sample(population(pop_name).genomes, 1);
    // ... and add the mutation to it
    target.addNewMutation(m1, selectionCoeff = selection_coef, position = asInteger(SEQUENCE_LENGTH / 2));

    log_output("adding beneficial mutation to population " + pop_name);
}

tick(onset_time) late() {
    // save simulation state in case we need to restart if the mutation is lost
    save_state();

    add_mutation(target_pop, s);
    writeFile(output_file, "tick\ttime\tfrequency");
}

// check that the allele of interest is still segregating (and save its
// frequency to a file)
tick(onset_time):SIMULATION_END late() {
    if (!population(target_pop, check = T)) return;

    segregating = sim.countOfMutationsOfType(m1) > 0;
    fixed = sum(sim.substitutions.mutationType == m1) == 1;

    // the mutation is not segregating and is not fixed either -- we must restart
    if (!segregating & !fixed) {
        log_output("mutation lost -- restarting");

        reset_state();

        add_mutation(target_pop, s);
        writeFile(output_file, "tick\ttime\tfrequency");
    }

    if (fixed)
        frequency = 1.0;
    else
        frequency = population(target_pop).genomes.mutationFrequenciesInGenomes();
    time = model_time(community.tick);

    writeFile(output_file, community.tick + "\t" + time + "\t" + frequency, append = T);
}
)"
```

```{r}
extension <- substitute(
  extension_template,
  s = 0.1, onset_time = 15000, target_pop = "ANA",
  output_dir = "~/Desktop/"
)

model <- compile_model(
  populations = list(afr, ooa, ehg, eur, ana, yam),
  gene_flow = gf, generation_time = 30,
  extension = extension 
)

slim(model, sequence_length = 1e6, recombination_rate = 1e-8, output = FALSE)

trajectory <- read.table("~/Desktop/traj_EUR.tsv", header = TRUE)
plot(-trajectory$time, trajectory$frequency, type = "l", xlim = c(-15e3, 0))

trajectory <- read.table("~/Desktop/traj_ANA.tsv", header = TRUE)
plot(-trajectory$time, trajectory$frequency, type = "l", xlim = c(-15e3, 0))
```








### Parametrizing selective sweep simulations


```{r, eval=FALSE}
simulate_sweep <- function(s) {
  output_path <- file.path(tempdir(), paste("sweep_frequencies", s, ".tsv", sep = "_"))

  # substitute values of given parameters into the "extension template" file:
  #   - s: selection coefficient of the sweep mutation
  #   - onset_time: time at which to add the mutation
  #   - output_file: where to save frequencies of surrounding mutations
  extension <- substitute(
    template = system.file("extdata", "extension_sweep.txt", package = "slendr"),
    s = s,
    onset_time = 1,
    output_file = output_path
  )
  
  # compile a simple slendr model, including the extension SLiM script
  pop <- population("pop", time = 1, N = 10000)
  model <- compile_model(pop, generation_time = 1, simulation_length = 1000,
                         extension = extension)
  
  # run the slendr model through SLiM (but don't simulate any tree sequence!)
  slim(model, sequence_length = 10e6, recombination_rate = 1e-8,
       burnin = 1000, output = FALSE)
  
  # load the simulated frequency table (remember, no tree sequence was
  # simulated here because we set `output = FALSE` above!) and note what
  # was the selection coefficient value for downstream analysis
  results <- read.table(output_path, header = TRUE)
  results$s <- s

  results
}
```

```{r}
library(parallel)

s_grid <- c(0.001, 0.005, 0.01, 0.05, 0.1, 0.25)

results <- mclapply(s_grid, simulate_sweep, mc.cores = detectCores()) %>% do.call(rbind, .)
```

```{r}
head(results, n = 20)
```

```{r}
ggplot(results) +
  geom_vline(xintercept = 5e6, linetype = "dashed", color = "black") +
  geom_line(aes(pos, freq, color = as.factor(s))) +
  guides(color = guide_legend("s")) +
  labs(x = "position [Mb]", y = "frequency") +
  ggtitle("Frequencies of neutral mutations surrounding a sweep mutation") +
  facet_wrap(~ s) +
  scale_x_continuous(labels = scales::label_comma(scale = 1e-6))
```


