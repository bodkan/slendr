---
title: "Non-neutral simulations"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Non-neutral simulations}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#>",
  fig.width = 6,
  fig.height = 4,
  dpi = 60,
  eval = slendr::check_dependencies(python = TRUE, slim = TRUE, quit = FALSE) 
)
```

## Introduction

_slendr_ has been designed specifically for the purpose of making it as easy as possible to program population genetic simulations of spatio-temporal demographic histories using SLiM. Our primary goal was to have the means to simulate arbitrarily complex spatial scenarios and simulate data which could be used for development of new spatial inference population genetic methods (and benchmarking of current methods). This functionality is briefly described in [vignette #1]() and in more detail in [vignette #6]().

After the spatial simulation features have been largely implemented, it turned out to be relatively easy to support "traditional", non-spatial demographic models, such as those described in [vignette #4]() and [vignette #5](). Because non-spatial models can be often implemented (and executed) more efficient in a coalescent setting, we added the possibility to run any compiled _slendr_ model not through SLiM but through a back-end script implemented in _msprime_, hidden behind the _slendr_ function `msprime()`.

Throughout all this time, _slendr_ models were purely neutral, without much planning to extend simulations toward non-neutral scenarios.

## Model specification

Let's first load all required R libraries:

```{r, collapse = TRUE, message = FALSE}
library(slendr)

library(dplyr)
library(ggplot2)

init_env()

seed <- 314159
set.seed(seed)
```

## Intended use cases for non-neutral models

In order to maintain the sanity of _slendr_ users and developers, there's one hard limit we're not planning to cross: **the _slendr_ built-in SLiM script functionality is assumed to remain unmodified.**

Whatever customization of the standard _slendr_ simulations you're interested in doing, we're making the assumption that you will not be changing the internal.


## _slendr_ "API" to its SLiM-based back end

### Referring to populations: `population()` Eidos function

When you program a _slendr_ model, you can refer to populations using symbolic names such as "AFR", "EUR", etc. in the following way:

```{r, eval=FALSE}
afr <- population("AFR", time = 100000, N = 20000)
eur <- population("EUR", time = 60000, N = 2000, parent = afr)
```

When we then want to analyze the tree-sequence output of _slendr_ models, we can refer to populations (or individuals sampled from those populations) using the same symbolic names.

When you're building a customized _slendr_/SLiM simulation, you can get a `Subpopulation` SLiM object corresponding to a symbolic name of a _slendr_ population using the provided Eidos function `population()`. For instance, let's assume we compiled a toy model of human demography from the [vignette #4]() and ran it in the SLiMgui using `slim(..., method = "gui"). We can then open an Eidos console in the GUI and type the following:

```
> // get a SLiM object corresponding to the "AFR" population
> population("AFR")
Subpopulation<p0>
> 
> // get the number of genomes in the population
> length(population("AFR").genomes)
6000
> 
> // get both "AFR" and "OOA" subpopulation objects
> population(c("AFR", "OOA"))
Subpopulation<p0> Subpopulation<p1>
```

Because the purpose of this vignette is to show how to extend _slendr_ to non-neutral scenarios (within the boundaries imposed by the design of its current SLiM back-end script), we could for instance use the `population()` Eidos function to add a beneficial mutation at the 1 milion-th position of a chromosome using this bit of Eidos code:

```
population("AFR").genomes[0].addNewMutation(m0, selectionCoeff = 0.05, position = 1000000);
```

As a side note, if we try to get a SLiM `Subpopulation` object corresponding to a _slendr_ population which will exist at some point but doesn't yet exist in a running SLiM simulation at a particular time, we will get an informative error:

```
> population("EUR")
The following populations not yet present in generation 276: EUR
```

### Referring to times: `tick()` Eidos function

The section above shows how to access the SLiM `Subpopulation` object of a _slendr_ population, perhaps in order to add a beneficial mutation, by referring to symbolic name of that population used in the _slendr_ R script.

Another useful feature of _slendr_ is its ability to use arbitrary time units in model definition. For instance, when creating a "EUR" population in the snippet above, we wrote this:

```{r, eval=FALSE}
afr <- population("AFR", time = 100000, N = 20000)
eur <- population("EUR", time = 60000, N = 2000, parent = afr)
```

The numbers 100000 and 60000 in the split time are not meaningful by themselves, but if we compile the _slendr_ model like this:

```{r, eval=FALSE}
model <- compile_model(populations = list(afr, eur), generation_time = 30, ...)
```

we can then conveniently interpret 100000 and 60000 as "years before present", which is particularly convenient when we're building models using radiocarbon-dated or fossil-dated ages, rather than using traditional units of generations (or ticks, forward in time as in SLiM; backwards in time as in _msprime).

Similarly to referring to _slendr_ population symbolic names in a consistent way between R and SLiM itself, we can also refer to times of events using _slendr_-specific time units using the function `tick()`. This function takes in a time in _slendr_ time units -- years before present, generations backwards in time, whatever you used in your _slendr_ R script, and translates those to SLiM's "ticks". For instance, in our example model of modern human history, we could get the tick number corresponding to the time of 40 thousand years ago by calling:

```
> tick(40000)
401
```

Similarly to the consistency check performed by the `population()` Eidos function, `tick()` also makes sure that the time given lies within the time window expected for the running simulation. For instance, our example model only starts at 100 thousand years ago, so if we try to get the tick number corresponding to a million years ago, we get this:

```
> tick(1e6)
Some of the times fall outside of the range of the slendr model:
  - oldest possible event: 100000
  - youngest possible event: 0

The offending times were: 1000000
```

Indeed, the tick-based time boundaries of the model are:

```
> // the very first time point of the simulation
> tick(100e3)
1
> // the very last time point of the simulation
> tick(0)
3334
```

As with `population()`, we can also perform the _slendr_-time-to-tick conversion in a vectorized manner:

```
> tick(c(100000, 0))
1 3334
```

Naturally, if our model does not use any special time units (for instance, if all times are encoded in generations, even forward in time), the `tick()` function becomes an identity function:

```{r, eval=FALSE}
pop <- population("pop", time = 1, N = 1000)
model <- compile_model(pop, generation_time = 1, simulation_length = 1000)

slim(model, sequence_length = 1e6, recombination_rate = 1e-8, method = "gui")
```

Indeed, if we pop up the Eidos console in SLiMgui for this model, we can verify this:

```
> // no conversion needed for models using times of generations
> tick(c(1, 1001))
1 1001
```

Still, the `tick()` function can be useful even for _slendr_ models which use the same time units as SLiM itself (generations forward in time) because it provides useful boundary checking. For instance, this is what happens if we try to get the tick number in a model above (which only runs from generation 1 to generation 1 + 1000):

```
> tick(c(0, 1e6))
Some of the times fall outside of the range of the slendr model:
  - oldest possible event: 1
  - youngest possible event: 1001

The offending times were: 0, 1000000
```

### Logging: `log_output()` Eidos function

### Useful constants

- `SEQUENCE_LENGTH`: the total length of the simulated sequence
- `SEED`: random seed passed to SLiM from the _slendr_ R code
- `POPULATIONS`: a `DataFrame` object
- `GENE_FLOWS`
- `SAMPLING`
- `GENERATION_TIME`

These are _slendr_'s SLiM constants which are most likely to be useful for user-defined custom SLiM extension snippets. There are othe constants present in the codebase, though -- you can find them by inspecting the `initialize()` block at the beginning of the _slendr_ SLiM script -- but those should be considered to be _slendr_'s internal matter. Use them only with caution, as their use can slightly change over time.

## Adding a SLiM snippet to the _slendr_ engine

The above examples show how you can refer to a _slendr_ population with its symbolic name on the SLiM side using the `population()` Eidos function provided by the _slendr_ built-in SLiM script, and how you can convert _slendr_-specific time units into SLiM's internal ticks using the `tick()` function.

And it turns out that as long as you're OK with keeping _slendr_'s built-in SLiM script intact (which, as we point out above, is a hard requirement we make in this vignette) you can use whatever SLiM features you have at your disposal and still easily refer to _slendr_ populations and times of _slendr_ model events. One way to do this would be to edit the built-in _slendr_ SLiM script and manually add your own SLiM code, but that would be brittle and not very reproducible. There's a much better way to do this, leveraging what we call _slendr_/SLiM snippets.

To demonstrate all of this in practice, let's say we want to simulate the allele frequency trajectory of a beneficial mutation which arose on the European lineage (the "EUR" population in our toy model) at 15 thousand years before present. We already know how to add a mutation to a SLiM `Subpopulation` corresponding to the "EUR" _slendr_ population, and we also know how to convert 15 thousand years ago to SLiM's tick units.


```
s100 late() { /* Add a beneficial mutation at a given time */
  // when to add the mutation ("years before present")
  event_time = 15000; 

  // parameters of the beneficial allele
  init_freq = 0.05;
  s = 0.1;    

  // make sure the callback is executed only at the given time point
  if (community.tick != tick(event_time)) return;
  
  // add the beneficial mutation at a given frequency
  eur_genomes = population("EUR").genomes;
  eur_sample = sample(eur_genomes, n = init_freq * length(eur_genomes));
  eur_sample.addNewMutation(m0, s, 0); 

  log_output("Added beneficial mutation at " + event_time + "years ago");
}
```