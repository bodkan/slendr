---
title: "spammr: Introduction and tutorial"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{spammr: Introduction and tutorial}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8,
  fig.height = 6,
  dpi = 150
)
```

## Introduction and motivation











## Installation and setup

First, let's install the latest version of the package and load it:

```{r installation, eval=FALSE}
devtools::install_github("bodkan/spammr")
```

Now we can load it with other R package dependencies:

```{r setup}
#library(spammr)
devtools::load_all("~/projects/spammr")
```


















## Defining the overall world map

Before we do anything else, we need to define a section of the map of the world which will provide context for all downstream spatio-temporal manipulation of population ranges.

In principle, any source of geospatial data which can be manipulated using the [simple features (sf)](https://r-spatial.github.io/sf/) infrastructure could be used. For now the `spammr` package implicitly uses the [Natural Earth](https://www.naturalearthdata.com/) project data (in it's vectorizes form!), which it internally loads using the [rnaturalearth](https://cran.r-project.org/web/packages/rnaturalearth/README.html) interface.

The first function we will look at is `world_map()`, which will load the map of the entire world in a vectorized format and zoom in (in fact, crop) to a specified section of the world.

Note that in the call below, we specify the coordinates of the zoom in a geographical Coordinate Reference System (CRS), i.e. longitude/latitude), but we also specified that we want to perform all the downstream manipulation of the spatial population maps in a projected CRS ([Lambert Azimuthal Equal-Area projection](https://epsg.io/3035)). This is more appropriate for
representing a wider European continent used in this tutorial. Of course, different CRS projection could be used based on which part of the world we want to simulate.

This is the current approach of `spammr`: let the user specify everything in an easy to understand longitude/latitude geographical CRS. However, in case it is necessary, the internal data structures and the final exported spatial maps can be internally handled in a realistic projected CRS which is better for ensuring undistorted distances and proportions.

```{r}
world <- world_map(
  lon = c(-15, 60),  # min-max longitude
  lat = c(20, 65),   # min-max latitude
  crs = "EPSG:3035"  # real projected CRS used internally
)
```

Internally, the `world` object is a normal `sf` class object without additional components. This is unlike other `spammr` object described below, which are also `sf` objects but which carry additional internal components.

Note that the summary of the object says "projected CRS:  ETRS89-extended / LAEA Europe". This means that the world map has indeed been transformed in the projected CRS we specified above.

```{r}
world
```











## Plotting geographical features and population ranges

The `spammr` package implements its own [generic
method](https://adv-r.hadley.nz/s3.html#s3-methods) called `plot()`,
which overrides the default `plot()` function used for [simple
features](https://r-spatial.github.io/sf/index.html) `sf` objects.

We do this in order to make it easier and more convenient to iteratively build more complex models. The function can smartly decide based given input arguments, what is the right way to present the data for the user which helps to define models more quickly without relying on the lower-level mechanisms of the `sf` package.

More on that below, but here we will just plot the world context we just created:

```{r}
plot(world, title = "Zoomed-in world map context")
```











### Defining smaller geographic regions

In addition to the overall spatial map context, we can also define
smaller geographic boundaries. This is mostly useful whenever we want to restrict a population movement (such as spatial population expansion) to a smaller region of the map that has some intuitive geographic meaning (i.e. Anatolia, West Eurasia, etc.).

```{r}
europe_anatolia <- region(
  "Western Europe & Anatolia",
  world,
  coords = list(
    c(-10, 35), c(-5, 35), c(10, 38), c(20, 35), c(38, 35),
    c(40, 40), c(30, 45), c(20, 58), c(-5, 60), c(-15, 50)
  )
)

europe <- region(
  "Western Europe",
  world,
  coords = list(
    c(-8, 35), c(-5, 36), c(10, 38), c(20, 35), c(25, 35),
    c(28, 45), c(20, 58), c(-5, 60), c(-15, 50)
  )
)

anatolia <- region(
  "Anatolia",
  world,
  coords = list(
    c(28, 35), c(40, 35),
    c(42, 40), c(30, 43), c(27, 40), c(25, 38)
  )
)
```

Again, the object returned by the `region()` function is actually a normal `sf` object, but carrying some additional annotation such as the name of the region (here "Anatolia"):

```{r}
anatolia
```

However, the object also carries additional class annotations for the purpose of internal `spammr` machinery:

```{r}
class(anatolia)
```

Furthermore, note that in all `region()` calls we specified the `world` object defined at the very beginning. This object is added as a hidden attribute to each `spammr` object and represents the context for all geospatial transformations, expansions, and plotting.

Again, we can use the generic `plot()` function to plot both geographic regions in the context of the defined section of the world map:

```{r}
plot(europe, anatolia, title = "Geographic regions")
```

Note that the `world` object is no longer explicitly specified. It is not needed, because each other class of objects provided to the `plot()` function must carry it as a "world" attribute. In fact, each such object must carry the same world context - `spammr` complains whenever this is not the case.

We can check that the component is really there, although hidden, and indeed is the same as the world object we created at the beginning:

```{r}
all(attr(europe, "world") == world)
all(attr(anatolia, "world") == world)
```















## Defining spatial population boundaries

### Circular population ranges

The whole point of `spammr` is formalizing the specification of spatial population boundaries and their changes over time. The core function for this is `population()`, which accepts the population `name` and the `time` in which we want to enforce that population's boundary, as well as the `world` object described above. Finally, this function accepts a `center` and `radius` arguments (in case of circular population boundaries):

```{r}
whg <- population(
  name = "WHG",       # population identifier
  time = 25000,       # time in years ago
  world,              # world map 'context' for the population
  center = c(-1, 47), # (longitude, latitude)
  radius = 1300       # radius of a circle in km
)
```

If we call the `plot()` function on the returned object, we have the option to either plot the population range in its "raw" form or in its "rendered" form, in which case the raw boundary is intersected with spatial landscape (removing large bodies of water, etc.).

The 'rendered' form is what is ultimately exported in a serialized form (see below) to be loaded as a spatial map into SLiM. This is why the `plot()` function renders population ranges by default.

```{r}
plot(whg, rendering = F, title = "'Raw' population range")
plot(whg, title = "'Rendered' population range")
```

### Polygonic population ranges

Alternatively, it is also possible to define finer population boundaries using a polygon geometry object (`coords=` argument) or a region object created by the `region()` function above. Again, as a reminder, note that all coordinates are described in the context of the geographic CRS.

```{r}
whg <- population(
  name = "WHG",   # population identifier
  time = 25000,   # time in years ago
  world,          # world map 'context' for the population
  region = europe # geographic region object
)
```

```{r}
plot(whg, rendering = F, title = "'Raw' population range")
plot(whg, title = "'Rendered' population range")
```

Let's create more populations and their boundaries:

```{r}
ana <- population(
  name = "ANA", time = 9000, world,
  center = c(34, 38), radius = 700,
  region = anatolia
)

yam <- population(
  name = "YAM", time = 7000, world,
  coords = list(   # polygon specified using coordinates of vertices
    c(26, 50), c(38, 49), c(48, 50),
    c(48, 56), c(38, 59), c(26, 56)
  )
)

neol <- population(
  name= "NEOL", time = 7000, world,
  center = c(10, 48), radius = 800
)
```













## Spatial population expansion

We can simulate the expanding range of a population using the function `expand()`, which accepts a parameter specifying by how many kilometers should the boundary expand (the `by` argument), how long should the expansion take (the `duration` argument) and how many intermediate spatial map snapshots should be exported representing this expansion (the `snapshots` argument).

For instance, let's represent the expansion of Anatolian farmers (this uses an optional parameter `region` which restricts the expansion only to Europe, instead of all around Anatolia):

```{r}
ana <- ana %>%
  expand(
    by = 2500,
    duration = 5000,
    snapshots = 10,
    region = europe_anatolia
  )
```

Note that in principle, you could specify the entire spatio-temporal history of a population in a single pipeline using the pipe operator `%>%`.

We can inspect the object returned by the `expand()` function and see that it contains he spatial maps ("snapshots") of the expansion process across time:

```{r}
ana
```

We can (and should) check the results visually:

```{r}
plot(ana, title = "Anatolian expansion into Europe")
```

To visually see what is really going on behind the scene, we can produce the complete, unrendered form of the expansion:

```{r}
plot(ana, title = "Anatolian expansion into Europe (not rendered)", rendering = F)
```












## Population migration across the landscape

To specify an explicit population movement (not expansion from a single starting location), we can use the function `migrate()`. This accepts the coordinates of the destination point (`towards`), the `duration` of the migration, and the number of individual spatial maps to save during export (`snapshots`, same as the `expand()` function above):

```{r}
yam <- yam %>%
  migrate(
    towards = c(10, 48), # migrate towards this point
    duration = 1000,     # how many years does the migration take?
    snapshots = 8        # how many intermediate maps should be saved?
)
```

We can inspect the object returned by the `migrate()` function and see that it contains not just the first YAM population range at 7000 years ago, but also the ranges of the intermediate locations:

```{r}
yam
```

Checking the result visually again, we see:

```{r}
plot(yam, title = "Intermediate migration maps")
```



















## Plotting the combined population ranges

The generic function `plot()` can handle a combination of population ranges, and can partition them in individual facets. This is very useful for visual inspection of the specified model and for looking for potential issues before the export of individual spatio-temporal maps.

```{r}
plot(whg, neol, yam, ana)
```














# Rasterization

The ultimate goal of `spammr` is formal specification of spatio-temporal population models for the purpose of forward simulations in SLiM. The crucial piece of machinery which connects the `spammr` R package with SLiM is an Eidos function called `defineSpatialMap()` which, among other parameters, accepts a two-dimensional matrix (essentially, a raster image) describing a spatial simulation landscape.

How do we link the visual (vectorized!) maps shown above to SLiM? The key is a `spammr` function `rasterize()`.

```{r}
x = rasterize(ana, whg)
```

### TODO and open questions

#### 1. How to tie the visual configuration to an explicit admixture graph?

I.e., a population _A_ splitting from a population _B_ at a time _t_, with a _Ne_ of X.

#### 2. How to validate the entire model?

Currently, the "compilation" procedure dumps the spatial maps in a given format on disk. Presumably (having solved item 1. above), we would also save the table of split times, as well as the table of admixture edges _and_ a table of spatial maps.

The compilation process should validate that the configured visual/split/admixture model is meaningful:

a) Population migration maps should overlap to a reasonable degree? I.e. there should be a continuity/overlap between consecutive maps

b) The overlap model should form a directed acyclic graph - there should be no "unreachable" population states.

#### 3. How to actually implement admixture in a spatial context? How to enforce, for instance, that a population _C_ contributed 60% of its ancestry to a population _D_? What sort of meaning does it actually have in the context of spatial maps and how they will be utilized by the backend SLiM script?

#### 4. At which stage should the the user specify SLiM bits relevant to their work?

There's a clear conflict between every SLiM script being tailored to each specific use-case. I will have a nice generic SLiM backend that slurps in the spatial maps, defines population splits and migrations... but that's just the demographic part. Should the user modify that script in SLiM GUI (which is awesome and a big reason to use SLiM in the first place)? This hurts the reproducibility, but I can't reasonably implement an R interface to every possible SLiM use-case.